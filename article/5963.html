<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="游魂的网络日志">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="//www.shen.ee">
    <!--SEO-->

    <meta name="keywords" content="TypeScript,ts,TypeScript高级类型,ts泛型" />


    <meta name="description" content="TypeScript 高级类型TS 中的类型兼容性TS 类型兼容性参考文档
两种类型系统：1 Structural Type System(结构化类型系统) 2 Nominal Type Sys..." />



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />

    <!--Title-->


<title>TypeScript 高级类型 | 游魂的网络日志</title>


    <link rel="alternate" href="/atom.xml" title="游魂的网络日志" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
      var cnzz_s_tag = document.createElement('script');
      cnzz_s_tag.type = 'text/javascript';
      cnzz_s_tag.async = true;
      cnzz_s_tag.charset = 'utf-8';
      cnzz_s_tag.src = cnzz_protocol + 'w.cnzz.com/c.php?id=1272902812&async=1';
      var root_s = document.getElementsByTagName('script')[0];
      root_s.parentNode.insertBefore(cnzz_s_tag, root_s);
		</script>
	</div>






    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(/./img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Andy'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">游魂的网络日志</h2>-->
            
                 <img src="/img/branding.png" alt="游魂的网络日志" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="//www.shen.ee">游魂的网络日志</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/资源/"><i class="fa "></i>资源</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/about/"><i class="fa "></i>关于我</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="TypeScript 高级类型">
            
	            TypeScript 高级类型
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/前端/">前端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/TypeScript/">TypeScript</a> <a class="tag-link" href="/tags/TypeScript高级类型/">TypeScript高级类型</a> <a class="tag-link" href="/tags/ts/">ts</a> <a class="tag-link" href="/tags/ts泛型/">ts泛型</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2022/06/16</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="TypeScript-高级类型"><a href="#TypeScript-高级类型" class="headerlink" title="TypeScript 高级类型"></a>TypeScript 高级类型</h1><h2 id="TS-中的类型兼容性"><a href="#TS-中的类型兼容性" class="headerlink" title="TS 中的类型兼容性"></a>TS 中的类型兼容性</h2><p><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" target="_blank" rel="noopener">TS 类型兼容性参考文档</a></p>
<p>两种类型系统：1 <strong>Structural Type System(结构化类型系统)</strong> 2 Nominal Type System(标明类型系统)</p>
<p><strong>TS 采用的是结构化类型系统，也叫做 duck typing(鸭子类型)，类型检查关注的是值所具有的形状</strong></p>
<p>也就是说，在结构类型系统中，如果两个对象具有相同的形状，则认为它们属于同一类型。比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p: Point = p2;</span><br></pre></td></tr></table></figure>
<p>对于对象类型来说，y 的成员至少与 x 相同，则 x 兼容 y（<strong>成员多的可以赋值给少的</strong>，或者说：只要满足必须的类型就行，多了也没事）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point2D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Point3D &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  z: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3: Point3D = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line"><span class="keyword">let</span> p2: Point2D = p3;</span><br></pre></td></tr></table></figure>
<p>函数类型的类型兼容性比较复杂，需要考虑：1 参数个数 2 返回值类型 等等</p>
<ol>
<li><p>参数个数：参数多的兼容参数少的(或者说，参数少的可以赋值给多的)</p>
<ul>
<li><strong>在 JS 中省略用不到的函数参数实际上是很常见的，这样的使用方式，促成了 TS 中函数类型之间的兼容性</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// arr.forEach 第一个参数的类型为： (value: string, index: number, array: string[]) =&gt; void</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F1 = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> F2 = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：参数少的可以赋值给参数多的</span></span><br><span class="line"><span class="keyword">let</span> f1: F1 = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> f2: F2 = f1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值类型：只要满足必须的类型要求就行，多了也没事</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">const</span> f1: F1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><ul>
<li><strong>泛型（Generics）可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用</strong>，常用于：函数、接口、class 中</li>
<li>需求：创建一个 id 函数，传入什么数据就返回该数据本身（也就是说，参数和返回值类型相同）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，该函数传入什么数值，就返回什么数值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res =&gt; 10</span></span><br><span class="line"><span class="keyword">const</span> res = id(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型</li>
<li>为了能让函数能够接受任意类型的参数，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这时候，就可以使用<strong>泛型</strong>来实现了</li>
<li><strong>泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用</strong></li>
<li>实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一</li>
</ul>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>创建泛型函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以仅使用一个字母来作为类型变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中添加类型变量</strong>，比如此处的 Type</li>
<li><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong></li>
<li><strong>类型变量相当于一个类型容器</strong>，能够捕获用户提供的类型（具体是什么类型由用户调用该函数时指定）</li>
<li>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</li>
<li>类型变量 Type，可以是任意合法的变量名称</li>
</ul>
<p>调用泛型函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数和返回值类型都为：number</span></span><br><span class="line"><span class="keyword">const</span> num = id&lt;<span class="built_in">number</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数和返回值类型都为：string</span></span><br><span class="line"><span class="keyword">const</span> str = id&lt;<span class="built_in">string</span>&gt;(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>（尖括号），<strong>尖括号中指定具体的类型</strong>，比如，此处的 number</li>
<li>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到</li>
<li>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number</li>
<li>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong></li>
</ul>
<h2 id="简化泛型函数调用"><a href="#简化泛型函数调用" class="headerlink" title="简化泛型函数调用"></a>简化泛型函数调用</h2><p>在调用泛型函数时，<strong>可以省略 <code>&lt;类型&gt;</code> 来简化泛型函数的调用</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 &lt;number&gt; 调用函数</span></span><br><span class="line"><span class="keyword">let</span> num = id(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> str = id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型</li>
<li>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</li>
<li>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读</li>
<li>说明：<strong>当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数</strong></li>
</ul>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>默认情况下，泛型函数的类型变量 Type 可以代表任意类型，这导致无法访问任何属性</p>
<p>比如，以下示例代码中想要获取参数的长度：</p>
<ul>
<li>因为 Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length。因此，无法访问 length 属性</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意：此处会报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>
<p>此时，就需要<strong>为泛型添加约束来<code>收缩类型</code>（缩窄类型取值范围）</strong></p>
<p>添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型 2 添加约束</p>
<p>首先，我们先来看第一种情况，如何指定更加具体的类型：</p>
<p>比如，将类型修改为 <code>Type[]</code>(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span>&gt;(<span class="params">value: Type[]</span>): <span class="title">Type</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 可以正确访问</span></span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加泛型约束"><a href="#添加泛型约束" class="headerlink" title="添加泛型约束"></a>添加泛型约束</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义类型</span></span><br><span class="line"><span class="keyword">interface</span> ILength &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type extends ILength 添加泛型约束</span></span><br><span class="line"><span class="comment">// 解释：表示传入的类型必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">value: Type</span>): <span class="title">Type</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value.length);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ul>
<li>创建描述约束的接口 ILength，该接口要求提供 length 属性</li>
<li>通过 <code>extends</code> 关键字来为泛型（类型变量）添加约束</li>
<li>该约束表示：<strong>传入的类型必须具有 length 属性</strong></li>
<li>注意：传入的实参（比如，数组）只要有 length 属性即可（类型兼容性)</li>
</ul>
<h2 id="多个类型变量的泛型"><a href="#多个类型变量的泛型" class="headerlink" title="多个类型变量的泛型"></a>多个类型变量的泛型</h2><p>泛型的类型变量可以有多个，并且<strong>类型变量之间还可以约束</strong>(比如，第二个类型变量受第一个类型变量约束) 比如，创建一个函数来获取对象中属性的值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">Type</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params">obj: Type, key: Key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; name: <span class="string">'jack'</span>, age: <span class="number">18</span> &#125;;</span><br><span class="line">getProp(person, <span class="string">'name'</span>);</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<ol>
<li>添加了第二个类型变量 Key，两个类型变量之间使用 <code>,</code> 逗号分隔。</li>
<li><strong>keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型</strong>。</li>
<li>本示例中 <code>keyof Type</code> 实际上获取的是 person 对象所有键的联合类型，也就是：<code>&#39;name&#39; | &#39;age&#39;</code></li>
<li>类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错</span></span><br><span class="line"><span class="comment">// 如果要用到 对象 类型，应该用 object ，而不是 Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">Type</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">Key</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">Type</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Type,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: Key,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IdFunc&lt;Type&gt; &#123;</span><br><span class="line">  id: <span class="function">(<span class="params">value: Type</span>) =&gt;</span> Type;</span><br><span class="line">  ids: <span class="function"><span class="params">()</span> =&gt;</span> Type[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: IdFunc&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  id(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  ids() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li>在接口名称的后面添加 <code>&lt;类型变量&gt;</code>，那么，这个接口就变成了泛型接口。</li>
<li>接口的类型变量，对接口中所有其他成员可见，也就是<strong>接口中所有成员都可以使用类型变量</strong>。</li>
<li>使用泛型接口时，<strong>需要显式指定具体的类型</strong>(比如，此处的 IdFunc)。</li>
<li>此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。</li>
</ol>
<p>实际上，JS 中的数组在 TS 中就是一个泛型接口</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strs = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">strs.forEach;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 鼠标放在 forEach 上查看类型</span></span><br><span class="line">nums.forEach;</span><br></pre></td></tr></table></figure>
<ul>
<li>解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型</li>
<li>技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息</li>
</ul>
<h2 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h2><p>泛型工具类型：TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作</p>
<p>说明：它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:</p>
<ol>
<li><code>Partial&lt;Type&gt;</code></li>
<li><code>Readonly&lt;Type&gt;</code></li>
<li><code>Pick&lt;Type, Keys&gt;</code></li>
</ol>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank" rel="noopener">TS 所有内置的泛型工具类型文档</a></li>
</ul>
<h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><ul>
<li>Partial 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialProps = Partial&lt;Props&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。</li>
</ul>
<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><ul>
<li>Readonly 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadonlyProps = Readonly&lt;Props&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> props: ReadonlyProps = &#123; id: <span class="string">'1'</span>, children: [] &#125;;</span><br><span class="line"><span class="comment">// 错误演示</span></span><br><span class="line">props.id = <span class="string">'2'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们想重新给 id 属性赋值时，就会报错:无法分配到 “id” ，因为它是只读属性。</li>
</ul>
<h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><ul>
<li>Pick<type, keys=""> 从 Type 中选择一组属性来构造新类型。</type,></li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  children: <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PickProps = Pick&lt;Props, <span class="string">'id'</span> | <span class="string">'title'</span>&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>解释:<ol>
<li>Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。</li>
<li>其中第二个类型变量，如果只选择一个则只传入该属性名即可，如果有多个使用联合类型即可。</li>
<li>第二个类型变量传入的属性只能是第一个类型变量中存在的属性。</li>
<li>构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。</li>
</ol>
</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">游魂的网络日志</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/article/32125.html" class="pre-post btn btn-default" title='TypeScript 常用类型'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">TypeScript 常用类型</span>
        </a>
    
    
        <a href="/article/16686.html" class="next-post btn btn-default" title='React系列学习教程合集'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">React系列学习教程合集</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	<link rel="stylesheet" href="https://cdn.bootcss.com/gitalk/1.4.1/gitalk.min.css">
<script src="//cdn.bootcss.com/gitalk/1.4.1/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.9.0/js/md5.min.js"></script>

<div id="gitalk-container"></div>
<script type="text/javascript">
    var pathArr = location.pathname.split("/");
    var pathId = pathArr[pathArr.length-1];
    var gitalk = new Gitalk({
        // Gitalk配置
        language: "zh-CN",
        clientID: "7f009ecacf6f9ef23c4f",
        clientSecret: "37f121ac84806a529cfb6f410e86b869384ecc56",
        repo: "youhunwl.github.io",
        owner: "youhunwl",
        admin: ["youhunwl"],
        id: md5(location.pathname),
        distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
</script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-高级类型"><span class="toc-text">TypeScript 高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TS-中的类型兼容性"><span class="toc-text">TS 中的类型兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型概述"><span class="toc-text">泛型概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型函数"><span class="toc-text">泛型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#简化泛型函数调用"><span class="toc-text">简化泛型函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型约束"><span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加泛型约束"><span class="toc-text">添加泛型约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多个类型变量的泛型"><span class="toc-text">多个类型变量的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型接口"><span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型工具类型"><span class="toc-text">泛型工具类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial"><span class="toc-text">Partial</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Readonly"><span class="toc-text">Readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pick"><span class="toc-text">Pick</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017 - 2022
                </span> |
                <span>
            		<a href="//www.shen.ee" class="copyright-links" target="_blank">游魂的网络日志</a>
        	</span>
            </div>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#444', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: false || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>




<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>